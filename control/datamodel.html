<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>control.datamodel API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>control.datamodel</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/43bd2e150961ad81f2af6575b1c8f269a7e20738/src/pure3d/control/datamodel.py#L1-L598" class="git-link">Browse git</a>
</summary>
<pre><code class="python">from markdown import markdown

from control.generic import AttrDict
from control.html import HtmlElements as H


class Datamodel:
    def __init__(self, Settings, Messages, Mongo):
        &#34;&#34;&#34;Datamodel related operations.

        This class has methods to manipulate various pieces of content
        in the data sources, and hand it over to higher level objects.

        It can find out dependencies between related records, and it knows
        a thing or two about fields.

        It is instantiated by a singleton object.

        It has a method which is a factory for `control.datamodel.Field` objects,
        which deal with individual fields.

        Likewise it has a factory function for `control.datamodel.Upload` objects,
        which deal with file uploads.

        Parameters
        ----------
        Settings: `control.generic.AttrDict`
            App-wide configuration data obtained from
            `control.config.Config.Settings`.
        Messages: object
            Singleton instance of `control.messages.Messages`.
        Mongo: object
            Singleton instance of `control.mongo.Mongo`.
        &#34;&#34;&#34;
        self.Settings = Settings
        self.Messages = Messages
        Messages.debugAdd(self)
        self.Mongo = Mongo

        datamodel = Settings.datamodel
        self.masterConfig = datamodel.master
        self.linkConfig = datamodel.link
        self.fieldsConfig = datamodel.fields
        self.uploadsConfig = datamodel.uploads
        self.fieldObjects = AttrDict()
        self.uploadObjects = AttrDict()

    def getDetailRecords(self, masterTable, masterId):
        &#34;&#34;&#34;Retrieve the detail records of a master record.

        It finds all records that have a field containing an id of the
        given master record.

        Details are not retrieved recursively, only the direct details
        of a master are fetched.

        Parameters
        ----------
        masterTable: string
            The name of the table in which the master record lives.
        masterId: ObjectId
            The id of the master record.

        Returns
        -------
        AttrDict
            The list of detail records, categorized by detail table in which
            they occur. The detail tables are the keys, the lists of records
            in those tables are the values.
            If the master record cannot be found or if there are no detail
            records, the empty dict is returned.
        &#34;&#34;&#34;
        Mongo = self.Mongo
        masterConfig = self.masterConfig

        detailTables = masterConfig.get(masterTable, [])

        crit = {f&#34;{masterTable.rstrip(&#39;s&#39;)}Id&#34;: masterId}

        detailRecords = AttrDict()

        for detailTable in detailTables:
            details = Mongo.getList(detailTable, **crit)
            if len(details):
                detailRecords[detailTable] = details

        return detailRecords

    def makeField(self, key):
        &#34;&#34;&#34;Make a field object and registers it.

        An instance of class `control.datamodel.Field` is created,
        geared to this particular field.

        !!! note &#34;Idempotent&#34;
            If the Field object is already registered, nothing is done.

        Parameters
        ----------
        key: string
            Identifier for the field.
            The configuration for this field will be retrieved using this key.
            The new field object will be stored under this key.

        Returns
        -------
        object
            The resulting Field object.
            It is also added to the `fieldObjects` member.
        &#34;&#34;&#34;
        Settings = self.Settings

        fieldObjects = self.fieldObjects

        fieldObject = fieldObjects[key]
        if fieldObject:
            return fieldObject

        Messages = self.Messages
        Mongo = self.Mongo
        fieldsConfig = self.fieldsConfig

        fieldsConfig = fieldsConfig[key]
        if fieldsConfig is None:
            Messages.error(logmsg=f&#34;Unknown field key &#39;{key}&#39;&#34;)

        fieldObject = Field(Settings, Messages, Mongo, key, **fieldsConfig)
        fieldObjects[key] = fieldObject
        return fieldObject

    def makeUpload(self, key):
        &#34;&#34;&#34;Make a file upload object and registers it.

        An instance of class `control.datamodel.Upload` is created,
        geared to this particular field.

        !!! note &#34;Idempotent&#34;
            If the Upload object is already registered, nothing is done.

        Parameters
        ----------
        key: string
            Identifier for the upload.
            The configuration for this upload will be retrieved using this key.
            The new upload object will be stored under this key.

        Returns
        -------
        object
            The resulting Upload object.
            It is also added to the `uploadObjects` member.
        &#34;&#34;&#34;
        Settings = self.Settings

        uploadObjects = self.uploadObjects

        uploadObject = uploadObjects[key]
        if uploadObject:
            return uploadObject

        Messages = self.Messages
        Mongo = self.Mongo
        uploadsConfig = self.uploadsConfig

        uploadsConfig = uploadsConfig[key]
        if uploadsConfig is None:
            Messages.error(logmsg=f&#34;Unknown upload key &#39;{key}&#39;&#34;)

        uploadObject = Upload(Settings, Messages, Mongo, key, **uploadsConfig)
        uploadObjects[key] = uploadObject
        return uploadObject


class Field:
    def __init__(self, Settings, Messages, Mongo, key, **kwargs):
        &#34;&#34;&#34;Handle field business.

        A Field object does not correspond with an individual field in a record.
        It represents a *column*, i.e. a set of fields with the same name in all
        records of a collection.

        First of all there is a method to retrieve the value of the field from
        a specific record.

        Then there are methods to deliver those values, either bare or formatted,
        to produce edit widgets to modify the values, and handlers to save
        values.

        How to do this is steered by the specification of the field by keys and
        values that are stored in this object.

        All field access should be guarded by the authorisation rules.

        Parameters
        ----------
        kwargs: dict
            Field configuration arguments.
            It certain parts of the field configuration
            are not present, defaults will be provided.
        &#34;&#34;&#34;
        self.Settings = Settings
        self.Messages = Messages
        Messages.debugAdd(self)
        self.Mongo = Mongo

        self.key = key
        &#34;&#34;&#34;The identifier of this field within the app.
        &#34;&#34;&#34;

        self.nameSpace = &#34;&#34;
        &#34;&#34;&#34;The first key to access the field data in a record.

        Example `dc` (Dublin Core). So if a record has Dublin Core
        metadata, we expect that metadata to exist under key `dc` in that record.

        If the namespace is `&#34;&#34;`, it is assumed that we can dig up the values without
        going into a namespace subdocument first.
        &#34;&#34;&#34;

        self.fieldPath = key
        &#34;&#34;&#34;Compound selector in a nested dict.

        A string of keys, separated by `.`, which will be used to drill down
        into a nested dict. At the end of the path we find the selected value.

        This field selection is applied after the name space selection
        (if `nameSpace` is not the empty string).
        &#34;&#34;&#34;

        self.tp = &#34;string&#34;
        &#34;&#34;&#34;The value type of the field.

        Value types can be string, integer, but also date times, and values
        from an other collection (value lists).
        &#34;&#34;&#34;

        self.caption = key
        &#34;&#34;&#34;A caption that may be displayed with the field value.

        The caption may be a literal string with or without a placeholder `{}`.

        If there is no place holder, the caption will precede the content of
        the field.

        If there is a placeholder, the content will replace the place holder
        in the caption.
        &#34;&#34;&#34;

        for (arg, value) in kwargs.items():
            if value is not None:
                setattr(self, arg, value)

    def logical(self, record):
        &#34;&#34;&#34;Give the logical value of the field in a record.

        Parameters
        ----------
        record: AttrDict or dict
            The record in which the field value is stored.

        Returns
        -------
        any:
            Whatever the value is that we find for that field.
            No conversion/casting to other types will be performed.
            If the field is not present, returns None, without warning.
        &#34;&#34;&#34;
        nameSpace = self.nameSpace
        fieldPath = self.fieldPath

        fields = fieldPath.split(&#34;.&#34;)

        dataSource = record.get(nameSpace, {}) if nameSpace else record

        for field in fields[0:-1]:
            dataSource = dataSource.get(field, None)
            if dataSource is None:
                break

        value = None if dataSource is None else dataSource.get(fields[-1], None)
        return value

    def bare(self, record):
        &#34;&#34;&#34;Give the bare string value of the field in a record.

        Parameters
        ----------
        record: AttrDict or dict
            The record in which the field value is stored.

        Returns
        -------
        string:
            Whatever the value is that we find for that field, converted to string.
            If the field is not present, returns the empty string, without warning.
        &#34;&#34;&#34;
        logical = self.logical(record)
        return &#34;&#34; if logical is None else str(logical)

    def formatted(
        self,
        table,
        record,
        level=None,
        button=&#34;&#34;,
        outerCls=&#34;fieldouter&#34;,
        innerCls=&#34;fieldinner&#34;,
    ):
        &#34;&#34;&#34;Give the formatted value of the field in a record.

        Optionally also puts a caption and/or an edit control.

        The value retrieved is (recursively) wrapped in HTML, steered by additional
        argument, as in `control.html.HtmlElements.wrapValue`.
        be applied.

        If the type is &#39;text&#39;, multiple values will simply be concatenated
        with newlines in between, and no extra classes will be applied.
        Instead, a markdown formatter is applied to the result.

        For other types:

        If the value is an iterable, each individual value is wrapped in a span
        to which an (other) extra CSS class may be applied.

        Parameters
        ----------
        table: string
            The table from which the record is taken
        record: AttrDict or dict
            The record in which the field value is stored.
        level: integer, optional None
            The heading level in which a caption will be placed.
            If None, no caption will be placed.
            If 0, the caption will be placed in a span.
        button: string, optional &#34;&#34;
            An optional edit button.
        outerCls: string optional &#34;fieldouter&#34;
            If given, an extra CSS class for the outer element that wraps the total
            value. Only relevant if the type is not &#39;text&#39;
        innerCls: string optional &#34;fieldinner&#34;
            If given, an extra CSS class for the inner elements that wrap parts of the
            value. Only relevant if the type is not &#39;text&#39;

        Returns
        -------
        string:
            Whatever the value is that we find for that field, converted to HTML.
            If the field is not present, returns the empty string, without warning.
        &#34;&#34;&#34;
        tp = self.tp
        caption = self.caption

        logical = self.logical(record)

        if tp == &#34;text&#34;:
            content = markdown(H.content(logical), tight=False)
        else:
            content = H.wrapValue(
                logical,
                outerElem=&#34;span&#34;,
                outerAtts=dict(cls=outerCls),
                innerElem=&#34;span&#34;,
                innerAtts=dict(cls=innerCls),
            )
        sep = &#34;&amp;nbsp;&#34; if button else &#34;&#34;

        content = f&#34;{button}{sep}{content}&#34;

        if level is not None:
            if &#34;{value}&#34; in caption:
                kind = table.rstrip(&#34;s&#34;)
                heading = caption.format(kind=kind, value=content)
                content = &#34;&#34;
            else:
                heading = caption

            if level == 0:
                elem = &#34;span&#34;
                lv = []
            else:
                elem = &#34;h&#34;
                lv = [level]
            heading = H.elem(elem, *lv, heading)

        return heading + content


class Upload:
    def __init__(self, Settings, Messages, Mongo, key, **kwargs):
        &#34;&#34;&#34;Handle upload business.

        An upload is like a field of type &#39;file&#39;.
        The name of the uploaded file is stored in a record in MongoDb.
        The contents of the file is stored on the file system.

        A Upload object does not correspond with an individual field in a record.
        It represents a *column*, i.e. a set of fields with the same name in all
        records of a collection.

        First of all there is a method to retrieve the file name of an upload from
        a specific record.

        Then there are methods to deliver those values, either bare or formatted,
        to produce widgets to upload or delete the corresponding files.

        How to do this is steered by the specification of the upload by keys and
        values that are stored in this object.

        All upload access should be guarded by the authorisation rules.

        Parameters
        ----------
        kwargs: dict
            Field configuration arguments.
            The following parts of the field configuration
            should be present: `table`, `field` and `relative`.
        &#34;&#34;&#34;
        self.Settings = Settings
        self.Messages = Messages
        Messages.debugAdd(self)
        self.Mongo = Mongo

        self.key = key
        &#34;&#34;&#34;The identifier of this upload within the app.
        &#34;&#34;&#34;

        self.table = None
        &#34;&#34;&#34;The table in which the file name should be placed.
        &#34;&#34;&#34;

        self.field = None
        &#34;&#34;&#34;The field in which the file name should be placed.
        &#34;&#34;&#34;

        self.relative = None
        &#34;&#34;&#34;Indicates the directory where the actual file will be saved.

        Possibe values:

        * `site`: top level of the working data directory of the site
        * `project`: project directory of the project in question
        * `edition`: edition directory of the project in question

        If left out, the value will be derived from `table`.
        &#34;&#34;&#34;

        self.accept = None
        &#34;&#34;&#34;The file types that the field accepts.
        &#34;&#34;&#34;

        self.caption = None
        &#34;&#34;&#34;The text to display on the upload button.
        &#34;&#34;&#34;

        self.show = None
        &#34;&#34;&#34;Whether to show the contents of the file.

        This is typically the case when the file is an image to be presented
        as a logo.
        &#34;&#34;&#34;

        # let attributes be filled in from the function **kwargs

        for (arg, value) in kwargs.items():
            if value is not None:
                setattr(self, arg, value)

        # try to fill in defaults for attributes that are still None

        good = True

        table = getattr(self, &#34;table&#34;, None)
        field = getattr(self, &#34;field&#34;, None)
        accept = getattr(self, &#34;accept&#34;, None)

        for arg in (&#34;table&#34;, &#34;field&#34;, &#34;relative&#34;, &#34;accept&#34;, &#34;caption&#34;, &#34;show&#34;):
            if getattr(self, arg, None) is None:
                if arg == &#34;relative&#34; and table is not None:
                    setattr(self, arg, table.removesuffix(&#34;s&#34;))
                elif arg == &#34;caption&#34;:
                    setattr(self, arg, f&#34;{table}-{field}-{accept}&#34;)
                elif arg == &#34;show&#34;:
                    setattr(self, arg, False)
                else:
                    Messages.error(logmsg=f&#34;Missing info in Upload spec: {arg}&#34;)
                    good = False

        if not good:
            quit()

    def bare(self, record):
        &#34;&#34;&#34;Give the bare file name as stored in a record in MongoDb.

        Parameters
        ----------
        record: AttrDict
            The record in which the file name is stored.

        Returns
        -------
        string:
            Whatever the value is that we find.
            If the field is not present, returns None, without warning.
        &#34;&#34;&#34;
        field = self.field

        return record[field]

    def getPath(self, record):
        &#34;&#34;&#34;Give the path to the file in question.

        The path can be used to build the static url and the save url.

        It does not contain the file name.
        If the path is non-empty, a &#34;/&#34; will be appended.
        &#34;&#34;&#34;
        table = self.table
        relative = self.relative

        recordId = record._id
        projectId = recordId if table == &#34;projects&#34; else record.projectId
        editionId = recordId if table == &#34;editions&#34; else record.editionId

        path = (
            &#34;&#34;
            if relative == &#34;site&#34;
            else f&#34;projects/{projectId}&#34;
            if relative == &#34;project&#34;
            else f&#34;projects/{projectId}/editions/{editionId}&#34;
            if relative == &#34;edition&#34;
            else None
        )
        sep = &#34;/&#34; if path else &#34;&#34;
        return f&#34;{path}{sep}&#34;

    def formatted(self, record, mayChange=False):
        &#34;&#34;&#34;Give the formatted value of a file field in a record.

        Optionally also puts an upload control.

        Parameters
        ----------
        record: AttrDict or dict
            The record in which the field value is stored.
        mayChange: boolean, optional False
            Whether the file may be changed.
            If so, an upload widget is supplied, wich contains a a delete button.

        Returns
        -------
        string:
            Whatever the value is that we find for that field, converted to HTML.
            If the field is not present, returns the empty string, without warning.
        &#34;&#34;&#34;

        fileName = self.bare(record)

        Messages = self.Messages

        key = self.key
        table = self.table
        field = self.field
        relative = self.relative
        accept = self.accept
        caption = self.caption
        show = self.show

        title = f&#34;click to upload a {caption}&#34;

        recordId = record._id

        fid = f&#34;{table}/{recordId}/{field}&#34;

        path = self.getPath(record)
        if path is None:
            Messages.warning(
                logmsg=f&#34;Wrong file path for upload {key} based on relative {relative}&#34;,
                msg=&#34;The location for this file cannot be determined&#34;,
            )

        if show:
            staticUrl = f&#34;/data/{path}{fileName}&#34;
            img = H.img(staticUrl, fid=fid)
        else:
            img = &#34;&#34;

        visual = img or H.span(fileName, cls=&#34;fieldinner&#34;)

        if not mayChange:
            return visual

        sep = &#34;/&#34; if path else &#34;&#34;
        saveUrl = f&#34;/upload/{fid}{sep}{path}&#34;

        return H.content(
            visual, H.finput(fileName, accept, saveUrl, show=show, fid=fid, title=title)
        )</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="control.datamodel.Datamodel"><code class="flex name class">
<span>class <span class="ident">Datamodel</span></span>
<span>(</span><span>Settings, Messages, Mongo)</span>
</code></dt>
<dd>
<div class="desc"><p>Datamodel related operations.</p>
<p>This class has methods to manipulate various pieces of content
in the data sources, and hand it over to higher level objects.</p>
<p>It can find out dependencies between related records, and it knows
a thing or two about fields.</p>
<p>It is instantiated by a singleton object.</p>
<p>It has a method which is a factory for <code><a title="control.datamodel.Field" href="#control.datamodel.Field">Field</a></code> objects,
which deal with individual fields.</p>
<p>Likewise it has a factory function for <code><a title="control.datamodel.Upload" href="#control.datamodel.Upload">Upload</a></code> objects,
which deal with file uploads.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>Settings</code></strong> :&ensp;<code><a title="control.generic.AttrDict" href="generic.html#control.generic.AttrDict">AttrDict</a></code></dt>
<dd>App-wide configuration data obtained from
<code><a title="control.config.Config.Settings" href="config.html#control.config.Config.Settings">Config.Settings</a></code>.</dd>
<dt><strong><code>Messages</code></strong> :&ensp;<code>object</code></dt>
<dd>Singleton instance of <code><a title="control.messages.Messages" href="messages.html#control.messages.Messages">Messages</a></code>.</dd>
<dt><strong><code>Mongo</code></strong> :&ensp;<code>object</code></dt>
<dd>Singleton instance of <code><a title="control.mongo.Mongo" href="mongo.html#control.mongo.Mongo">Mongo</a></code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/43bd2e150961ad81f2af6575b1c8f269a7e20738/src/pure3d/control/datamodel.py#L7-L171" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Datamodel:
    def __init__(self, Settings, Messages, Mongo):
        &#34;&#34;&#34;Datamodel related operations.

        This class has methods to manipulate various pieces of content
        in the data sources, and hand it over to higher level objects.

        It can find out dependencies between related records, and it knows
        a thing or two about fields.

        It is instantiated by a singleton object.

        It has a method which is a factory for `control.datamodel.Field` objects,
        which deal with individual fields.

        Likewise it has a factory function for `control.datamodel.Upload` objects,
        which deal with file uploads.

        Parameters
        ----------
        Settings: `control.generic.AttrDict`
            App-wide configuration data obtained from
            `control.config.Config.Settings`.
        Messages: object
            Singleton instance of `control.messages.Messages`.
        Mongo: object
            Singleton instance of `control.mongo.Mongo`.
        &#34;&#34;&#34;
        self.Settings = Settings
        self.Messages = Messages
        Messages.debugAdd(self)
        self.Mongo = Mongo

        datamodel = Settings.datamodel
        self.masterConfig = datamodel.master
        self.linkConfig = datamodel.link
        self.fieldsConfig = datamodel.fields
        self.uploadsConfig = datamodel.uploads
        self.fieldObjects = AttrDict()
        self.uploadObjects = AttrDict()

    def getDetailRecords(self, masterTable, masterId):
        &#34;&#34;&#34;Retrieve the detail records of a master record.

        It finds all records that have a field containing an id of the
        given master record.

        Details are not retrieved recursively, only the direct details
        of a master are fetched.

        Parameters
        ----------
        masterTable: string
            The name of the table in which the master record lives.
        masterId: ObjectId
            The id of the master record.

        Returns
        -------
        AttrDict
            The list of detail records, categorized by detail table in which
            they occur. The detail tables are the keys, the lists of records
            in those tables are the values.
            If the master record cannot be found or if there are no detail
            records, the empty dict is returned.
        &#34;&#34;&#34;
        Mongo = self.Mongo
        masterConfig = self.masterConfig

        detailTables = masterConfig.get(masterTable, [])

        crit = {f&#34;{masterTable.rstrip(&#39;s&#39;)}Id&#34;: masterId}

        detailRecords = AttrDict()

        for detailTable in detailTables:
            details = Mongo.getList(detailTable, **crit)
            if len(details):
                detailRecords[detailTable] = details

        return detailRecords

    def makeField(self, key):
        &#34;&#34;&#34;Make a field object and registers it.

        An instance of class `control.datamodel.Field` is created,
        geared to this particular field.

        !!! note &#34;Idempotent&#34;
            If the Field object is already registered, nothing is done.

        Parameters
        ----------
        key: string
            Identifier for the field.
            The configuration for this field will be retrieved using this key.
            The new field object will be stored under this key.

        Returns
        -------
        object
            The resulting Field object.
            It is also added to the `fieldObjects` member.
        &#34;&#34;&#34;
        Settings = self.Settings

        fieldObjects = self.fieldObjects

        fieldObject = fieldObjects[key]
        if fieldObject:
            return fieldObject

        Messages = self.Messages
        Mongo = self.Mongo
        fieldsConfig = self.fieldsConfig

        fieldsConfig = fieldsConfig[key]
        if fieldsConfig is None:
            Messages.error(logmsg=f&#34;Unknown field key &#39;{key}&#39;&#34;)

        fieldObject = Field(Settings, Messages, Mongo, key, **fieldsConfig)
        fieldObjects[key] = fieldObject
        return fieldObject

    def makeUpload(self, key):
        &#34;&#34;&#34;Make a file upload object and registers it.

        An instance of class `control.datamodel.Upload` is created,
        geared to this particular field.

        !!! note &#34;Idempotent&#34;
            If the Upload object is already registered, nothing is done.

        Parameters
        ----------
        key: string
            Identifier for the upload.
            The configuration for this upload will be retrieved using this key.
            The new upload object will be stored under this key.

        Returns
        -------
        object
            The resulting Upload object.
            It is also added to the `uploadObjects` member.
        &#34;&#34;&#34;
        Settings = self.Settings

        uploadObjects = self.uploadObjects

        uploadObject = uploadObjects[key]
        if uploadObject:
            return uploadObject

        Messages = self.Messages
        Mongo = self.Mongo
        uploadsConfig = self.uploadsConfig

        uploadsConfig = uploadsConfig[key]
        if uploadsConfig is None:
            Messages.error(logmsg=f&#34;Unknown upload key &#39;{key}&#39;&#34;)

        uploadObject = Upload(Settings, Messages, Mongo, key, **uploadsConfig)
        uploadObjects[key] = uploadObject
        return uploadObject</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="control.content.Content" href="content.html#control.content.Content">Content</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="control.datamodel.Datamodel.getDetailRecords"><code class="name flex">
<span>def <span class="ident">getDetailRecords</span></span>(<span>self, masterTable, masterId)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve the detail records of a master record.</p>
<p>It finds all records that have a field containing an id of the
given master record.</p>
<p>Details are not retrieved recursively, only the direct details
of a master are fetched.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>masterTable</code></strong> :&ensp;<code>string</code></dt>
<dd>The name of the table in which the master record lives.</dd>
<dt><strong><code>masterId</code></strong> :&ensp;<code>ObjectId</code></dt>
<dd>The id of the master record.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>AttrDict</code></dt>
<dd>The list of detail records, categorized by detail table in which
they occur. The detail tables are the keys, the lists of records
in those tables are the values.
If the master record cannot be found or if there are no detail
records, the empty dict is returned.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/43bd2e150961ad81f2af6575b1c8f269a7e20738/src/pure3d/control/datamodel.py#L48-L87" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getDetailRecords(self, masterTable, masterId):
    &#34;&#34;&#34;Retrieve the detail records of a master record.

    It finds all records that have a field containing an id of the
    given master record.

    Details are not retrieved recursively, only the direct details
    of a master are fetched.

    Parameters
    ----------
    masterTable: string
        The name of the table in which the master record lives.
    masterId: ObjectId
        The id of the master record.

    Returns
    -------
    AttrDict
        The list of detail records, categorized by detail table in which
        they occur. The detail tables are the keys, the lists of records
        in those tables are the values.
        If the master record cannot be found or if there are no detail
        records, the empty dict is returned.
    &#34;&#34;&#34;
    Mongo = self.Mongo
    masterConfig = self.masterConfig

    detailTables = masterConfig.get(masterTable, [])

    crit = {f&#34;{masterTable.rstrip(&#39;s&#39;)}Id&#34;: masterId}

    detailRecords = AttrDict()

    for detailTable in detailTables:
        details = Mongo.getList(detailTable, **crit)
        if len(details):
            detailRecords[detailTable] = details

    return detailRecords</code></pre>
</details>
</dd>
<dt id="control.datamodel.Datamodel.makeField"><code class="name flex">
<span>def <span class="ident">makeField</span></span>(<span>self, key)</span>
</code></dt>
<dd>
<div class="desc"><p>Make a field object and registers it.</p>
<p>An instance of class <code><a title="control.datamodel.Field" href="#control.datamodel.Field">Field</a></code> is created,
geared to this particular field.</p>
<div class="admonition note">
<p class="admonition-title">Idempotent</p>
<p>If the Field object is already registered, nothing is done.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>key</code></strong> :&ensp;<code>string</code></dt>
<dd>Identifier for the field.
The configuration for this field will be retrieved using this key.
The new field object will be stored under this key.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>object</code></dt>
<dd>The resulting Field object.
It is also added to the <code>fieldObjects</code> member.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/43bd2e150961ad81f2af6575b1c8f269a7e20738/src/pure3d/control/datamodel.py#L89-L129" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def makeField(self, key):
    &#34;&#34;&#34;Make a field object and registers it.

    An instance of class `control.datamodel.Field` is created,
    geared to this particular field.

    !!! note &#34;Idempotent&#34;
        If the Field object is already registered, nothing is done.

    Parameters
    ----------
    key: string
        Identifier for the field.
        The configuration for this field will be retrieved using this key.
        The new field object will be stored under this key.

    Returns
    -------
    object
        The resulting Field object.
        It is also added to the `fieldObjects` member.
    &#34;&#34;&#34;
    Settings = self.Settings

    fieldObjects = self.fieldObjects

    fieldObject = fieldObjects[key]
    if fieldObject:
        return fieldObject

    Messages = self.Messages
    Mongo = self.Mongo
    fieldsConfig = self.fieldsConfig

    fieldsConfig = fieldsConfig[key]
    if fieldsConfig is None:
        Messages.error(logmsg=f&#34;Unknown field key &#39;{key}&#39;&#34;)

    fieldObject = Field(Settings, Messages, Mongo, key, **fieldsConfig)
    fieldObjects[key] = fieldObject
    return fieldObject</code></pre>
</details>
</dd>
<dt id="control.datamodel.Datamodel.makeUpload"><code class="name flex">
<span>def <span class="ident">makeUpload</span></span>(<span>self, key)</span>
</code></dt>
<dd>
<div class="desc"><p>Make a file upload object and registers it.</p>
<p>An instance of class <code><a title="control.datamodel.Upload" href="#control.datamodel.Upload">Upload</a></code> is created,
geared to this particular field.</p>
<div class="admonition note">
<p class="admonition-title">Idempotent</p>
<p>If the Upload object is already registered, nothing is done.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>key</code></strong> :&ensp;<code>string</code></dt>
<dd>Identifier for the upload.
The configuration for this upload will be retrieved using this key.
The new upload object will be stored under this key.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>object</code></dt>
<dd>The resulting Upload object.
It is also added to the <code>uploadObjects</code> member.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/43bd2e150961ad81f2af6575b1c8f269a7e20738/src/pure3d/control/datamodel.py#L131-L171" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def makeUpload(self, key):
    &#34;&#34;&#34;Make a file upload object and registers it.

    An instance of class `control.datamodel.Upload` is created,
    geared to this particular field.

    !!! note &#34;Idempotent&#34;
        If the Upload object is already registered, nothing is done.

    Parameters
    ----------
    key: string
        Identifier for the upload.
        The configuration for this upload will be retrieved using this key.
        The new upload object will be stored under this key.

    Returns
    -------
    object
        The resulting Upload object.
        It is also added to the `uploadObjects` member.
    &#34;&#34;&#34;
    Settings = self.Settings

    uploadObjects = self.uploadObjects

    uploadObject = uploadObjects[key]
    if uploadObject:
        return uploadObject

    Messages = self.Messages
    Mongo = self.Mongo
    uploadsConfig = self.uploadsConfig

    uploadsConfig = uploadsConfig[key]
    if uploadsConfig is None:
        Messages.error(logmsg=f&#34;Unknown upload key &#39;{key}&#39;&#34;)

    uploadObject = Upload(Settings, Messages, Mongo, key, **uploadsConfig)
    uploadObjects[key] = uploadObject
    return uploadObject</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="control.datamodel.Field"><code class="flex name class">
<span>class <span class="ident">Field</span></span>
<span>(</span><span>Settings, Messages, Mongo, key, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Handle field business.</p>
<p>A Field object does not correspond with an individual field in a record.
It represents a <em>column</em>, i.e. a set of fields with the same name in all
records of a collection.</p>
<p>First of all there is a method to retrieve the value of the field from
a specific record.</p>
<p>Then there are methods to deliver those values, either bare or formatted,
to produce edit widgets to modify the values, and handlers to save
values.</p>
<p>How to do this is steered by the specification of the field by keys and
values that are stored in this object.</p>
<p>All field access should be guarded by the authorisation rules.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Field configuration arguments.
It certain parts of the field configuration
are not present, defaults will be provided.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/43bd2e150961ad81f2af6575b1c8f269a7e20738/src/pure3d/control/datamodel.py#L174-L386" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Field:
    def __init__(self, Settings, Messages, Mongo, key, **kwargs):
        &#34;&#34;&#34;Handle field business.

        A Field object does not correspond with an individual field in a record.
        It represents a *column*, i.e. a set of fields with the same name in all
        records of a collection.

        First of all there is a method to retrieve the value of the field from
        a specific record.

        Then there are methods to deliver those values, either bare or formatted,
        to produce edit widgets to modify the values, and handlers to save
        values.

        How to do this is steered by the specification of the field by keys and
        values that are stored in this object.

        All field access should be guarded by the authorisation rules.

        Parameters
        ----------
        kwargs: dict
            Field configuration arguments.
            It certain parts of the field configuration
            are not present, defaults will be provided.
        &#34;&#34;&#34;
        self.Settings = Settings
        self.Messages = Messages
        Messages.debugAdd(self)
        self.Mongo = Mongo

        self.key = key
        &#34;&#34;&#34;The identifier of this field within the app.
        &#34;&#34;&#34;

        self.nameSpace = &#34;&#34;
        &#34;&#34;&#34;The first key to access the field data in a record.

        Example `dc` (Dublin Core). So if a record has Dublin Core
        metadata, we expect that metadata to exist under key `dc` in that record.

        If the namespace is `&#34;&#34;`, it is assumed that we can dig up the values without
        going into a namespace subdocument first.
        &#34;&#34;&#34;

        self.fieldPath = key
        &#34;&#34;&#34;Compound selector in a nested dict.

        A string of keys, separated by `.`, which will be used to drill down
        into a nested dict. At the end of the path we find the selected value.

        This field selection is applied after the name space selection
        (if `nameSpace` is not the empty string).
        &#34;&#34;&#34;

        self.tp = &#34;string&#34;
        &#34;&#34;&#34;The value type of the field.

        Value types can be string, integer, but also date times, and values
        from an other collection (value lists).
        &#34;&#34;&#34;

        self.caption = key
        &#34;&#34;&#34;A caption that may be displayed with the field value.

        The caption may be a literal string with or without a placeholder `{}`.

        If there is no place holder, the caption will precede the content of
        the field.

        If there is a placeholder, the content will replace the place holder
        in the caption.
        &#34;&#34;&#34;

        for (arg, value) in kwargs.items():
            if value is not None:
                setattr(self, arg, value)

    def logical(self, record):
        &#34;&#34;&#34;Give the logical value of the field in a record.

        Parameters
        ----------
        record: AttrDict or dict
            The record in which the field value is stored.

        Returns
        -------
        any:
            Whatever the value is that we find for that field.
            No conversion/casting to other types will be performed.
            If the field is not present, returns None, without warning.
        &#34;&#34;&#34;
        nameSpace = self.nameSpace
        fieldPath = self.fieldPath

        fields = fieldPath.split(&#34;.&#34;)

        dataSource = record.get(nameSpace, {}) if nameSpace else record

        for field in fields[0:-1]:
            dataSource = dataSource.get(field, None)
            if dataSource is None:
                break

        value = None if dataSource is None else dataSource.get(fields[-1], None)
        return value

    def bare(self, record):
        &#34;&#34;&#34;Give the bare string value of the field in a record.

        Parameters
        ----------
        record: AttrDict or dict
            The record in which the field value is stored.

        Returns
        -------
        string:
            Whatever the value is that we find for that field, converted to string.
            If the field is not present, returns the empty string, without warning.
        &#34;&#34;&#34;
        logical = self.logical(record)
        return &#34;&#34; if logical is None else str(logical)

    def formatted(
        self,
        table,
        record,
        level=None,
        button=&#34;&#34;,
        outerCls=&#34;fieldouter&#34;,
        innerCls=&#34;fieldinner&#34;,
    ):
        &#34;&#34;&#34;Give the formatted value of the field in a record.

        Optionally also puts a caption and/or an edit control.

        The value retrieved is (recursively) wrapped in HTML, steered by additional
        argument, as in `control.html.HtmlElements.wrapValue`.
        be applied.

        If the type is &#39;text&#39;, multiple values will simply be concatenated
        with newlines in between, and no extra classes will be applied.
        Instead, a markdown formatter is applied to the result.

        For other types:

        If the value is an iterable, each individual value is wrapped in a span
        to which an (other) extra CSS class may be applied.

        Parameters
        ----------
        table: string
            The table from which the record is taken
        record: AttrDict or dict
            The record in which the field value is stored.
        level: integer, optional None
            The heading level in which a caption will be placed.
            If None, no caption will be placed.
            If 0, the caption will be placed in a span.
        button: string, optional &#34;&#34;
            An optional edit button.
        outerCls: string optional &#34;fieldouter&#34;
            If given, an extra CSS class for the outer element that wraps the total
            value. Only relevant if the type is not &#39;text&#39;
        innerCls: string optional &#34;fieldinner&#34;
            If given, an extra CSS class for the inner elements that wrap parts of the
            value. Only relevant if the type is not &#39;text&#39;

        Returns
        -------
        string:
            Whatever the value is that we find for that field, converted to HTML.
            If the field is not present, returns the empty string, without warning.
        &#34;&#34;&#34;
        tp = self.tp
        caption = self.caption

        logical = self.logical(record)

        if tp == &#34;text&#34;:
            content = markdown(H.content(logical), tight=False)
        else:
            content = H.wrapValue(
                logical,
                outerElem=&#34;span&#34;,
                outerAtts=dict(cls=outerCls),
                innerElem=&#34;span&#34;,
                innerAtts=dict(cls=innerCls),
            )
        sep = &#34;&amp;nbsp;&#34; if button else &#34;&#34;

        content = f&#34;{button}{sep}{content}&#34;

        if level is not None:
            if &#34;{value}&#34; in caption:
                kind = table.rstrip(&#34;s&#34;)
                heading = caption.format(kind=kind, value=content)
                content = &#34;&#34;
            else:
                heading = caption

            if level == 0:
                elem = &#34;span&#34;
                lv = []
            else:
                elem = &#34;h&#34;
                lv = [level]
            heading = H.elem(elem, *lv, heading)

        return heading + content</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="control.datamodel.Field.caption"><code class="name">var <span class="ident">caption</span></code></dt>
<dd>
<div class="desc"><p>A caption that may be displayed with the field value.</p>
<p>The caption may be a literal string with or without a placeholder <code>{}</code>.</p>
<p>If there is no place holder, the caption will precede the content of
the field.</p>
<p>If there is a placeholder, the content will replace the place holder
in the caption.</p></div>
</dd>
<dt id="control.datamodel.Field.fieldPath"><code class="name">var <span class="ident">fieldPath</span></code></dt>
<dd>
<div class="desc"><p>Compound selector in a nested dict.</p>
<p>A string of keys, separated by <code>.</code>, which will be used to drill down
into a nested dict. At the end of the path we find the selected value.</p>
<p>This field selection is applied after the name space selection
(if <code>nameSpace</code> is not the empty string).</p></div>
</dd>
<dt id="control.datamodel.Field.key"><code class="name">var <span class="ident">key</span></code></dt>
<dd>
<div class="desc"><p>The identifier of this field within the app.</p></div>
</dd>
<dt id="control.datamodel.Field.nameSpace"><code class="name">var <span class="ident">nameSpace</span></code></dt>
<dd>
<div class="desc"><p>The first key to access the field data in a record.</p>
<p>Example <code>dc</code> (Dublin Core). So if a record has Dublin Core
metadata, we expect that metadata to exist under key <code>dc</code> in that record.</p>
<p>If the namespace is <code>""</code>, it is assumed that we can dig up the values without
going into a namespace subdocument first.</p></div>
</dd>
<dt id="control.datamodel.Field.tp"><code class="name">var <span class="ident">tp</span></code></dt>
<dd>
<div class="desc"><p>The value type of the field.</p>
<p>Value types can be string, integer, but also date times, and values
from an other collection (value lists).</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="control.datamodel.Field.bare"><code class="name flex">
<span>def <span class="ident">bare</span></span>(<span>self, record)</span>
</code></dt>
<dd>
<div class="desc"><p>Give the bare string value of the field in a record.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>record</code></strong> :&ensp;<code>AttrDict</code> or <code>dict</code></dt>
<dd>The record in which the field value is stored.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>string:</code></dt>
<dd>Whatever the value is that we find for that field, converted to string.
If the field is not present, returns the empty string, without warning.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/43bd2e150961ad81f2af6575b1c8f269a7e20738/src/pure3d/control/datamodel.py#L283-L298" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def bare(self, record):
    &#34;&#34;&#34;Give the bare string value of the field in a record.

    Parameters
    ----------
    record: AttrDict or dict
        The record in which the field value is stored.

    Returns
    -------
    string:
        Whatever the value is that we find for that field, converted to string.
        If the field is not present, returns the empty string, without warning.
    &#34;&#34;&#34;
    logical = self.logical(record)
    return &#34;&#34; if logical is None else str(logical)</code></pre>
</details>
</dd>
<dt id="control.datamodel.Field.formatted"><code class="name flex">
<span>def <span class="ident">formatted</span></span>(<span>self, table, record, level=None, button='', outerCls='fieldouter', innerCls='fieldinner')</span>
</code></dt>
<dd>
<div class="desc"><p>Give the formatted value of the field in a record.</p>
<p>Optionally also puts a caption and/or an edit control.</p>
<p>The value retrieved is (recursively) wrapped in HTML, steered by additional
argument, as in <code><a title="control.html.HtmlElements.wrapValue" href="html.html#control.html.HtmlElements.wrapValue">HtmlElements.wrapValue()</a></code>.
be applied.</p>
<p>If the type is 'text', multiple values will simply be concatenated
with newlines in between, and no extra classes will be applied.
Instead, a markdown formatter is applied to the result.</p>
<p>For other types:</p>
<p>If the value is an iterable, each individual value is wrapped in a span
to which an (other) extra CSS class may be applied.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>table</code></strong> :&ensp;<code>string</code></dt>
<dd>The table from which the record is taken</dd>
<dt><strong><code>record</code></strong> :&ensp;<code>AttrDict</code> or <code>dict</code></dt>
<dd>The record in which the field value is stored.</dd>
<dt><strong><code>level</code></strong> :&ensp;<code>integer</code>, optional <code>None</code></dt>
<dd>The heading level in which a caption will be placed.
If None, no caption will be placed.
If 0, the caption will be placed in a span.</dd>
<dt><strong><code>button</code></strong> :&ensp;<code>string</code>, optional <code>""</code></dt>
<dd>An optional edit button.</dd>
<dt><strong><code>outerCls</code></strong> :&ensp;<code>string optional "fieldouter"</code></dt>
<dd>If given, an extra CSS class for the outer element that wraps the total
value. Only relevant if the type is not 'text'</dd>
<dt><strong><code>innerCls</code></strong> :&ensp;<code>string optional "fieldinner"</code></dt>
<dd>If given, an extra CSS class for the inner elements that wrap parts of the
value. Only relevant if the type is not 'text'</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>string:</code></dt>
<dd>Whatever the value is that we find for that field, converted to HTML.
If the field is not present, returns the empty string, without warning.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/43bd2e150961ad81f2af6575b1c8f269a7e20738/src/pure3d/control/datamodel.py#L300-L386" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def formatted(
    self,
    table,
    record,
    level=None,
    button=&#34;&#34;,
    outerCls=&#34;fieldouter&#34;,
    innerCls=&#34;fieldinner&#34;,
):
    &#34;&#34;&#34;Give the formatted value of the field in a record.

    Optionally also puts a caption and/or an edit control.

    The value retrieved is (recursively) wrapped in HTML, steered by additional
    argument, as in `control.html.HtmlElements.wrapValue`.
    be applied.

    If the type is &#39;text&#39;, multiple values will simply be concatenated
    with newlines in between, and no extra classes will be applied.
    Instead, a markdown formatter is applied to the result.

    For other types:

    If the value is an iterable, each individual value is wrapped in a span
    to which an (other) extra CSS class may be applied.

    Parameters
    ----------
    table: string
        The table from which the record is taken
    record: AttrDict or dict
        The record in which the field value is stored.
    level: integer, optional None
        The heading level in which a caption will be placed.
        If None, no caption will be placed.
        If 0, the caption will be placed in a span.
    button: string, optional &#34;&#34;
        An optional edit button.
    outerCls: string optional &#34;fieldouter&#34;
        If given, an extra CSS class for the outer element that wraps the total
        value. Only relevant if the type is not &#39;text&#39;
    innerCls: string optional &#34;fieldinner&#34;
        If given, an extra CSS class for the inner elements that wrap parts of the
        value. Only relevant if the type is not &#39;text&#39;

    Returns
    -------
    string:
        Whatever the value is that we find for that field, converted to HTML.
        If the field is not present, returns the empty string, without warning.
    &#34;&#34;&#34;
    tp = self.tp
    caption = self.caption

    logical = self.logical(record)

    if tp == &#34;text&#34;:
        content = markdown(H.content(logical), tight=False)
    else:
        content = H.wrapValue(
            logical,
            outerElem=&#34;span&#34;,
            outerAtts=dict(cls=outerCls),
            innerElem=&#34;span&#34;,
            innerAtts=dict(cls=innerCls),
        )
    sep = &#34;&amp;nbsp;&#34; if button else &#34;&#34;

    content = f&#34;{button}{sep}{content}&#34;

    if level is not None:
        if &#34;{value}&#34; in caption:
            kind = table.rstrip(&#34;s&#34;)
            heading = caption.format(kind=kind, value=content)
            content = &#34;&#34;
        else:
            heading = caption

        if level == 0:
            elem = &#34;span&#34;
            lv = []
        else:
            elem = &#34;h&#34;
            lv = [level]
        heading = H.elem(elem, *lv, heading)

    return heading + content</code></pre>
</details>
</dd>
<dt id="control.datamodel.Field.logical"><code class="name flex">
<span>def <span class="ident">logical</span></span>(<span>self, record)</span>
</code></dt>
<dd>
<div class="desc"><p>Give the logical value of the field in a record.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>record</code></strong> :&ensp;<code>AttrDict</code> or <code>dict</code></dt>
<dd>The record in which the field value is stored.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>any:</code></dt>
<dd>Whatever the value is that we find for that field.
No conversion/casting to other types will be performed.
If the field is not present, returns None, without warning.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/43bd2e150961ad81f2af6575b1c8f269a7e20738/src/pure3d/control/datamodel.py#L253-L281" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def logical(self, record):
    &#34;&#34;&#34;Give the logical value of the field in a record.

    Parameters
    ----------
    record: AttrDict or dict
        The record in which the field value is stored.

    Returns
    -------
    any:
        Whatever the value is that we find for that field.
        No conversion/casting to other types will be performed.
        If the field is not present, returns None, without warning.
    &#34;&#34;&#34;
    nameSpace = self.nameSpace
    fieldPath = self.fieldPath

    fields = fieldPath.split(&#34;.&#34;)

    dataSource = record.get(nameSpace, {}) if nameSpace else record

    for field in fields[0:-1]:
        dataSource = dataSource.get(field, None)
        if dataSource is None:
            break

    value = None if dataSource is None else dataSource.get(fields[-1], None)
    return value</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="control.datamodel.Upload"><code class="flex name class">
<span>class <span class="ident">Upload</span></span>
<span>(</span><span>Settings, Messages, Mongo, key, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Handle upload business.</p>
<p>An upload is like a field of type 'file'.
The name of the uploaded file is stored in a record in MongoDb.
The contents of the file is stored on the file system.</p>
<p>A Upload object does not correspond with an individual field in a record.
It represents a <em>column</em>, i.e. a set of fields with the same name in all
records of a collection.</p>
<p>First of all there is a method to retrieve the file name of an upload from
a specific record.</p>
<p>Then there are methods to deliver those values, either bare or formatted,
to produce widgets to upload or delete the corresponding files.</p>
<p>How to do this is steered by the specification of the upload by keys and
values that are stored in this object.</p>
<p>All upload access should be guarded by the authorisation rules.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Field configuration arguments.
The following parts of the field configuration
should be present: <code>table</code>, <code>field</code> and <code>relative</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/43bd2e150961ad81f2af6575b1c8f269a7e20738/src/pure3d/control/datamodel.py#L389-L598" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Upload:
    def __init__(self, Settings, Messages, Mongo, key, **kwargs):
        &#34;&#34;&#34;Handle upload business.

        An upload is like a field of type &#39;file&#39;.
        The name of the uploaded file is stored in a record in MongoDb.
        The contents of the file is stored on the file system.

        A Upload object does not correspond with an individual field in a record.
        It represents a *column*, i.e. a set of fields with the same name in all
        records of a collection.

        First of all there is a method to retrieve the file name of an upload from
        a specific record.

        Then there are methods to deliver those values, either bare or formatted,
        to produce widgets to upload or delete the corresponding files.

        How to do this is steered by the specification of the upload by keys and
        values that are stored in this object.

        All upload access should be guarded by the authorisation rules.

        Parameters
        ----------
        kwargs: dict
            Field configuration arguments.
            The following parts of the field configuration
            should be present: `table`, `field` and `relative`.
        &#34;&#34;&#34;
        self.Settings = Settings
        self.Messages = Messages
        Messages.debugAdd(self)
        self.Mongo = Mongo

        self.key = key
        &#34;&#34;&#34;The identifier of this upload within the app.
        &#34;&#34;&#34;

        self.table = None
        &#34;&#34;&#34;The table in which the file name should be placed.
        &#34;&#34;&#34;

        self.field = None
        &#34;&#34;&#34;The field in which the file name should be placed.
        &#34;&#34;&#34;

        self.relative = None
        &#34;&#34;&#34;Indicates the directory where the actual file will be saved.

        Possibe values:

        * `site`: top level of the working data directory of the site
        * `project`: project directory of the project in question
        * `edition`: edition directory of the project in question

        If left out, the value will be derived from `table`.
        &#34;&#34;&#34;

        self.accept = None
        &#34;&#34;&#34;The file types that the field accepts.
        &#34;&#34;&#34;

        self.caption = None
        &#34;&#34;&#34;The text to display on the upload button.
        &#34;&#34;&#34;

        self.show = None
        &#34;&#34;&#34;Whether to show the contents of the file.

        This is typically the case when the file is an image to be presented
        as a logo.
        &#34;&#34;&#34;

        # let attributes be filled in from the function **kwargs

        for (arg, value) in kwargs.items():
            if value is not None:
                setattr(self, arg, value)

        # try to fill in defaults for attributes that are still None

        good = True

        table = getattr(self, &#34;table&#34;, None)
        field = getattr(self, &#34;field&#34;, None)
        accept = getattr(self, &#34;accept&#34;, None)

        for arg in (&#34;table&#34;, &#34;field&#34;, &#34;relative&#34;, &#34;accept&#34;, &#34;caption&#34;, &#34;show&#34;):
            if getattr(self, arg, None) is None:
                if arg == &#34;relative&#34; and table is not None:
                    setattr(self, arg, table.removesuffix(&#34;s&#34;))
                elif arg == &#34;caption&#34;:
                    setattr(self, arg, f&#34;{table}-{field}-{accept}&#34;)
                elif arg == &#34;show&#34;:
                    setattr(self, arg, False)
                else:
                    Messages.error(logmsg=f&#34;Missing info in Upload spec: {arg}&#34;)
                    good = False

        if not good:
            quit()

    def bare(self, record):
        &#34;&#34;&#34;Give the bare file name as stored in a record in MongoDb.

        Parameters
        ----------
        record: AttrDict
            The record in which the file name is stored.

        Returns
        -------
        string:
            Whatever the value is that we find.
            If the field is not present, returns None, without warning.
        &#34;&#34;&#34;
        field = self.field

        return record[field]

    def getPath(self, record):
        &#34;&#34;&#34;Give the path to the file in question.

        The path can be used to build the static url and the save url.

        It does not contain the file name.
        If the path is non-empty, a &#34;/&#34; will be appended.
        &#34;&#34;&#34;
        table = self.table
        relative = self.relative

        recordId = record._id
        projectId = recordId if table == &#34;projects&#34; else record.projectId
        editionId = recordId if table == &#34;editions&#34; else record.editionId

        path = (
            &#34;&#34;
            if relative == &#34;site&#34;
            else f&#34;projects/{projectId}&#34;
            if relative == &#34;project&#34;
            else f&#34;projects/{projectId}/editions/{editionId}&#34;
            if relative == &#34;edition&#34;
            else None
        )
        sep = &#34;/&#34; if path else &#34;&#34;
        return f&#34;{path}{sep}&#34;

    def formatted(self, record, mayChange=False):
        &#34;&#34;&#34;Give the formatted value of a file field in a record.

        Optionally also puts an upload control.

        Parameters
        ----------
        record: AttrDict or dict
            The record in which the field value is stored.
        mayChange: boolean, optional False
            Whether the file may be changed.
            If so, an upload widget is supplied, wich contains a a delete button.

        Returns
        -------
        string:
            Whatever the value is that we find for that field, converted to HTML.
            If the field is not present, returns the empty string, without warning.
        &#34;&#34;&#34;

        fileName = self.bare(record)

        Messages = self.Messages

        key = self.key
        table = self.table
        field = self.field
        relative = self.relative
        accept = self.accept
        caption = self.caption
        show = self.show

        title = f&#34;click to upload a {caption}&#34;

        recordId = record._id

        fid = f&#34;{table}/{recordId}/{field}&#34;

        path = self.getPath(record)
        if path is None:
            Messages.warning(
                logmsg=f&#34;Wrong file path for upload {key} based on relative {relative}&#34;,
                msg=&#34;The location for this file cannot be determined&#34;,
            )

        if show:
            staticUrl = f&#34;/data/{path}{fileName}&#34;
            img = H.img(staticUrl, fid=fid)
        else:
            img = &#34;&#34;

        visual = img or H.span(fileName, cls=&#34;fieldinner&#34;)

        if not mayChange:
            return visual

        sep = &#34;/&#34; if path else &#34;&#34;
        saveUrl = f&#34;/upload/{fid}{sep}{path}&#34;

        return H.content(
            visual, H.finput(fileName, accept, saveUrl, show=show, fid=fid, title=title)
        )</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="control.datamodel.Upload.accept"><code class="name">var <span class="ident">accept</span></code></dt>
<dd>
<div class="desc"><p>The file types that the field accepts.</p></div>
</dd>
<dt id="control.datamodel.Upload.caption"><code class="name">var <span class="ident">caption</span></code></dt>
<dd>
<div class="desc"><p>The text to display on the upload button.</p></div>
</dd>
<dt id="control.datamodel.Upload.field"><code class="name">var <span class="ident">field</span></code></dt>
<dd>
<div class="desc"><p>The field in which the file name should be placed.</p></div>
</dd>
<dt id="control.datamodel.Upload.key"><code class="name">var <span class="ident">key</span></code></dt>
<dd>
<div class="desc"><p>The identifier of this upload within the app.</p></div>
</dd>
<dt id="control.datamodel.Upload.relative"><code class="name">var <span class="ident">relative</span></code></dt>
<dd>
<div class="desc"><p>Indicates the directory where the actual file will be saved.</p>
<p>Possibe values:</p>
<ul>
<li><code>site</code>: top level of the working data directory of the site</li>
<li><code>project</code>: project directory of the project in question</li>
<li><code>edition</code>: edition directory of the project in question</li>
</ul>
<p>If left out, the value will be derived from <code>table</code>.</p></div>
</dd>
<dt id="control.datamodel.Upload.show"><code class="name">var <span class="ident">show</span></code></dt>
<dd>
<div class="desc"><p>Whether to show the contents of the file.</p>
<p>This is typically the case when the file is an image to be presented
as a logo.</p></div>
</dd>
<dt id="control.datamodel.Upload.table"><code class="name">var <span class="ident">table</span></code></dt>
<dd>
<div class="desc"><p>The table in which the file name should be placed.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="control.datamodel.Upload.bare"><code class="name flex">
<span>def <span class="ident">bare</span></span>(<span>self, record)</span>
</code></dt>
<dd>
<div class="desc"><p>Give the bare file name as stored in a record in MongoDb.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>record</code></strong> :&ensp;<code>AttrDict</code></dt>
<dd>The record in which the file name is stored.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>string:</code></dt>
<dd>Whatever the value is that we find.
If the field is not present, returns None, without warning.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/43bd2e150961ad81f2af6575b1c8f269a7e20738/src/pure3d/control/datamodel.py#L492-L508" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def bare(self, record):
    &#34;&#34;&#34;Give the bare file name as stored in a record in MongoDb.

    Parameters
    ----------
    record: AttrDict
        The record in which the file name is stored.

    Returns
    -------
    string:
        Whatever the value is that we find.
        If the field is not present, returns None, without warning.
    &#34;&#34;&#34;
    field = self.field

    return record[field]</code></pre>
</details>
</dd>
<dt id="control.datamodel.Upload.formatted"><code class="name flex">
<span>def <span class="ident">formatted</span></span>(<span>self, record, mayChange=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Give the formatted value of a file field in a record.</p>
<p>Optionally also puts an upload control.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>record</code></strong> :&ensp;<code>AttrDict</code> or <code>dict</code></dt>
<dd>The record in which the field value is stored.</dd>
<dt><strong><code>mayChange</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>Whether the file may be changed.
If so, an upload widget is supplied, wich contains a a delete button.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>string:</code></dt>
<dd>Whatever the value is that we find for that field, converted to HTML.
If the field is not present, returns the empty string, without warning.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/43bd2e150961ad81f2af6575b1c8f269a7e20738/src/pure3d/control/datamodel.py#L537-L598" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def formatted(self, record, mayChange=False):
    &#34;&#34;&#34;Give the formatted value of a file field in a record.

    Optionally also puts an upload control.

    Parameters
    ----------
    record: AttrDict or dict
        The record in which the field value is stored.
    mayChange: boolean, optional False
        Whether the file may be changed.
        If so, an upload widget is supplied, wich contains a a delete button.

    Returns
    -------
    string:
        Whatever the value is that we find for that field, converted to HTML.
        If the field is not present, returns the empty string, without warning.
    &#34;&#34;&#34;

    fileName = self.bare(record)

    Messages = self.Messages

    key = self.key
    table = self.table
    field = self.field
    relative = self.relative
    accept = self.accept
    caption = self.caption
    show = self.show

    title = f&#34;click to upload a {caption}&#34;

    recordId = record._id

    fid = f&#34;{table}/{recordId}/{field}&#34;

    path = self.getPath(record)
    if path is None:
        Messages.warning(
            logmsg=f&#34;Wrong file path for upload {key} based on relative {relative}&#34;,
            msg=&#34;The location for this file cannot be determined&#34;,
        )

    if show:
        staticUrl = f&#34;/data/{path}{fileName}&#34;
        img = H.img(staticUrl, fid=fid)
    else:
        img = &#34;&#34;

    visual = img or H.span(fileName, cls=&#34;fieldinner&#34;)

    if not mayChange:
        return visual

    sep = &#34;/&#34; if path else &#34;&#34;
    saveUrl = f&#34;/upload/{fid}{sep}{path}&#34;

    return H.content(
        visual, H.finput(fileName, accept, saveUrl, show=show, fid=fid, title=title)
    )</code></pre>
</details>
</dd>
<dt id="control.datamodel.Upload.getPath"><code class="name flex">
<span>def <span class="ident">getPath</span></span>(<span>self, record)</span>
</code></dt>
<dd>
<div class="desc"><p>Give the path to the file in question.</p>
<p>The path can be used to build the static url and the save url.</p>
<p>It does not contain the file name.
If the path is non-empty, a "/" will be appended.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/43bd2e150961ad81f2af6575b1c8f269a7e20738/src/pure3d/control/datamodel.py#L510-L535" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getPath(self, record):
    &#34;&#34;&#34;Give the path to the file in question.

    The path can be used to build the static url and the save url.

    It does not contain the file name.
    If the path is non-empty, a &#34;/&#34; will be appended.
    &#34;&#34;&#34;
    table = self.table
    relative = self.relative

    recordId = record._id
    projectId = recordId if table == &#34;projects&#34; else record.projectId
    editionId = recordId if table == &#34;editions&#34; else record.editionId

    path = (
        &#34;&#34;
        if relative == &#34;site&#34;
        else f&#34;projects/{projectId}&#34;
        if relative == &#34;project&#34;
        else f&#34;projects/{projectId}/editions/{editionId}&#34;
        if relative == &#34;edition&#34;
        else None
    )
    sep = &#34;/&#34; if path else &#34;&#34;
    return f&#34;{path}{sep}&#34;</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<p><a href="https://github.com/CLARIAH/pure3dx" title="GitHub repo">GitHub</a></p>
<form>
<input id="lunr-search" name="q" placeholder="🔎 Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="control" href="index.html">control</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="control.datamodel.Datamodel" href="#control.datamodel.Datamodel">Datamodel</a></code></h4>
<ul class="">
<li><code><a title="control.datamodel.Datamodel.getDetailRecords" href="#control.datamodel.Datamodel.getDetailRecords">getDetailRecords</a></code></li>
<li><code><a title="control.datamodel.Datamodel.makeField" href="#control.datamodel.Datamodel.makeField">makeField</a></code></li>
<li><code><a title="control.datamodel.Datamodel.makeUpload" href="#control.datamodel.Datamodel.makeUpload">makeUpload</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="control.datamodel.Field" href="#control.datamodel.Field">Field</a></code></h4>
<ul class="two-column">
<li><code><a title="control.datamodel.Field.bare" href="#control.datamodel.Field.bare">bare</a></code></li>
<li><code><a title="control.datamodel.Field.caption" href="#control.datamodel.Field.caption">caption</a></code></li>
<li><code><a title="control.datamodel.Field.fieldPath" href="#control.datamodel.Field.fieldPath">fieldPath</a></code></li>
<li><code><a title="control.datamodel.Field.formatted" href="#control.datamodel.Field.formatted">formatted</a></code></li>
<li><code><a title="control.datamodel.Field.key" href="#control.datamodel.Field.key">key</a></code></li>
<li><code><a title="control.datamodel.Field.logical" href="#control.datamodel.Field.logical">logical</a></code></li>
<li><code><a title="control.datamodel.Field.nameSpace" href="#control.datamodel.Field.nameSpace">nameSpace</a></code></li>
<li><code><a title="control.datamodel.Field.tp" href="#control.datamodel.Field.tp">tp</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="control.datamodel.Upload" href="#control.datamodel.Upload">Upload</a></code></h4>
<ul class="two-column">
<li><code><a title="control.datamodel.Upload.accept" href="#control.datamodel.Upload.accept">accept</a></code></li>
<li><code><a title="control.datamodel.Upload.bare" href="#control.datamodel.Upload.bare">bare</a></code></li>
<li><code><a title="control.datamodel.Upload.caption" href="#control.datamodel.Upload.caption">caption</a></code></li>
<li><code><a title="control.datamodel.Upload.field" href="#control.datamodel.Upload.field">field</a></code></li>
<li><code><a title="control.datamodel.Upload.formatted" href="#control.datamodel.Upload.formatted">formatted</a></code></li>
<li><code><a title="control.datamodel.Upload.getPath" href="#control.datamodel.Upload.getPath">getPath</a></code></li>
<li><code><a title="control.datamodel.Upload.key" href="#control.datamodel.Upload.key">key</a></code></li>
<li><code><a title="control.datamodel.Upload.relative" href="#control.datamodel.Upload.relative">relative</a></code></li>
<li><code><a title="control.datamodel.Upload.show" href="#control.datamodel.Upload.show">show</a></code></li>
<li><code><a title="control.datamodel.Upload.table" href="#control.datamodel.Upload.table">table</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<a href="https://pure.knaw.nl/portal/en/persons/dirk-roorda">Dirk Roorda</a>
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>