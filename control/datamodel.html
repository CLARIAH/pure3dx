<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.11.1" />
<title>control.datamodel API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>control.datamodel</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/99a827eec565f9f7bf0633f62d3c060d35dd93dc/src/control/datamodel.py#L1-L1298" class="git-link">Browse git</a>
</summary>
<pre><code class="python">from markdown import markdown

from .generic import AttrDict, pseudoisonow
from .files import fileExists, listFilesAccepted, writeYaml


class Datamodel:
    def __init__(self, Settings, Messages, Mongo):
        &#34;&#34;&#34;Datamodel related operations.

        This class has methods to manipulate various pieces of content
        in the data sources, and hand it over to higher level objects.

        It can find out dependencies between related records, and it knows
        a thing or two about fields.

        It is instantiated by a singleton object.

        It has a method which is a factory for `control.datamodel.Field` objects,
        which deal with individual fields.

        Likewise it has a factory function for `control.datamodel.Upload` objects,
        which deal with file uploads.

        Parameters
        ----------
        Settings: AttrDict
            App-wide configuration data obtained from
            `control.config.Config.Settings`.
        Messages: object
            Singleton instance of `control.messages.Messages`.
        Mongo: object
            Singleton instance of `control.mongo.Mongo`.
        &#34;&#34;&#34;
        self.Settings = Settings
        self.Messages = Messages
        Messages.debugAdd(self)
        self.Mongo = Mongo

        datamodel = Settings.datamodel
        self.detailMaster = datamodel.detailMaster
        self.masterDetail = datamodel.masterDetail
        self.mainLink = datamodel.mainLink
        textsConfig = datamodel.texts
        fieldsConfig = datamodel.fields
        fieldDistribution = datamodel.fieldDistribution
        self.uploadsConfig = datamodel.uploads
        self.fieldObjects = AttrDict()
        self.uploadObjects = AttrDict()

        fieldPaths = {}

        for f, cfg in fieldsConfig.items():
            nameSpace = cfg.nameSpace or &#34;&#34;
            fieldPath = cfg.fieldPath or f
            sep = &#34;.&#34; if nameSpace and fieldPath else &#34;&#34;
            fieldPaths[f] = f&#34;{nameSpace}{sep}{fieldPath}&#34;

        self.textsConfig = textsConfig
        self.fieldsConfig = fieldsConfig
        self.fieldDistribution = fieldDistribution
        self.fieldPaths = fieldPaths

    @staticmethod
    def specialize(table, record):
        &#34;&#34;&#34;Specializes information to a table.

        Field information is a mapping of keys to values.
        When values are dicts, their keys are table names.
        If a table is given, we can specialize for that table.
        If the table does not occur as a key, we look if there is a key `&#34;&#34;`,
        and if so, we use that value. Otherwise we use None.

        Parameters
        ----------
        table: string
            The table to which we must specialize the record
        record: dict | AttrDict
            The record, of which some fields have values per table

        Returns
        -------
        AttrDict
            The specialized record (a new copy)
        &#34;&#34;&#34;
        new = AttrDict()

        for k, v in record.items():
            if type(v) in {dict, AttrDict}:
                new[k] = v.get(table, v.get(&#34;&#34;, None))
            else:
                new[k] = v

        return new

    def getTexts(self):
        &#34;&#34;&#34;Get the names and info for the fixed text pages.

        The contents of these pages are stored in fields the site record,
        the path to the field is given in the text info dict.

        Returns
        -------
        dict
            Keyed by the name of the text, values are keys for the corresponding
            metadata fields in the site record where the text is stored.
        &#34;&#34;&#34;
        return self.textsConfig

    def getMetaFields(self, table, kinds, level=None, asDict=False):
        &#34;&#34;&#34;Get the list of metadata fields for in the meta box.

        Parameters
        ----------
        table: string
            Either `site` or `project` or `edition`
        kinds: list | string | void
            The kinds of fields to fetch: one or more of &#34;main&#34;, &#34;box&#34; or &#34;narrative&#34;.
            If None, all kinds are used, in the order :main&#34;, &#34;narrative&#34;, &#34;box&#34;.
            If a string: it is the single kind that is being used.
        level: integer, optional None
            If not None, append @ plus level to each meta key that is delivered,
            and join the components with ` + `
            If one of the fields is `title`, its level is one lower.
        asDict: boolean, optional False
            If True, the `level` parameter will be ignored.
            Returns a dictionary with the field names as keys, and the field information
            as values, specialized to the given table.

        Returns
        -------
        dict | tuple of string | string
            Returns a dict if `asDict` is True.
            The meta keys in question, as a tuple if level is None, otherwise as a
            &#34;+&#34;-separated string where each item is appended with a level indicator
        &#34;&#34;&#34;
        fieldDistribution = self.fieldDistribution
        fieldsConfig = self.fieldsConfig

        result = {} if asDict else []

        kinds = (
            [&#34;main&#34;, &#34;narrative&#34;, &#34;box&#34;]
            if kinds is None
            else [kinds] if type(kinds) is str else list(kinds)
        )

        for k in kinds:
            fields = fieldDistribution.get(k, {}).get(table, [])

            if asDict:
                for f in fields:
                    result[f] = self.specialize(table, fieldsConfig.get(f, AttrDict()))
            else:
                result.extend(fields)

        return (
            result
            if asDict
            else (
                tuple(result)
                if level is None
                else &#34; + &#34;.join(
                    f&#34;{x}@{level - 1 if x == &#39;title&#39; else level}&#34; for x in result
                )
            )
        )

    def checkMetaFields(self, table):
        &#34;&#34;&#34;Get the list of metadata fields that must be present before publication.

        Parameters
        ----------
        table: string
            Either `site` or `project` or `edition`

        Returns
        -------
        tuple of string
            The meta keys in question
        &#34;&#34;&#34;
        fieldDistribution = self.fieldDistribution
        fieldsConfig = self.fieldsConfig

        kinds = (&#34;main&#34;, &#34;narrative&#34;, &#34;box&#34;)

        result = []

        for k in kinds:
            fields = fieldDistribution.get(k, {}).get(table, [])

            for f in fields:
                info = self.specialize(table, fieldsConfig.get(f, AttrDict()))

                if info.mandatory:
                    result.append(f)

        return tuple(result)

    def getMarkdownFields(self):
        &#34;&#34;&#34;Gives the set of all fields with markdown content.

        Returns
        -------
        set
        &#34;&#34;&#34;
        fieldsConfig = self.fieldsConfig

        return {f for (f, cfg) in fieldsConfig.items() if cfg.get(&#34;tp&#34;, None) == &#34;text&#34;}

    def getListFields(self):
        &#34;&#34;&#34;Gives the set of all fields with list content.

        Returns
        -------
        set
        &#34;&#34;&#34;
        fieldsConfig = self.fieldsConfig

        return {
            f
            for (f, cfg) in fieldsConfig.items()
            if cfg.get(&#34;multiple&#34;, True)
            and cfg.get(&#34;tp&#34;, None) not in {&#34;text&#34;, &#34;datetime&#34;}
        }

    def relevant(self, project=None, edition=None):
        &#34;&#34;&#34;Get a relevant record and the table to which it belongs.

        A relevant record is either a project record, or an edition record,
        or the one and only site record.

        If all optional parameters are None, we look for the site record.
        If the project parameter is not None, we look for the project record.

        This is the inverse of `context()`.

        Paramenters
        -----------
        project: string | ObjectId | AttrDict, optional None
            The project whose record we need.
        edition: string | ObjectId | AttrDict, optional None
            The edition whose record we need.

        Returns
        -------
        tuple
            * table: string; the table in which the record is found
            * record id: string; the id of the record
            * record: AttrDict; the record itself

            If both project and edition are not None
        &#34;&#34;&#34;
        Settings = self.Settings
        Mongo = self.Mongo

        if edition is not None:
            table = &#34;edition&#34;
            (recordId, record) = Mongo.get(table, edition)
        elif project is not None:
            table = &#34;project&#34;
            (recordId, record) = Mongo.get(table, project)
        else:
            table = &#34;site&#34;
            siteCrit = Settings.siteCrit
            record = Mongo.getRecord(table, siteCrit)
            recordId = record._id

        return (table, recordId, record)

    def context(self, table, record):
        &#34;&#34;&#34;Get the context of a record.

        Get the project and edition records to which the record belongs.

        Parameters
        ----------
        table: string
            The table in which the record sits.
        record: string
            The record.

        This is the inverse of `relevant()`.

        Returns
        -------
        tuple of tuple
            (siteId, site, projectId, project, editionId, edition)
        &#34;&#34;&#34;
        Mongo = self.Mongo

        (recordId, record) = Mongo.get(table, record)

        if recordId is None:
            return (None, None, None, None, None, None)

        if table == &#34;site&#34;:
            (editionId, edition) = (None, None)
            (projectId, project) = (None, None)
            (siteId, site) = (recordId, record)
        elif table == &#34;project&#34;:
            (editionId, edition) = (None, None)
            (projectId, project) = (recordId, record)
            (siteId, site) = Mongo.get(&#34;site&#34;, record.siteId)
        elif table == &#34;edition&#34;:
            (editionId, edition) = (recordId, record)
            (projectId, project) = Mongo.get(&#34;project&#34;, record.projectId)
            (siteId, site) = Mongo.get(&#34;site&#34;, project.siteId)

        return (siteId, site, projectId, project, editionId, edition)

    def getDetailRecords(self, masterTable, master):
        &#34;&#34;&#34;Retrieve the detail records of a master record.

        It finds all records that have a field containing an id of the
        given master record. But not those in cross-link records.

        Details are not retrieved recursively, only the direct details
        of a master are fetched.

        Parameters
        ----------
        masterTable: string
            The name of the table in which the master record lives.
        master: string | ObjectId | AttrDict
            The master record.

        Returns
        -------
        AttrDict
            The list of detail records, categorized by detail table in which
            they occur. The detail tables are the keys, the lists of records
            in those tables are the values.
            If the master record cannot be found or if there are no detail
            records, the empty dict is returned.
        &#34;&#34;&#34;
        Mongo = self.Mongo
        masterDetail = self.masterDetail

        detailTable = masterDetail[masterTable]
        if detailTable is None:
            return AttrDict()

        (masterId, master) = Mongo.get(masterTable, master)
        if masterId is None:
            return AttrDict()

        crit = {f&#34;{masterTable}Id&#34;: masterId}

        detailRecords = AttrDict()

        details = Mongo.getList(detailTable, crit)

        if len(details):
            detailRecords[detailTable] = details

        return detailRecords

    def getUserWork(self, user):
        &#34;&#34;&#34;Gets the number of project and edition records of a user.

        We will not delete users if the user is linked to a project or edition.
        This function counts how many projects and editions a user is linked to.

        Parameters
        ----------
        user: string
            The name of the user (field `user` in the record)

        Returns
        -------
        integer
            The number of projects
        integer
            The number of editions
        &#34;&#34;&#34;
        Mongo = self.Mongo
        nProjects = len(Mongo.getList(&#34;projectUser&#34;, dict(user=user)))
        nEditions = len(Mongo.getList(&#34;EditionUser&#34;, dict(user=user)))
        return (nProjects, nEditions)

    def getLinkedCrit(self, table, record, deleted=False):
        &#34;&#34;&#34;Produce criteria to retrieve the linked records of a record.

        It finds all cross-linked records containing an id of the
        given record.

        So no detail records.

        Parameters
        ----------
        table: string
            The name of the table in which the record lives.
        record: string | ObjectId | AttrDict
            The record.
        deleted: boolean, optional False
            Search only in the records that are marked for deletion

        Returns
        -------
        AttrDict
            Keys: tables in which linked records exist.
            Values: the criteria to find those linked records in that table.
        &#34;&#34;&#34;
        Mongo = self.Mongo
        mainLink = self.mainLink

        linkTables = mainLink[table]

        if linkTables is None:
            return AttrDict()

        (recordId, record) = Mongo.get(table, record, deleted=deleted)

        if recordId is None:
            return AttrDict()

        crit = {f&#34;{table}Id&#34;: recordId}

        linkCriteria = AttrDict()

        for linkTable in linkTables:
            linkCriteria[linkTable] = crit

        return linkCriteria

    def getKeywords(self, extra=None):
        &#34;&#34;&#34;Get the lists of keywords that act as values for metadata fields.

        A keyword is a string value and it belongs to a list of keywords.
        The metadata fields that are declared with `tp: keyword` are associated
        with a list of values: keywords.

        We read the table of keywords, organize it by metadata field, and count
        how many edition/project record use that keyword.

        Parameters
        ----------
        extra: dict, optional None
            If passed, it is a dictionary keyed by metadata keys and valued
            with value sets for those metadata keys. These values must be added to
            the respective keyword lists.
            These are typically from existing values in metadata fields that
            have been accepted when different keyword lists were in effect.

        Returns
        -------
        dict
            keyed by name of the metadata field, then by the keyword itself,
            and valued by the number of edition/project records it occurs in.
        &#34;&#34;&#34;
        Mongo = self.Mongo
        Settings = self.Settings
        datamodel = Settings.datamodel
        fieldsConfig = datamodel.fields
        fieldPaths = self.fieldPaths

        keywordLists = {
            field for (field, cfg) in fieldsConfig.items() if cfg.tp == &#34;keyword&#34;
        }

        keywords = {}

        for name in keywordLists:
            keywords[name] = {}

        keywordItems = Mongo.getList(&#34;keyword&#34;, {})

        for keywordRecord in keywordItems:
            name = keywordRecord.name

            if name not in keywords:
                # in this case, the existing keywords contain vocab lists
                # that are not associated with a metadata field:
                # either the metadata config has changed
                # or the keywords come from a different instance
                keywords[name] = {}

            fieldPath = fieldPaths[name]
            value = keywordRecord.value
            criteria = {fieldPath: value}
            recordsP = Mongo.getList(&#34;project&#34;, criteria)
            recordsE = Mongo.getList(&#34;edition&#34;, criteria)
            occs = len(recordsP) + len(recordsE)
            keywords[name][value] = occs

        if extra is not None:
            for name, values in extra.items():
                fieldPath = fieldPaths[name]

                for value in values:
                    criteria = {fieldPath: value}
                    recordsP = Mongo.getList(&#34;project&#34;, criteria)
                    recordsE = Mongo.getList(&#34;edition&#34;, criteria)
                    occs = len(recordsP) + len(recordsE)
                    keywords[name][value] = occs

        return keywords

    def makeField(self, key, table):
        &#34;&#34;&#34;Make a field object and registers it.

        An instance of class `control.datamodel.Field` is created,
        geared to this particular field.

        !!! note &#34;Idempotent&#34;
            If the Field object is already registered, nothing is done.
            Field objects are registered under their key and table.

        Parameters
        ----------
        key: string
            Identifier for the field.
            The configuration for this field will be retrieved using this key.

        Returns
        -------
        object
            The resulting Field object.
            It is also added to the `fieldObjects` member.
        &#34;&#34;&#34;
        Settings = self.Settings

        fieldObjects = self.fieldObjects

        fieldObject = fieldObjects[(key, table)]

        if fieldObject:
            return fieldObject

        Messages = self.Messages
        Mongo = self.Mongo
        fieldsConfig = self.fieldsConfig

        fieldConfig = fieldsConfig[key]

        if fieldConfig is None:
            Messages.error(logmsg=f&#34;Unknown field key &#39;{key}&#39;&#34;)
            fieldConfig = AttrDict()

        fieldObject = Field(Settings, Messages, Mongo, self, key, table, **fieldConfig)

        fieldObjects[(key, table)] = fieldObject
        return fieldObject

    def makeUpload(self, key, fileName=None):
        &#34;&#34;&#34;Make a file upload object and registers it.

        An instance of class `control.datamodel.Upload` is created,
        geared to this particular field.

        !!! note &#34;Idempotent&#34;
            If the Upload object is already registered, nothing is done.

        Parameters
        ----------
        key: string
            Identifier for the upload.
            The configuration for this upload will be retrieved using this key.
            The new upload object will be stored under this key.
        fileName: string, optional None
            If present, it indicates that the uploaded file will have this prescribed
            name.
            A file name for an upload object may also have been specified in
            the datamodel configuration.

        Returns
        -------
        object
            The resulting Upload object.
            It is also added to the `uploadObjects` member.
        &#34;&#34;&#34;
        Settings = self.Settings

        uploadObjects = self.uploadObjects
        uploadsConfig = self.uploadsConfig

        if fileName is None:
            fileName = uploadsConfig.get(key, AttrDict()).fileName

        uploadObject = uploadObjects[(key, fileName)]
        if uploadObject:
            return uploadObject

        Messages = self.Messages
        Mongo = self.Mongo
        uploadsConfig = self.uploadsConfig

        uploadsConfig = AttrDict(**uploadsConfig[key])
        if uploadsConfig is None:
            Messages.error(logmsg=f&#34;Unknown upload key &#39;{key}&#39;&#34;)
        if fileName is not None:
            uploadsConfig[&#34;fileName&#34;] = fileName

        uploadObject = Upload(Settings, Messages, Mongo, key, **uploadsConfig)
        uploadObjects[(key, fileName)] = uploadObject
        return uploadObject

    def getUploadConfig(self, key):
        &#34;&#34;&#34;Get an upload config.

        Parameters
        ----------
        key: string
            The key of the upload config

        Returns
        -------
        object | void
            The upload config found under the given key and file name, if
            present, otherwise None
        &#34;&#34;&#34;
        return self.uploadsConfig[key]

    def getUploadObject(self, key, fileName=None):
        &#34;&#34;&#34;Get an upload object.

        Parameters
        ----------
        key: string
            The key of the upload object
        fileName: string, optional None
            The file name of the upload object.
            If not passed, the file name is derived from the config of the key.

        Returns
        -------
        object | void
            The upload object found under the given key and file name, if
            present, otherwise None
        &#34;&#34;&#34;
        if fileName is None:
            fileName = self.uploadsConfig[key].fileName
        return self.uploadObjects[(key, fileName)]


class Field:
    def __init__(self, Settings, Messages, Mongo, Datamodel, key, table, **kwargs):
        &#34;&#34;&#34;Handle field business.

        A Field object does not correspond with an individual field in a record.
        It represents a *column*, i.e. a set of fields with the same name in all
        records of a table.

        First of all there is a method to retrieve the value of the field from
        a specific record.

        Then there are methods to deliver those values, either bare or formatted,
        to produce edit widgets to modify the values, and handlers to save
        values.

        How to do this is steered by the specification of the field by keys and
        values that are stored in this object.

        Some field specifications may be table dependent. If a table is passed,
        we can get the table dependent values by means of the static method
        `control.datamodel.Datamodel.specialize`.

        All field access should be guarded by the authorisation rules.

        Parameters
        ----------
        table: string
            Name of the table for which we must specialize the field information
        kwargs: dict
            Field configuration arguments.
            It certain parts of the field configuration
            are not present, defaults will be provided.
        &#34;&#34;&#34;
        self.Settings = Settings
        self.Messages = Messages
        Messages.debugAdd(self)
        self.Mongo = Mongo
        self.Datamodel = Datamodel

        self.key = key
        &#34;&#34;&#34;The identifier of this field within the app.
        &#34;&#34;&#34;

        self.table = table
        &#34;&#34;&#34;The table for which this field is specialized.
        &#34;&#34;&#34;

        self.nameSpace = &#34;&#34;
        &#34;&#34;&#34;The first key to access the field data in a record.

        Example `dc` (Dublin Core). So if a record has Dublin Core
        metadata, we expect that metadata to exist under key `dc` in that record.

        If the nameSpace is `&#34;&#34;`, it is assumed that we can dig up the values without
        going into a nameSpace sub-record first.

        **NB.: This attribute is not table dependent.**
        &#34;&#34;&#34;

        self.fieldPath = key
        &#34;&#34;&#34;Compound selector in a nested dict.

        A string of keys, separated by `.`, which will be used to drill down
        into a nested dict. At the end of the path we find the selected value.

        This field selection is applied after the name space selection
        (if `nameSpace` is not the empty string).

        **NB.: This attribute is not table dependent.**
        &#34;&#34;&#34;

        self.tp = &#34;string&#34;
        &#34;&#34;&#34;The value type of the field.

        Value types can be string, integer, but also date-time, and values
        from an other table (keyword).

        The value &#34;keyword&#34; is used if the the field works with values from another
        table (i.e. values from the keyword table). It is assumed that all these values
        are strings.

        If True, the value of such a field must consist of zero or more elements
        of a prescribed list of keywords.

        These lists are associated with certain metadata fields and can be managed
        by admins in a widget on the MyWork page.

        We do not enforce that the value of such a field is a member of the
        associated list at all times. For example, if we import projects and editions
        that have been made with different lists of keywords in force, we accept
        foreign keywords. However, users will not be able to apply foreign keywords
        when they edit fields.

        **NB.: This attribute is not table dependent.**
        &#34;&#34;&#34;

        self.multiple = True
        &#34;&#34;&#34;Whether multiple values are allowed.

        **NB.: This attribute is not table dependent.**
        &#34;&#34;&#34;

        self.readonly = False
        &#34;&#34;&#34;Whether the field can be edited manually by authorized users.

        If this field is True, no user can directly change the value. Instead, the
        system will fill in this value, dependent on the completion of certain actions.

        **NB.: This attribute is not table dependent.**
        &#34;&#34;&#34;

        self.default = None
        &#34;&#34;&#34;A default value to deliver if the field has no value.

        **NB.: This attribute may be table dependent.**
        &#34;&#34;&#34;

        self.mandatory = False
        &#34;&#34;&#34;Whether a value is mandatory.

        **NB.: This attribute may be table dependent.**
        &#34;&#34;&#34;

        self.caption = key
        &#34;&#34;&#34;A caption that may be displayed with the field value.

        The caption may be a literal string with or without a placeholder `{}`.

        If there is no place holder, the caption will precede the content of
        the field.

        If there is a placeholder, the content will replace the place holder
        in the caption.

        **NB.: This attribute may be table dependent.**
        &#34;&#34;&#34;

        for arg, value in Datamodel.specialize(table, kwargs).items():
            if value is not None:
                setattr(self, arg, value)

    def specialize(self, table, record):
        &#34;&#34;&#34;Specializes a record to a table.

        Parameters
        ----------
        table: string
            The table in question
        record: dict | AttrDict
            The record in question

        Returns
        -------
        AttrDict
            The specialized record, a new copy
        &#34;&#34;&#34;
        return Datamodel.specialize(table, record)

    def logical(self, record):
        &#34;&#34;&#34;Give the logical value of the field in a record.

        Parameters
        ----------
        record: AttrDict
            The record in which the field value is stored.

        Returns
        -------
        any:
            Whatever the value is that we find for that field.
            No conversion/casting to other types will be performed.
            If the field is not present, returns None, without warning.
        &#34;&#34;&#34;
        nameSpace = self.nameSpace
        fieldPath = self.fieldPath

        fields = fieldPath.split(&#34;.&#34;)

        dataSource = record.get(nameSpace, {}) if nameSpace else record

        for field in fields[0:-1]:
            dataSource = dataSource.get(field, None)
            if dataSource is None:
                break

        value = None if dataSource is None else dataSource.get(fields[-1], None)

        return value

    def resolved(self, record):
        default = self.default
        logical = self.logical(record)
        return default if logical is None else logical

    def setLogical(self, record, value):
        &#34;&#34;&#34;Set the logical value of the field in a record.

        Parameters
        ----------
        record: AttrDict
            The record in which the field value is to be stored.
            It will be modified in place.
        value: object
            Any value to put into the record

        &#34;&#34;&#34;
        nameSpace = self.nameSpace
        fieldPath = self.fieldPath

        fields = fieldPath.split(&#34;.&#34;)

        dataSource = record.setdefault(nameSpace, AttrDict()) if nameSpace else record

        for field in fields[0:-1]:
            dataSource = dataSource.setdefault(field, AttrDict())

        dataSource[fields[-1]] = value

    def bare(self, record, compact=False, joined=False):
        &#34;&#34;&#34;Give the bare string value of the field in a record.

        If the logical value of the field is None, its default will be filled in.

        Parameters
        ----------
        record: AttrDict
            The record in which the field value is stored.
        compact: boolean, optional False
            Only relevant for datetime types: if True, omit the time, leaving only
            the date plus the timezone (always `Z` = UTC).
        joined: boolean|string, optional False
            Only relevant for fields with multiple values, but not of type text:
            If not False, it should be a string by which the values should be joined.

            For example, if the value is [2, 3], if joined is False the result is:
            `[2, 3]`, but if joined is &#34;;&#34; the result is `2;3`.


        Returns
        -------
        string:
            Whatever the value is that we find for that field, converted to string.
            If the field is not present, returns the empty string, without warning.
        &#34;&#34;&#34;
        tp = self.tp
        multiple = self.multiple

        resolved = self.resolved(record)

        # if not multiple and type(logical) in {list, tuple}:
        #    logical = logical[-1] if len(logical) else &#34;&#34;

        return (
            &#34;&#34;
            if resolved is None
            else (
                (resolved.split(&#34;T&#34;)[0] + &#34;Z&#34; if compact else resolved)
                if tp == &#34;datetime&#34;
                else (
                    str(resolved)
                    if joined is False
                    or tp == &#34;text&#34;
                    or not multiple
                    or type(resolved) in {str, int, bool}
                    else joined.join(str(r) for r in resolved)
                )
            )
        )

    def formatted(
        self,
        record,
        level=None,
        editable=False,
        outerCls=&#34;fieldouter&#34;,
        innerCls=&#34;fieldinner&#34;,
    ):
        &#34;&#34;&#34;Give the formatted value of the field in a record.

        Optionally also puts a caption and/or an edit control.

        The value retrieved is (recursively) wrapped in HTML, steered by an additional
        argument, as in `control.html.HtmlElements.wrapValue`.
        be applied.

        If the type is &#39;text&#39;, multiple values will simply be concatenated
        with newlines in between, and no extra classes will be applied.
        Instead, a markdown formatter is applied to the result.

        For other types:

        If the value is an iterable, each individual value is wrapped in a span
        to which an (other) extra CSS class may be applied.

        Parameters
        ----------
        table: string
            The table from which the record is taken
        record: string | ObjectId | AttrDict
            The record in which the field value is stored.
        level: integer, optional None
            The heading level in which a caption will be placed.
            If None, no caption will be placed.
            If 0, the caption will be placed in a span.
        editable: boolean, optional False
            Whether the field is editable by the current user.
            If so, edit controls are provided.
            But if the field has been declared as readonly in the field specs, no edit
            controls will be provided.
        outerCls: string optional &#34;fieldouter&#34;
            If given, an extra CSS class for the outer element that wraps the total
            value. Only relevant if the type is not &#39;text&#39;
        innerCls: string optional &#34;fieldinner&#34;
            If given, an extra CSS class for the inner elements that wrap parts of the
            value. Only relevant if the type is not &#39;text&#39;

        Returns
        -------
        string:
            Whatever the value is that we find for that field, converted to HTML.
            If the field is not present, returns the empty string, without warning.
        &#34;&#34;&#34;
        Settings = self.Settings
        Mongo = self.Mongo
        Datamodel = self.Datamodel

        H = Settings.H

        table = self.table

        (recordId, record) = Mongo.get(table, record)
        if recordId is None:
            return &#34;&#34;

        tp = self.tp
        caption = self.caption
        key = self.key
        multiple = self.multiple
        readonly = self.readonly

        bare = self.bare(record)
        resolved = self.resolved(record)

        # if table == &#34;site&#34; and key == &#34;abstract&#34;:
        bareRep = bare or H.i(f&#34;no {key}&#34;)

        if tp == &#34;text&#34;:
            readonlyContent = markdown(bareRep, tight=False)
        elif tp == &#34;datetime&#34; or tp == &#34;date&#34;:
            readonlyContent = bare or H.i(&#34;never&#34;)
        else:
            readonlyContent = H.wrapValue(
                resolved,
                outerElem=&#34;span&#34;,
                outerAtts=dict(cls=outerCls),
                innerElem=&#34;span&#34;,
                innerAtts=dict(cls=innerCls),
            )

        if editable and not readonly:
            keyRepUrl = &#34;&#34; if key is None else f&#34;/{key}&#34;
            saveUrl = f&#34;/save/{table}/{recordId}{keyRepUrl}&#34;
            updateButton = H.actionButton(&#34;edit_update&#34;, tip=f&#34; for field {key}&#34;)
            cancelButton = H.actionButton(&#34;edit_cancel&#34;, tip=f&#34; for field {key}&#34;)
            saveButton = H.actionButton(&#34;edit_save&#34;, tip=f&#34; for field {key}&#34;)
            messages = H.div(&#34;&#34;, cls=&#34;editmsgs&#34;)
            orig = (
                bare
                if tp == &#34;text&#34;
                else (
                    &#34;§&#34;.join(resolved or []) if tp == &#34;keyword&#34; else writeYaml(resolved)
                )
            )

            if tp == &#34;keyword&#34;:
                valueSet = (
                    set()
                    if resolved is None
                    else {resolved} if type(resolved) is str else set(resolved)
                )
                keywords = Datamodel.getKeywords(extra={key: valueSet})[key]
                options = (
                    [] if multiple else [(f&#34;Choose a {key} ...&#34;, &#34;&#34;, valueSet == set())]
                ) + [(k, k, k in valueSet) for k in keywords]
                editableContent = H.select(
                    options,
                    multiple=multiple,
                    cls=&#34;editcontent&#34;,
                    saveurl=saveUrl,
                    origValue=orig,
                    tp=tp,
                )
            else:
                editableContent = H.textarea(
                    &#34;&#34;, cls=&#34;editcontent&#34;, saveurl=saveUrl, origValue=orig, tp=key
                )

            content = &#34;&#34;.join(
                [
                    H.span(readonlyContent, cls=&#34;readonlycontent&#34;),
                    H.nbsp,
                    editableContent,
                    updateButton,
                    saveButton,
                    cancelButton,
                    messages,
                ]
            )
        else:
            content = readonlyContent

        if level is not None:
            if &#34;{value}&#34; in caption:
                theCaption = caption.format(kind=table, value=content)
                inCaption = True
            else:
                theCaption = caption
                inCaption = False

            if level == 0:
                elem = &#34;span&#34;
                cls = None
            else:
                elem = &#34;div&#34;
                cls = f&#34;lv lv{level}&#34;

            theCaption = H.elem(elem, theCaption, cls=cls)
        else:
            theCaption = &#34;&#34;
            inCaption = False

        fullContent = (&#34;&#34; if inCaption else theCaption) + (
            theCaption if inCaption else content
        )

        return H.div(
            fullContent,
            cls=&#34;editwidget&#34; if editable and not readonly else &#34;readonlywidget&#34;,
        )


class Upload:
    def __init__(self, Settings, Messages, Mongo, key, **kwargs):
        &#34;&#34;&#34;Handle upload business.

        An upload is like a field of type &#39;file&#39;.
        The name of the uploaded file is stored in a record in MongoDb.
        The contents of the file is stored on the file system.

        A Upload object does not correspond with an individual field in a record.
        It represents a *column*, i.e. a set of fields with the same name in all
        records of a table.

        First of all there is a method to retrieve the file name of an upload from
        a specific record.

        Then there are methods to deliver those values, either bare or formatted,
        to produce widgets to upload or delete the corresponding files.

        How to do this is steered by the specification of the upload by keys and
        values that are stored in this object.

        All upload access should be guarded by the authorisation rules.

        Parameters
        ----------
        kwargs: dict
            Upload configuration arguments.
            The following parts of the upload configuration
            should be present: `table`, `accept`, while `caption`, `fileName`,
            `show` are optional.
        &#34;&#34;&#34;
        self.Settings = Settings
        self.Messages = Messages
        Messages.debugAdd(self)
        self.Mongo = Mongo

        self.key = key
        &#34;&#34;&#34;The identifier of this upload within the app.
        &#34;&#34;&#34;

        self.table = kwargs.get(&#34;table&#34;, None)
        &#34;&#34;&#34;Indicates the directory where the actual file will be saved.

        Possibe values:

        * `site`: top level of the working data directory of the site
        * `project`: project directory of the project in question
        * `edition`: edition directory of the project in question
        &#34;&#34;&#34;

        self.accept = kwargs.get(&#34;accept&#34;, None)
        &#34;&#34;&#34;The file types that the field accepts.
        &#34;&#34;&#34;

        self.caption = kwargs.get(&#34;caption&#34;, f&#34;{self.table} ({self.accept})&#34;)
        &#34;&#34;&#34;The text to display on the upload button.
        &#34;&#34;&#34;

        self.multiple = kwargs.get(&#34;multiple&#34;, False)
        &#34;&#34;&#34;Whether multiple files of this type may be uploaded.
        &#34;&#34;&#34;

        self.fileName = kwargs.get(&#34;fileName&#34;, None)
        &#34;&#34;&#34;The name of the file once it is uploaded.

        The file name for the upload can be passed when the file name
        is known in advance.
        In that case, a file that is uploaded in this upload widget,
        will get this as prescribed file name, regardless of the file name in the
        upload request.

        Without a file name, the upload widget will show all existing files
        conforming to the `accept` setting, and will have a control to upload a
        new file.
        &#34;&#34;&#34;

        self.show = kwargs.get(&#34;show&#34;, False)
        &#34;&#34;&#34;Whether to show the contents of the file.

        This is typically the case when the file is an image to be presented
        as a logo.
        &#34;&#34;&#34;

        # let attributes be filled in from the function **kwargs

        for arg, value in kwargs.items():
            if value is not None:
                setattr(self, arg, value)

        # try to fill in defaults for attributes that are still None

        good = True

        for arg in (&#34;table&#34;, &#34;accept&#34;):
            if getattr(self, arg, None) is None:
                Messages.error(logmsg=f&#34;Missing info in Upload spec: {arg}&#34;)
                good = False

        if not good:
            quit()

    def getDir(self, record):
        &#34;&#34;&#34;Give the path to the file in question.

        The path can be used to build the static url and the save url.

        It does not contain the file name.
        If the path is non-empty, a &#34;/&#34; will be appended.

        Parameters
        ----------
        record: string | ObjectId | AttrDict
            The record relevant to the upload
        &#34;&#34;&#34;
        table = self.table
        recordId = record._id

        projectId = (
            recordId
            if table == &#34;project&#34;
            else record.projectId if table == &#34;edition&#34; else None
        )
        editionId = recordId if table == &#34;edition&#34; else None

        path = (
            &#34;&#34;
            if table == &#34;site&#34;
            else (
                f&#34;project/{projectId}&#34;
                if table == &#34;project&#34;
                else (
                    f&#34;project/{projectId}/edition/{editionId}&#34;
                    if table == &#34;edition&#34;
                    else None
                )
            )
        )
        sep = &#34;/&#34; if path else &#34;&#34;
        return f&#34;{path}{sep}&#34;

    def formatted(self, record, mayChange=False, bust=None, wrapped=True):
        &#34;&#34;&#34;Give the formatted value of a file field in a record.

        Optionally also puts an upload control.

        Parameters
        ----------
        record: string | ObjectId | AttrDict
            The record relevant to the upload
        mayChange: boolean, optional False
            Whether the file may be changed.
            If so, an upload widget is supplied, wich contains a a delete button.
        bust: string, optional None
            If not None, the image url of the file whose name is passed in
            `bust` is made unique by adding the current time to it.
            This is a cache buster.
        wrapped: boolean, optional True
            Whether the content should be wrapped in a container element.
            See `control.html.HtmlElements.finput()`.

        Returns
        -------
        string
            The name of the uploaded file(s) and/or an upload control.
        &#34;&#34;&#34;
        Settings = self.Settings
        H = Settings.H
        workingDir = Settings.workingDir

        key = self.key
        fileName = self.fileName
        accept = self.accept
        caption = self.caption
        show = self.show

        recordId = record._id

        fileNameRep = &#34;-&#34; if fileName is None else fileName
        fid = f&#34;{recordId}/{key}/{fileNameRep}&#34;

        path = self.getDir(record)
        sep = &#34;/&#34; if path else &#34;&#34;
        fullDir = f&#34;{workingDir}{sep}{path}&#34;
        saveUrl = f&#34;/upload/{fid}{sep}{path}&#34;
        deleteUrl = f&#34;/deletefile/{fid}{sep}{path}&#34;.rstrip(&#34;/&#34;) + &#34;/&#34;

        if fileName is None:
            content = []
            for fileNm in listFilesAccepted(fullDir, accept, withExt=True):
                buster = (
                    f&#34;?v={pseudoisonow()}&#34;
                    if show and bust is not None and bust == fileNm
                    else &#34;&#34;
                )
                item = [fileNm, f&#34;/data/{path}{fileNm}{buster}&#34; if show else None]
                content.append(item)
        else:
            buster = (
                f&#34;?v={pseudoisonow()}&#34;
                if show and bust is not None and bust == fileName
                else &#34;&#34;
            )
            fullPath = (f&#34;{workingDir}{sep}{path}&#34;).rstrip(&#34;/&#34;) + f&#34;/{fileName}&#34;
            exists = fileExists(fullPath)
            content = (
                fileName,
                exists,
                f&#34;/data/{path}{fileName}{buster}&#34; if show else None,
            )

        return H.finput(
            content,
            accept,
            mayChange,
            saveUrl,
            deleteUrl,
            caption,
            wrapped=wrapped,
            buttonCls=&#34;button small&#34;,
            cls=f&#34;{key.lower()}&#34;,
        )</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="control.datamodel.Datamodel"><code class="flex name class">
<span>class <span class="ident">Datamodel</span></span>
<span>(</span><span>Settings, Messages, Mongo)</span>
</code></dt>
<dd>
<div class="desc"><p>Datamodel related operations.</p>
<p>This class has methods to manipulate various pieces of content
in the data sources, and hand it over to higher level objects.</p>
<p>It can find out dependencies between related records, and it knows
a thing or two about fields.</p>
<p>It is instantiated by a singleton object.</p>
<p>It has a method which is a factory for <code><a title="control.datamodel.Field" href="#control.datamodel.Field">Field</a></code> objects,
which deal with individual fields.</p>
<p>Likewise it has a factory function for <code><a title="control.datamodel.Upload" href="#control.datamodel.Upload">Upload</a></code> objects,
which deal with file uploads.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>Settings</code></strong> :&ensp;<code>AttrDict</code></dt>
<dd>App-wide configuration data obtained from
<code><a title="control.config.Config.Settings" href="config.html#control.config.Config.Settings">Config.Settings</a></code>.</dd>
<dt><strong><code>Messages</code></strong> :&ensp;<code>object</code></dt>
<dd>Singleton instance of <code><a title="control.messages.Messages" href="messages.html#control.messages.Messages">Messages</a></code>.</dd>
<dt><strong><code>Mongo</code></strong> :&ensp;<code>object</code></dt>
<dd>Singleton instance of <code><a title="control.mongo.Mongo" href="mongo.html#control.mongo.Mongo">Mongo</a></code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/99a827eec565f9f7bf0633f62d3c060d35dd93dc/src/control/datamodel.py#L7-L634" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Datamodel:
    def __init__(self, Settings, Messages, Mongo):
        &#34;&#34;&#34;Datamodel related operations.

        This class has methods to manipulate various pieces of content
        in the data sources, and hand it over to higher level objects.

        It can find out dependencies between related records, and it knows
        a thing or two about fields.

        It is instantiated by a singleton object.

        It has a method which is a factory for `control.datamodel.Field` objects,
        which deal with individual fields.

        Likewise it has a factory function for `control.datamodel.Upload` objects,
        which deal with file uploads.

        Parameters
        ----------
        Settings: AttrDict
            App-wide configuration data obtained from
            `control.config.Config.Settings`.
        Messages: object
            Singleton instance of `control.messages.Messages`.
        Mongo: object
            Singleton instance of `control.mongo.Mongo`.
        &#34;&#34;&#34;
        self.Settings = Settings
        self.Messages = Messages
        Messages.debugAdd(self)
        self.Mongo = Mongo

        datamodel = Settings.datamodel
        self.detailMaster = datamodel.detailMaster
        self.masterDetail = datamodel.masterDetail
        self.mainLink = datamodel.mainLink
        textsConfig = datamodel.texts
        fieldsConfig = datamodel.fields
        fieldDistribution = datamodel.fieldDistribution
        self.uploadsConfig = datamodel.uploads
        self.fieldObjects = AttrDict()
        self.uploadObjects = AttrDict()

        fieldPaths = {}

        for f, cfg in fieldsConfig.items():
            nameSpace = cfg.nameSpace or &#34;&#34;
            fieldPath = cfg.fieldPath or f
            sep = &#34;.&#34; if nameSpace and fieldPath else &#34;&#34;
            fieldPaths[f] = f&#34;{nameSpace}{sep}{fieldPath}&#34;

        self.textsConfig = textsConfig
        self.fieldsConfig = fieldsConfig
        self.fieldDistribution = fieldDistribution
        self.fieldPaths = fieldPaths

    @staticmethod
    def specialize(table, record):
        &#34;&#34;&#34;Specializes information to a table.

        Field information is a mapping of keys to values.
        When values are dicts, their keys are table names.
        If a table is given, we can specialize for that table.
        If the table does not occur as a key, we look if there is a key `&#34;&#34;`,
        and if so, we use that value. Otherwise we use None.

        Parameters
        ----------
        table: string
            The table to which we must specialize the record
        record: dict | AttrDict
            The record, of which some fields have values per table

        Returns
        -------
        AttrDict
            The specialized record (a new copy)
        &#34;&#34;&#34;
        new = AttrDict()

        for k, v in record.items():
            if type(v) in {dict, AttrDict}:
                new[k] = v.get(table, v.get(&#34;&#34;, None))
            else:
                new[k] = v

        return new

    def getTexts(self):
        &#34;&#34;&#34;Get the names and info for the fixed text pages.

        The contents of these pages are stored in fields the site record,
        the path to the field is given in the text info dict.

        Returns
        -------
        dict
            Keyed by the name of the text, values are keys for the corresponding
            metadata fields in the site record where the text is stored.
        &#34;&#34;&#34;
        return self.textsConfig

    def getMetaFields(self, table, kinds, level=None, asDict=False):
        &#34;&#34;&#34;Get the list of metadata fields for in the meta box.

        Parameters
        ----------
        table: string
            Either `site` or `project` or `edition`
        kinds: list | string | void
            The kinds of fields to fetch: one or more of &#34;main&#34;, &#34;box&#34; or &#34;narrative&#34;.
            If None, all kinds are used, in the order :main&#34;, &#34;narrative&#34;, &#34;box&#34;.
            If a string: it is the single kind that is being used.
        level: integer, optional None
            If not None, append @ plus level to each meta key that is delivered,
            and join the components with ` + `
            If one of the fields is `title`, its level is one lower.
        asDict: boolean, optional False
            If True, the `level` parameter will be ignored.
            Returns a dictionary with the field names as keys, and the field information
            as values, specialized to the given table.

        Returns
        -------
        dict | tuple of string | string
            Returns a dict if `asDict` is True.
            The meta keys in question, as a tuple if level is None, otherwise as a
            &#34;+&#34;-separated string where each item is appended with a level indicator
        &#34;&#34;&#34;
        fieldDistribution = self.fieldDistribution
        fieldsConfig = self.fieldsConfig

        result = {} if asDict else []

        kinds = (
            [&#34;main&#34;, &#34;narrative&#34;, &#34;box&#34;]
            if kinds is None
            else [kinds] if type(kinds) is str else list(kinds)
        )

        for k in kinds:
            fields = fieldDistribution.get(k, {}).get(table, [])

            if asDict:
                for f in fields:
                    result[f] = self.specialize(table, fieldsConfig.get(f, AttrDict()))
            else:
                result.extend(fields)

        return (
            result
            if asDict
            else (
                tuple(result)
                if level is None
                else &#34; + &#34;.join(
                    f&#34;{x}@{level - 1 if x == &#39;title&#39; else level}&#34; for x in result
                )
            )
        )

    def checkMetaFields(self, table):
        &#34;&#34;&#34;Get the list of metadata fields that must be present before publication.

        Parameters
        ----------
        table: string
            Either `site` or `project` or `edition`

        Returns
        -------
        tuple of string
            The meta keys in question
        &#34;&#34;&#34;
        fieldDistribution = self.fieldDistribution
        fieldsConfig = self.fieldsConfig

        kinds = (&#34;main&#34;, &#34;narrative&#34;, &#34;box&#34;)

        result = []

        for k in kinds:
            fields = fieldDistribution.get(k, {}).get(table, [])

            for f in fields:
                info = self.specialize(table, fieldsConfig.get(f, AttrDict()))

                if info.mandatory:
                    result.append(f)

        return tuple(result)

    def getMarkdownFields(self):
        &#34;&#34;&#34;Gives the set of all fields with markdown content.

        Returns
        -------
        set
        &#34;&#34;&#34;
        fieldsConfig = self.fieldsConfig

        return {f for (f, cfg) in fieldsConfig.items() if cfg.get(&#34;tp&#34;, None) == &#34;text&#34;}

    def getListFields(self):
        &#34;&#34;&#34;Gives the set of all fields with list content.

        Returns
        -------
        set
        &#34;&#34;&#34;
        fieldsConfig = self.fieldsConfig

        return {
            f
            for (f, cfg) in fieldsConfig.items()
            if cfg.get(&#34;multiple&#34;, True)
            and cfg.get(&#34;tp&#34;, None) not in {&#34;text&#34;, &#34;datetime&#34;}
        }

    def relevant(self, project=None, edition=None):
        &#34;&#34;&#34;Get a relevant record and the table to which it belongs.

        A relevant record is either a project record, or an edition record,
        or the one and only site record.

        If all optional parameters are None, we look for the site record.
        If the project parameter is not None, we look for the project record.

        This is the inverse of `context()`.

        Paramenters
        -----------
        project: string | ObjectId | AttrDict, optional None
            The project whose record we need.
        edition: string | ObjectId | AttrDict, optional None
            The edition whose record we need.

        Returns
        -------
        tuple
            * table: string; the table in which the record is found
            * record id: string; the id of the record
            * record: AttrDict; the record itself

            If both project and edition are not None
        &#34;&#34;&#34;
        Settings = self.Settings
        Mongo = self.Mongo

        if edition is not None:
            table = &#34;edition&#34;
            (recordId, record) = Mongo.get(table, edition)
        elif project is not None:
            table = &#34;project&#34;
            (recordId, record) = Mongo.get(table, project)
        else:
            table = &#34;site&#34;
            siteCrit = Settings.siteCrit
            record = Mongo.getRecord(table, siteCrit)
            recordId = record._id

        return (table, recordId, record)

    def context(self, table, record):
        &#34;&#34;&#34;Get the context of a record.

        Get the project and edition records to which the record belongs.

        Parameters
        ----------
        table: string
            The table in which the record sits.
        record: string
            The record.

        This is the inverse of `relevant()`.

        Returns
        -------
        tuple of tuple
            (siteId, site, projectId, project, editionId, edition)
        &#34;&#34;&#34;
        Mongo = self.Mongo

        (recordId, record) = Mongo.get(table, record)

        if recordId is None:
            return (None, None, None, None, None, None)

        if table == &#34;site&#34;:
            (editionId, edition) = (None, None)
            (projectId, project) = (None, None)
            (siteId, site) = (recordId, record)
        elif table == &#34;project&#34;:
            (editionId, edition) = (None, None)
            (projectId, project) = (recordId, record)
            (siteId, site) = Mongo.get(&#34;site&#34;, record.siteId)
        elif table == &#34;edition&#34;:
            (editionId, edition) = (recordId, record)
            (projectId, project) = Mongo.get(&#34;project&#34;, record.projectId)
            (siteId, site) = Mongo.get(&#34;site&#34;, project.siteId)

        return (siteId, site, projectId, project, editionId, edition)

    def getDetailRecords(self, masterTable, master):
        &#34;&#34;&#34;Retrieve the detail records of a master record.

        It finds all records that have a field containing an id of the
        given master record. But not those in cross-link records.

        Details are not retrieved recursively, only the direct details
        of a master are fetched.

        Parameters
        ----------
        masterTable: string
            The name of the table in which the master record lives.
        master: string | ObjectId | AttrDict
            The master record.

        Returns
        -------
        AttrDict
            The list of detail records, categorized by detail table in which
            they occur. The detail tables are the keys, the lists of records
            in those tables are the values.
            If the master record cannot be found or if there are no detail
            records, the empty dict is returned.
        &#34;&#34;&#34;
        Mongo = self.Mongo
        masterDetail = self.masterDetail

        detailTable = masterDetail[masterTable]
        if detailTable is None:
            return AttrDict()

        (masterId, master) = Mongo.get(masterTable, master)
        if masterId is None:
            return AttrDict()

        crit = {f&#34;{masterTable}Id&#34;: masterId}

        detailRecords = AttrDict()

        details = Mongo.getList(detailTable, crit)

        if len(details):
            detailRecords[detailTable] = details

        return detailRecords

    def getUserWork(self, user):
        &#34;&#34;&#34;Gets the number of project and edition records of a user.

        We will not delete users if the user is linked to a project or edition.
        This function counts how many projects and editions a user is linked to.

        Parameters
        ----------
        user: string
            The name of the user (field `user` in the record)

        Returns
        -------
        integer
            The number of projects
        integer
            The number of editions
        &#34;&#34;&#34;
        Mongo = self.Mongo
        nProjects = len(Mongo.getList(&#34;projectUser&#34;, dict(user=user)))
        nEditions = len(Mongo.getList(&#34;EditionUser&#34;, dict(user=user)))
        return (nProjects, nEditions)

    def getLinkedCrit(self, table, record, deleted=False):
        &#34;&#34;&#34;Produce criteria to retrieve the linked records of a record.

        It finds all cross-linked records containing an id of the
        given record.

        So no detail records.

        Parameters
        ----------
        table: string
            The name of the table in which the record lives.
        record: string | ObjectId | AttrDict
            The record.
        deleted: boolean, optional False
            Search only in the records that are marked for deletion

        Returns
        -------
        AttrDict
            Keys: tables in which linked records exist.
            Values: the criteria to find those linked records in that table.
        &#34;&#34;&#34;
        Mongo = self.Mongo
        mainLink = self.mainLink

        linkTables = mainLink[table]

        if linkTables is None:
            return AttrDict()

        (recordId, record) = Mongo.get(table, record, deleted=deleted)

        if recordId is None:
            return AttrDict()

        crit = {f&#34;{table}Id&#34;: recordId}

        linkCriteria = AttrDict()

        for linkTable in linkTables:
            linkCriteria[linkTable] = crit

        return linkCriteria

    def getKeywords(self, extra=None):
        &#34;&#34;&#34;Get the lists of keywords that act as values for metadata fields.

        A keyword is a string value and it belongs to a list of keywords.
        The metadata fields that are declared with `tp: keyword` are associated
        with a list of values: keywords.

        We read the table of keywords, organize it by metadata field, and count
        how many edition/project record use that keyword.

        Parameters
        ----------
        extra: dict, optional None
            If passed, it is a dictionary keyed by metadata keys and valued
            with value sets for those metadata keys. These values must be added to
            the respective keyword lists.
            These are typically from existing values in metadata fields that
            have been accepted when different keyword lists were in effect.

        Returns
        -------
        dict
            keyed by name of the metadata field, then by the keyword itself,
            and valued by the number of edition/project records it occurs in.
        &#34;&#34;&#34;
        Mongo = self.Mongo
        Settings = self.Settings
        datamodel = Settings.datamodel
        fieldsConfig = datamodel.fields
        fieldPaths = self.fieldPaths

        keywordLists = {
            field for (field, cfg) in fieldsConfig.items() if cfg.tp == &#34;keyword&#34;
        }

        keywords = {}

        for name in keywordLists:
            keywords[name] = {}

        keywordItems = Mongo.getList(&#34;keyword&#34;, {})

        for keywordRecord in keywordItems:
            name = keywordRecord.name

            if name not in keywords:
                # in this case, the existing keywords contain vocab lists
                # that are not associated with a metadata field:
                # either the metadata config has changed
                # or the keywords come from a different instance
                keywords[name] = {}

            fieldPath = fieldPaths[name]
            value = keywordRecord.value
            criteria = {fieldPath: value}
            recordsP = Mongo.getList(&#34;project&#34;, criteria)
            recordsE = Mongo.getList(&#34;edition&#34;, criteria)
            occs = len(recordsP) + len(recordsE)
            keywords[name][value] = occs

        if extra is not None:
            for name, values in extra.items():
                fieldPath = fieldPaths[name]

                for value in values:
                    criteria = {fieldPath: value}
                    recordsP = Mongo.getList(&#34;project&#34;, criteria)
                    recordsE = Mongo.getList(&#34;edition&#34;, criteria)
                    occs = len(recordsP) + len(recordsE)
                    keywords[name][value] = occs

        return keywords

    def makeField(self, key, table):
        &#34;&#34;&#34;Make a field object and registers it.

        An instance of class `control.datamodel.Field` is created,
        geared to this particular field.

        !!! note &#34;Idempotent&#34;
            If the Field object is already registered, nothing is done.
            Field objects are registered under their key and table.

        Parameters
        ----------
        key: string
            Identifier for the field.
            The configuration for this field will be retrieved using this key.

        Returns
        -------
        object
            The resulting Field object.
            It is also added to the `fieldObjects` member.
        &#34;&#34;&#34;
        Settings = self.Settings

        fieldObjects = self.fieldObjects

        fieldObject = fieldObjects[(key, table)]

        if fieldObject:
            return fieldObject

        Messages = self.Messages
        Mongo = self.Mongo
        fieldsConfig = self.fieldsConfig

        fieldConfig = fieldsConfig[key]

        if fieldConfig is None:
            Messages.error(logmsg=f&#34;Unknown field key &#39;{key}&#39;&#34;)
            fieldConfig = AttrDict()

        fieldObject = Field(Settings, Messages, Mongo, self, key, table, **fieldConfig)

        fieldObjects[(key, table)] = fieldObject
        return fieldObject

    def makeUpload(self, key, fileName=None):
        &#34;&#34;&#34;Make a file upload object and registers it.

        An instance of class `control.datamodel.Upload` is created,
        geared to this particular field.

        !!! note &#34;Idempotent&#34;
            If the Upload object is already registered, nothing is done.

        Parameters
        ----------
        key: string
            Identifier for the upload.
            The configuration for this upload will be retrieved using this key.
            The new upload object will be stored under this key.
        fileName: string, optional None
            If present, it indicates that the uploaded file will have this prescribed
            name.
            A file name for an upload object may also have been specified in
            the datamodel configuration.

        Returns
        -------
        object
            The resulting Upload object.
            It is also added to the `uploadObjects` member.
        &#34;&#34;&#34;
        Settings = self.Settings

        uploadObjects = self.uploadObjects
        uploadsConfig = self.uploadsConfig

        if fileName is None:
            fileName = uploadsConfig.get(key, AttrDict()).fileName

        uploadObject = uploadObjects[(key, fileName)]
        if uploadObject:
            return uploadObject

        Messages = self.Messages
        Mongo = self.Mongo
        uploadsConfig = self.uploadsConfig

        uploadsConfig = AttrDict(**uploadsConfig[key])
        if uploadsConfig is None:
            Messages.error(logmsg=f&#34;Unknown upload key &#39;{key}&#39;&#34;)
        if fileName is not None:
            uploadsConfig[&#34;fileName&#34;] = fileName

        uploadObject = Upload(Settings, Messages, Mongo, key, **uploadsConfig)
        uploadObjects[(key, fileName)] = uploadObject
        return uploadObject

    def getUploadConfig(self, key):
        &#34;&#34;&#34;Get an upload config.

        Parameters
        ----------
        key: string
            The key of the upload config

        Returns
        -------
        object | void
            The upload config found under the given key and file name, if
            present, otherwise None
        &#34;&#34;&#34;
        return self.uploadsConfig[key]

    def getUploadObject(self, key, fileName=None):
        &#34;&#34;&#34;Get an upload object.

        Parameters
        ----------
        key: string
            The key of the upload object
        fileName: string, optional None
            The file name of the upload object.
            If not passed, the file name is derived from the config of the key.

        Returns
        -------
        object | void
            The upload object found under the given key and file name, if
            present, otherwise None
        &#34;&#34;&#34;
        if fileName is None:
            fileName = self.uploadsConfig[key].fileName
        return self.uploadObjects[(key, fileName)]</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="control.content.Content" href="content.html#control.content.Content">Content</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="control.datamodel.Datamodel.specialize"><code class="name flex">
<span>def <span class="ident">specialize</span></span>(<span>table, record)</span>
</code></dt>
<dd>
<div class="desc"><p>Specializes information to a table.</p>
<p>Field information is a mapping of keys to values.
When values are dicts, their keys are table names.
If a table is given, we can specialize for that table.
If the table does not occur as a key, we look if there is a key <code>""</code>,
and if so, we use that value. Otherwise we use None.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>table</code></strong> :&ensp;<code>string</code></dt>
<dd>The table to which we must specialize the record</dd>
<dt><strong><code>record</code></strong> :&ensp;<code>dict | AttrDict</code></dt>
<dd>The record, of which some fields have values per table</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>AttrDict</code></dt>
<dd>The specialized record (a new copy)</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="control.datamodel.Datamodel.checkMetaFields"><code class="name flex">
<span>def <span class="ident">checkMetaFields</span></span>(<span>self, table)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the list of metadata fields that must be present before publication.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>table</code></strong> :&ensp;<code>string</code></dt>
<dd>Either <code>site</code> or <code>project</code> or <code>edition</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code> of <code>string</code></dt>
<dd>The meta keys in question</dd>
</dl></div>
</dd>
<dt id="control.datamodel.Datamodel.context"><code class="name flex">
<span>def <span class="ident">context</span></span>(<span>self, table, record)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the context of a record.</p>
<p>Get the project and edition records to which the record belongs.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>table</code></strong> :&ensp;<code>string</code></dt>
<dd>The table in which the record sits.</dd>
<dt><strong><code>record</code></strong> :&ensp;<code>string</code></dt>
<dd>The record.</dd>
</dl>
<p>This is the inverse of <code>relevant()</code>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code> of <code>tuple</code></dt>
<dd>(siteId, site, projectId, project, editionId, edition)</dd>
</dl></div>
</dd>
<dt id="control.datamodel.Datamodel.getDetailRecords"><code class="name flex">
<span>def <span class="ident">getDetailRecords</span></span>(<span>self, masterTable, master)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve the detail records of a master record.</p>
<p>It finds all records that have a field containing an id of the
given master record. But not those in cross-link records.</p>
<p>Details are not retrieved recursively, only the direct details
of a master are fetched.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>masterTable</code></strong> :&ensp;<code>string</code></dt>
<dd>The name of the table in which the master record lives.</dd>
<dt><strong><code>master</code></strong> :&ensp;<code>string | ObjectId | AttrDict</code></dt>
<dd>The master record.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>AttrDict</code></dt>
<dd>The list of detail records, categorized by detail table in which
they occur. The detail tables are the keys, the lists of records
in those tables are the values.
If the master record cannot be found or if there are no detail
records, the empty dict is returned.</dd>
</dl></div>
</dd>
<dt id="control.datamodel.Datamodel.getKeywords"><code class="name flex">
<span>def <span class="ident">getKeywords</span></span>(<span>self, extra=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the lists of keywords that act as values for metadata fields.</p>
<p>A keyword is a string value and it belongs to a list of keywords.
The metadata fields that are declared with <code>tp: keyword</code> are associated
with a list of values: keywords.</p>
<p>We read the table of keywords, organize it by metadata field, and count
how many edition/project record use that keyword.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>extra</code></strong> :&ensp;<code>dict</code>, optional <code>None</code></dt>
<dd>If passed, it is a dictionary keyed by metadata keys and valued
with value sets for those metadata keys. These values must be added to
the respective keyword lists.
These are typically from existing values in metadata fields that
have been accepted when different keyword lists were in effect.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>keyed by name of the metadata field, then by the keyword itself,
and valued by the number of edition/project records it occurs in.</dd>
</dl></div>
</dd>
<dt id="control.datamodel.Datamodel.getLinkedCrit"><code class="name flex">
<span>def <span class="ident">getLinkedCrit</span></span>(<span>self, table, record, deleted=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Produce criteria to retrieve the linked records of a record.</p>
<p>It finds all cross-linked records containing an id of the
given record.</p>
<p>So no detail records.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>table</code></strong> :&ensp;<code>string</code></dt>
<dd>The name of the table in which the record lives.</dd>
<dt><strong><code>record</code></strong> :&ensp;<code>string | ObjectId | AttrDict</code></dt>
<dd>The record.</dd>
<dt><strong><code>deleted</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>Search only in the records that are marked for deletion</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>AttrDict</code></dt>
<dd>Keys: tables in which linked records exist.
Values: the criteria to find those linked records in that table.</dd>
</dl></div>
</dd>
<dt id="control.datamodel.Datamodel.getListFields"><code class="name flex">
<span>def <span class="ident">getListFields</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Gives the set of all fields with list content.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>set</code></dt>
<dd>&nbsp;</dd>
</dl></div>
</dd>
<dt id="control.datamodel.Datamodel.getMarkdownFields"><code class="name flex">
<span>def <span class="ident">getMarkdownFields</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Gives the set of all fields with markdown content.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>set</code></dt>
<dd>&nbsp;</dd>
</dl></div>
</dd>
<dt id="control.datamodel.Datamodel.getMetaFields"><code class="name flex">
<span>def <span class="ident">getMetaFields</span></span>(<span>self, table, kinds, level=None, asDict=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the list of metadata fields for in the meta box.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>table</code></strong> :&ensp;<code>string</code></dt>
<dd>Either <code>site</code> or <code>project</code> or <code>edition</code></dd>
<dt><strong><code>kinds</code></strong> :&ensp;<code>list | string | void</code></dt>
<dd>The kinds of fields to fetch: one or more of "main", "box" or "narrative".
If None, all kinds are used, in the order :main", "narrative", "box".
If a string: it is the single kind that is being used.</dd>
<dt><strong><code>level</code></strong> :&ensp;<code>integer</code>, optional <code>None</code></dt>
<dd>If not None, append @ plus level to each meta key that is delivered,
and join the components with <code>+</code>
If one of the fields is <code>title</code>, its level is one lower.</dd>
<dt><strong><code>asDict</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>If True, the <code>level</code> parameter will be ignored.
Returns a dictionary with the field names as keys, and the field information
as values, specialized to the given table.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict | tuple</code> of <code>string | string</code></dt>
<dd>Returns a dict if <code>asDict</code> is True.
The meta keys in question, as a tuple if level is None, otherwise as a
"+"-separated string where each item is appended with a level indicator</dd>
</dl></div>
</dd>
<dt id="control.datamodel.Datamodel.getTexts"><code class="name flex">
<span>def <span class="ident">getTexts</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the names and info for the fixed text pages.</p>
<p>The contents of these pages are stored in fields the site record,
the path to the field is given in the text info dict.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>Keyed by the name of the text, values are keys for the corresponding
metadata fields in the site record where the text is stored.</dd>
</dl></div>
</dd>
<dt id="control.datamodel.Datamodel.getUploadConfig"><code class="name flex">
<span>def <span class="ident">getUploadConfig</span></span>(<span>self, key)</span>
</code></dt>
<dd>
<div class="desc"><p>Get an upload config.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>key</code></strong> :&ensp;<code>string</code></dt>
<dd>The key of the upload config</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>object | void</code></dt>
<dd>The upload config found under the given key and file name, if
present, otherwise None</dd>
</dl></div>
</dd>
<dt id="control.datamodel.Datamodel.getUploadObject"><code class="name flex">
<span>def <span class="ident">getUploadObject</span></span>(<span>self, key, fileName=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get an upload object.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>key</code></strong> :&ensp;<code>string</code></dt>
<dd>The key of the upload object</dd>
<dt><strong><code>fileName</code></strong> :&ensp;<code>string</code>, optional <code>None</code></dt>
<dd>The file name of the upload object.
If not passed, the file name is derived from the config of the key.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>object | void</code></dt>
<dd>The upload object found under the given key and file name, if
present, otherwise None</dd>
</dl></div>
</dd>
<dt id="control.datamodel.Datamodel.getUserWork"><code class="name flex">
<span>def <span class="ident">getUserWork</span></span>(<span>self, user)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the number of project and edition records of a user.</p>
<p>We will not delete users if the user is linked to a project or edition.
This function counts how many projects and editions a user is linked to.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>user</code></strong> :&ensp;<code>string</code></dt>
<dd>The name of the user (field <code>user</code> in the record)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>integer</code></dt>
<dd>The number of projects</dd>
<dt><code>integer</code></dt>
<dd>The number of editions</dd>
</dl></div>
</dd>
<dt id="control.datamodel.Datamodel.makeField"><code class="name flex">
<span>def <span class="ident">makeField</span></span>(<span>self, key, table)</span>
</code></dt>
<dd>
<div class="desc"><p>Make a field object and registers it.</p>
<p>An instance of class <code><a title="control.datamodel.Field" href="#control.datamodel.Field">Field</a></code> is created,
geared to this particular field.</p>
<div class="admonition note">
<p class="admonition-title">Idempotent</p>
<p>If the Field object is already registered, nothing is done.
Field objects are registered under their key and table.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>key</code></strong> :&ensp;<code>string</code></dt>
<dd>Identifier for the field.
The configuration for this field will be retrieved using this key.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>object</code></dt>
<dd>The resulting Field object.
It is also added to the <code>fieldObjects</code> member.</dd>
</dl></div>
</dd>
<dt id="control.datamodel.Datamodel.makeUpload"><code class="name flex">
<span>def <span class="ident">makeUpload</span></span>(<span>self, key, fileName=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Make a file upload object and registers it.</p>
<p>An instance of class <code><a title="control.datamodel.Upload" href="#control.datamodel.Upload">Upload</a></code> is created,
geared to this particular field.</p>
<div class="admonition note">
<p class="admonition-title">Idempotent</p>
<p>If the Upload object is already registered, nothing is done.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>key</code></strong> :&ensp;<code>string</code></dt>
<dd>Identifier for the upload.
The configuration for this upload will be retrieved using this key.
The new upload object will be stored under this key.</dd>
<dt><strong><code>fileName</code></strong> :&ensp;<code>string</code>, optional <code>None</code></dt>
<dd>If present, it indicates that the uploaded file will have this prescribed
name.
A file name for an upload object may also have been specified in
the datamodel configuration.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>object</code></dt>
<dd>The resulting Upload object.
It is also added to the <code>uploadObjects</code> member.</dd>
</dl></div>
</dd>
<dt id="control.datamodel.Datamodel.relevant"><code class="name flex">
<span>def <span class="ident">relevant</span></span>(<span>self, project=None, edition=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get a relevant record and the table to which it belongs.</p>
<p>A relevant record is either a project record, or an edition record,
or the one and only site record.</p>
<p>If all optional parameters are None, we look for the site record.
If the project parameter is not None, we look for the project record.</p>
<p>This is the inverse of <code>context()</code>.</p>
<h2 id="paramenters">Paramenters</h2>
<p>project: string | ObjectId | AttrDict, optional None
The project whose record we need.
edition: string | ObjectId | AttrDict, optional None
The edition whose record we need.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>
<ul>
<li>table: string; the table in which the record is found</li>
<li>record id: string; the id of the record</li>
<li>record: AttrDict; the record itself</li>
</ul>
<p>If both project and edition are not None</p>
</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="control.datamodel.Field"><code class="flex name class">
<span>class <span class="ident">Field</span></span>
<span>(</span><span>Settings, Messages, Mongo, Datamodel, key, table, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Handle field business.</p>
<p>A Field object does not correspond with an individual field in a record.
It represents a <em>column</em>, i.e. a set of fields with the same name in all
records of a table.</p>
<p>First of all there is a method to retrieve the value of the field from
a specific record.</p>
<p>Then there are methods to deliver those values, either bare or formatted,
to produce edit widgets to modify the values, and handlers to save
values.</p>
<p>How to do this is steered by the specification of the field by keys and
values that are stored in this object.</p>
<p>Some field specifications may be table dependent. If a table is passed,
we can get the table dependent values by means of the static method
<code><a title="control.datamodel.Datamodel.specialize" href="#control.datamodel.Datamodel.specialize">Datamodel.specialize()</a></code>.</p>
<p>All field access should be guarded by the authorisation rules.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>table</code></strong> :&ensp;<code>string</code></dt>
<dd>Name of the table for which we must specialize the field information</dd>
<dt><strong><code>kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Field configuration arguments.
It certain parts of the field configuration
are not present, defaults will be provided.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/99a827eec565f9f7bf0633f62d3c060d35dd93dc/src/control/datamodel.py#L637-L1075" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Field:
    def __init__(self, Settings, Messages, Mongo, Datamodel, key, table, **kwargs):
        &#34;&#34;&#34;Handle field business.

        A Field object does not correspond with an individual field in a record.
        It represents a *column*, i.e. a set of fields with the same name in all
        records of a table.

        First of all there is a method to retrieve the value of the field from
        a specific record.

        Then there are methods to deliver those values, either bare or formatted,
        to produce edit widgets to modify the values, and handlers to save
        values.

        How to do this is steered by the specification of the field by keys and
        values that are stored in this object.

        Some field specifications may be table dependent. If a table is passed,
        we can get the table dependent values by means of the static method
        `control.datamodel.Datamodel.specialize`.

        All field access should be guarded by the authorisation rules.

        Parameters
        ----------
        table: string
            Name of the table for which we must specialize the field information
        kwargs: dict
            Field configuration arguments.
            It certain parts of the field configuration
            are not present, defaults will be provided.
        &#34;&#34;&#34;
        self.Settings = Settings
        self.Messages = Messages
        Messages.debugAdd(self)
        self.Mongo = Mongo
        self.Datamodel = Datamodel

        self.key = key
        &#34;&#34;&#34;The identifier of this field within the app.
        &#34;&#34;&#34;

        self.table = table
        &#34;&#34;&#34;The table for which this field is specialized.
        &#34;&#34;&#34;

        self.nameSpace = &#34;&#34;
        &#34;&#34;&#34;The first key to access the field data in a record.

        Example `dc` (Dublin Core). So if a record has Dublin Core
        metadata, we expect that metadata to exist under key `dc` in that record.

        If the nameSpace is `&#34;&#34;`, it is assumed that we can dig up the values without
        going into a nameSpace sub-record first.

        **NB.: This attribute is not table dependent.**
        &#34;&#34;&#34;

        self.fieldPath = key
        &#34;&#34;&#34;Compound selector in a nested dict.

        A string of keys, separated by `.`, which will be used to drill down
        into a nested dict. At the end of the path we find the selected value.

        This field selection is applied after the name space selection
        (if `nameSpace` is not the empty string).

        **NB.: This attribute is not table dependent.**
        &#34;&#34;&#34;

        self.tp = &#34;string&#34;
        &#34;&#34;&#34;The value type of the field.

        Value types can be string, integer, but also date-time, and values
        from an other table (keyword).

        The value &#34;keyword&#34; is used if the the field works with values from another
        table (i.e. values from the keyword table). It is assumed that all these values
        are strings.

        If True, the value of such a field must consist of zero or more elements
        of a prescribed list of keywords.

        These lists are associated with certain metadata fields and can be managed
        by admins in a widget on the MyWork page.

        We do not enforce that the value of such a field is a member of the
        associated list at all times. For example, if we import projects and editions
        that have been made with different lists of keywords in force, we accept
        foreign keywords. However, users will not be able to apply foreign keywords
        when they edit fields.

        **NB.: This attribute is not table dependent.**
        &#34;&#34;&#34;

        self.multiple = True
        &#34;&#34;&#34;Whether multiple values are allowed.

        **NB.: This attribute is not table dependent.**
        &#34;&#34;&#34;

        self.readonly = False
        &#34;&#34;&#34;Whether the field can be edited manually by authorized users.

        If this field is True, no user can directly change the value. Instead, the
        system will fill in this value, dependent on the completion of certain actions.

        **NB.: This attribute is not table dependent.**
        &#34;&#34;&#34;

        self.default = None
        &#34;&#34;&#34;A default value to deliver if the field has no value.

        **NB.: This attribute may be table dependent.**
        &#34;&#34;&#34;

        self.mandatory = False
        &#34;&#34;&#34;Whether a value is mandatory.

        **NB.: This attribute may be table dependent.**
        &#34;&#34;&#34;

        self.caption = key
        &#34;&#34;&#34;A caption that may be displayed with the field value.

        The caption may be a literal string with or without a placeholder `{}`.

        If there is no place holder, the caption will precede the content of
        the field.

        If there is a placeholder, the content will replace the place holder
        in the caption.

        **NB.: This attribute may be table dependent.**
        &#34;&#34;&#34;

        for arg, value in Datamodel.specialize(table, kwargs).items():
            if value is not None:
                setattr(self, arg, value)

    def specialize(self, table, record):
        &#34;&#34;&#34;Specializes a record to a table.

        Parameters
        ----------
        table: string
            The table in question
        record: dict | AttrDict
            The record in question

        Returns
        -------
        AttrDict
            The specialized record, a new copy
        &#34;&#34;&#34;
        return Datamodel.specialize(table, record)

    def logical(self, record):
        &#34;&#34;&#34;Give the logical value of the field in a record.

        Parameters
        ----------
        record: AttrDict
            The record in which the field value is stored.

        Returns
        -------
        any:
            Whatever the value is that we find for that field.
            No conversion/casting to other types will be performed.
            If the field is not present, returns None, without warning.
        &#34;&#34;&#34;
        nameSpace = self.nameSpace
        fieldPath = self.fieldPath

        fields = fieldPath.split(&#34;.&#34;)

        dataSource = record.get(nameSpace, {}) if nameSpace else record

        for field in fields[0:-1]:
            dataSource = dataSource.get(field, None)
            if dataSource is None:
                break

        value = None if dataSource is None else dataSource.get(fields[-1], None)

        return value

    def resolved(self, record):
        default = self.default
        logical = self.logical(record)
        return default if logical is None else logical

    def setLogical(self, record, value):
        &#34;&#34;&#34;Set the logical value of the field in a record.

        Parameters
        ----------
        record: AttrDict
            The record in which the field value is to be stored.
            It will be modified in place.
        value: object
            Any value to put into the record

        &#34;&#34;&#34;
        nameSpace = self.nameSpace
        fieldPath = self.fieldPath

        fields = fieldPath.split(&#34;.&#34;)

        dataSource = record.setdefault(nameSpace, AttrDict()) if nameSpace else record

        for field in fields[0:-1]:
            dataSource = dataSource.setdefault(field, AttrDict())

        dataSource[fields[-1]] = value

    def bare(self, record, compact=False, joined=False):
        &#34;&#34;&#34;Give the bare string value of the field in a record.

        If the logical value of the field is None, its default will be filled in.

        Parameters
        ----------
        record: AttrDict
            The record in which the field value is stored.
        compact: boolean, optional False
            Only relevant for datetime types: if True, omit the time, leaving only
            the date plus the timezone (always `Z` = UTC).
        joined: boolean|string, optional False
            Only relevant for fields with multiple values, but not of type text:
            If not False, it should be a string by which the values should be joined.

            For example, if the value is [2, 3], if joined is False the result is:
            `[2, 3]`, but if joined is &#34;;&#34; the result is `2;3`.


        Returns
        -------
        string:
            Whatever the value is that we find for that field, converted to string.
            If the field is not present, returns the empty string, without warning.
        &#34;&#34;&#34;
        tp = self.tp
        multiple = self.multiple

        resolved = self.resolved(record)

        # if not multiple and type(logical) in {list, tuple}:
        #    logical = logical[-1] if len(logical) else &#34;&#34;

        return (
            &#34;&#34;
            if resolved is None
            else (
                (resolved.split(&#34;T&#34;)[0] + &#34;Z&#34; if compact else resolved)
                if tp == &#34;datetime&#34;
                else (
                    str(resolved)
                    if joined is False
                    or tp == &#34;text&#34;
                    or not multiple
                    or type(resolved) in {str, int, bool}
                    else joined.join(str(r) for r in resolved)
                )
            )
        )

    def formatted(
        self,
        record,
        level=None,
        editable=False,
        outerCls=&#34;fieldouter&#34;,
        innerCls=&#34;fieldinner&#34;,
    ):
        &#34;&#34;&#34;Give the formatted value of the field in a record.

        Optionally also puts a caption and/or an edit control.

        The value retrieved is (recursively) wrapped in HTML, steered by an additional
        argument, as in `control.html.HtmlElements.wrapValue`.
        be applied.

        If the type is &#39;text&#39;, multiple values will simply be concatenated
        with newlines in between, and no extra classes will be applied.
        Instead, a markdown formatter is applied to the result.

        For other types:

        If the value is an iterable, each individual value is wrapped in a span
        to which an (other) extra CSS class may be applied.

        Parameters
        ----------
        table: string
            The table from which the record is taken
        record: string | ObjectId | AttrDict
            The record in which the field value is stored.
        level: integer, optional None
            The heading level in which a caption will be placed.
            If None, no caption will be placed.
            If 0, the caption will be placed in a span.
        editable: boolean, optional False
            Whether the field is editable by the current user.
            If so, edit controls are provided.
            But if the field has been declared as readonly in the field specs, no edit
            controls will be provided.
        outerCls: string optional &#34;fieldouter&#34;
            If given, an extra CSS class for the outer element that wraps the total
            value. Only relevant if the type is not &#39;text&#39;
        innerCls: string optional &#34;fieldinner&#34;
            If given, an extra CSS class for the inner elements that wrap parts of the
            value. Only relevant if the type is not &#39;text&#39;

        Returns
        -------
        string:
            Whatever the value is that we find for that field, converted to HTML.
            If the field is not present, returns the empty string, without warning.
        &#34;&#34;&#34;
        Settings = self.Settings
        Mongo = self.Mongo
        Datamodel = self.Datamodel

        H = Settings.H

        table = self.table

        (recordId, record) = Mongo.get(table, record)
        if recordId is None:
            return &#34;&#34;

        tp = self.tp
        caption = self.caption
        key = self.key
        multiple = self.multiple
        readonly = self.readonly

        bare = self.bare(record)
        resolved = self.resolved(record)

        # if table == &#34;site&#34; and key == &#34;abstract&#34;:
        bareRep = bare or H.i(f&#34;no {key}&#34;)

        if tp == &#34;text&#34;:
            readonlyContent = markdown(bareRep, tight=False)
        elif tp == &#34;datetime&#34; or tp == &#34;date&#34;:
            readonlyContent = bare or H.i(&#34;never&#34;)
        else:
            readonlyContent = H.wrapValue(
                resolved,
                outerElem=&#34;span&#34;,
                outerAtts=dict(cls=outerCls),
                innerElem=&#34;span&#34;,
                innerAtts=dict(cls=innerCls),
            )

        if editable and not readonly:
            keyRepUrl = &#34;&#34; if key is None else f&#34;/{key}&#34;
            saveUrl = f&#34;/save/{table}/{recordId}{keyRepUrl}&#34;
            updateButton = H.actionButton(&#34;edit_update&#34;, tip=f&#34; for field {key}&#34;)
            cancelButton = H.actionButton(&#34;edit_cancel&#34;, tip=f&#34; for field {key}&#34;)
            saveButton = H.actionButton(&#34;edit_save&#34;, tip=f&#34; for field {key}&#34;)
            messages = H.div(&#34;&#34;, cls=&#34;editmsgs&#34;)
            orig = (
                bare
                if tp == &#34;text&#34;
                else (
                    &#34;§&#34;.join(resolved or []) if tp == &#34;keyword&#34; else writeYaml(resolved)
                )
            )

            if tp == &#34;keyword&#34;:
                valueSet = (
                    set()
                    if resolved is None
                    else {resolved} if type(resolved) is str else set(resolved)
                )
                keywords = Datamodel.getKeywords(extra={key: valueSet})[key]
                options = (
                    [] if multiple else [(f&#34;Choose a {key} ...&#34;, &#34;&#34;, valueSet == set())]
                ) + [(k, k, k in valueSet) for k in keywords]
                editableContent = H.select(
                    options,
                    multiple=multiple,
                    cls=&#34;editcontent&#34;,
                    saveurl=saveUrl,
                    origValue=orig,
                    tp=tp,
                )
            else:
                editableContent = H.textarea(
                    &#34;&#34;, cls=&#34;editcontent&#34;, saveurl=saveUrl, origValue=orig, tp=key
                )

            content = &#34;&#34;.join(
                [
                    H.span(readonlyContent, cls=&#34;readonlycontent&#34;),
                    H.nbsp,
                    editableContent,
                    updateButton,
                    saveButton,
                    cancelButton,
                    messages,
                ]
            )
        else:
            content = readonlyContent

        if level is not None:
            if &#34;{value}&#34; in caption:
                theCaption = caption.format(kind=table, value=content)
                inCaption = True
            else:
                theCaption = caption
                inCaption = False

            if level == 0:
                elem = &#34;span&#34;
                cls = None
            else:
                elem = &#34;div&#34;
                cls = f&#34;lv lv{level}&#34;

            theCaption = H.elem(elem, theCaption, cls=cls)
        else:
            theCaption = &#34;&#34;
            inCaption = False

        fullContent = (&#34;&#34; if inCaption else theCaption) + (
            theCaption if inCaption else content
        )

        return H.div(
            fullContent,
            cls=&#34;editwidget&#34; if editable and not readonly else &#34;readonlywidget&#34;,
        )</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="control.datamodel.Field.caption"><code class="name">var <span class="ident">caption</span></code></dt>
<dd>
<div class="desc"><p>A caption that may be displayed with the field value.</p>
<p>The caption may be a literal string with or without a placeholder <code>{}</code>.</p>
<p>If there is no place holder, the caption will precede the content of
the field.</p>
<p>If there is a placeholder, the content will replace the place holder
in the caption.</p>
<p><strong>NB.: This attribute may be table dependent.</strong></p></div>
</dd>
<dt id="control.datamodel.Field.default"><code class="name">var <span class="ident">default</span></code></dt>
<dd>
<div class="desc"><p>A default value to deliver if the field has no value.</p>
<p><strong>NB.: This attribute may be table dependent.</strong></p></div>
</dd>
<dt id="control.datamodel.Field.fieldPath"><code class="name">var <span class="ident">fieldPath</span></code></dt>
<dd>
<div class="desc"><p>Compound selector in a nested dict.</p>
<p>A string of keys, separated by <code>.</code>, which will be used to drill down
into a nested dict. At the end of the path we find the selected value.</p>
<p>This field selection is applied after the name space selection
(if <code>nameSpace</code> is not the empty string).</p>
<p><strong>NB.: This attribute is not table dependent.</strong></p></div>
</dd>
<dt id="control.datamodel.Field.key"><code class="name">var <span class="ident">key</span></code></dt>
<dd>
<div class="desc"><p>The identifier of this field within the app.</p></div>
</dd>
<dt id="control.datamodel.Field.mandatory"><code class="name">var <span class="ident">mandatory</span></code></dt>
<dd>
<div class="desc"><p>Whether a value is mandatory.</p>
<p><strong>NB.: This attribute may be table dependent.</strong></p></div>
</dd>
<dt id="control.datamodel.Field.multiple"><code class="name">var <span class="ident">multiple</span></code></dt>
<dd>
<div class="desc"><p>Whether multiple values are allowed.</p>
<p><strong>NB.: This attribute is not table dependent.</strong></p></div>
</dd>
<dt id="control.datamodel.Field.nameSpace"><code class="name">var <span class="ident">nameSpace</span></code></dt>
<dd>
<div class="desc"><p>The first key to access the field data in a record.</p>
<p>Example <code>dc</code> (Dublin Core). So if a record has Dublin Core
metadata, we expect that metadata to exist under key <code>dc</code> in that record.</p>
<p>If the nameSpace is <code>""</code>, it is assumed that we can dig up the values without
going into a nameSpace sub-record first.</p>
<p><strong>NB.: This attribute is not table dependent.</strong></p></div>
</dd>
<dt id="control.datamodel.Field.readonly"><code class="name">var <span class="ident">readonly</span></code></dt>
<dd>
<div class="desc"><p>Whether the field can be edited manually by authorized users.</p>
<p>If this field is True, no user can directly change the value. Instead, the
system will fill in this value, dependent on the completion of certain actions.</p>
<p><strong>NB.: This attribute is not table dependent.</strong></p></div>
</dd>
<dt id="control.datamodel.Field.table"><code class="name">var <span class="ident">table</span></code></dt>
<dd>
<div class="desc"><p>The table for which this field is specialized.</p></div>
</dd>
<dt id="control.datamodel.Field.tp"><code class="name">var <span class="ident">tp</span></code></dt>
<dd>
<div class="desc"><p>The value type of the field.</p>
<p>Value types can be string, integer, but also date-time, and values
from an other table (keyword).</p>
<p>The value "keyword" is used if the the field works with values from another
table (i.e. values from the keyword table). It is assumed that all these values
are strings.</p>
<p>If True, the value of such a field must consist of zero or more elements
of a prescribed list of keywords.</p>
<p>These lists are associated with certain metadata fields and can be managed
by admins in a widget on the MyWork page.</p>
<p>We do not enforce that the value of such a field is a member of the
associated list at all times. For example, if we import projects and editions
that have been made with different lists of keywords in force, we accept
foreign keywords. However, users will not be able to apply foreign keywords
when they edit fields.</p>
<p><strong>NB.: This attribute is not table dependent.</strong></p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="control.datamodel.Field.bare"><code class="name flex">
<span>def <span class="ident">bare</span></span>(<span>self, record, compact=False, joined=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Give the bare string value of the field in a record.</p>
<p>If the logical value of the field is None, its default will be filled in.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>record</code></strong> :&ensp;<code>AttrDict</code></dt>
<dd>The record in which the field value is stored.</dd>
<dt><strong><code>compact</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>Only relevant for datetime types: if True, omit the time, leaving only
the date plus the timezone (always <code>Z</code> = UTC).</dd>
<dt><strong><code>joined</code></strong> :&ensp;<code>boolean|string</code>, optional <code>False</code></dt>
<dd>
<p>Only relevant for fields with multiple values, but not of type text:
If not False, it should be a string by which the values should be joined.</p>
<p>For example, if the value is [2, 3], if joined is False the result is:
<code>[2, 3]</code>, but if joined is ";" the result is <code>2;3</code>.</p>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>string:</code></dt>
<dd>Whatever the value is that we find for that field, converted to string.
If the field is not present, returns the empty string, without warning.</dd>
</dl></div>
</dd>
<dt id="control.datamodel.Field.formatted"><code class="name flex">
<span>def <span class="ident">formatted</span></span>(<span>self, record, level=None, editable=False, outerCls='fieldouter', innerCls='fieldinner')</span>
</code></dt>
<dd>
<div class="desc"><p>Give the formatted value of the field in a record.</p>
<p>Optionally also puts a caption and/or an edit control.</p>
<p>The value retrieved is (recursively) wrapped in HTML, steered by an additional
argument, as in <code><a title="control.html.HtmlElements.wrapValue" href="html.html#control.html.HtmlElements.wrapValue">HtmlElements.wrapValue()</a></code>.
be applied.</p>
<p>If the type is 'text', multiple values will simply be concatenated
with newlines in between, and no extra classes will be applied.
Instead, a markdown formatter is applied to the result.</p>
<p>For other types:</p>
<p>If the value is an iterable, each individual value is wrapped in a span
to which an (other) extra CSS class may be applied.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>table</code></strong> :&ensp;<code>string</code></dt>
<dd>The table from which the record is taken</dd>
<dt><strong><code>record</code></strong> :&ensp;<code>string | ObjectId | AttrDict</code></dt>
<dd>The record in which the field value is stored.</dd>
<dt><strong><code>level</code></strong> :&ensp;<code>integer</code>, optional <code>None</code></dt>
<dd>The heading level in which a caption will be placed.
If None, no caption will be placed.
If 0, the caption will be placed in a span.</dd>
<dt><strong><code>editable</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>Whether the field is editable by the current user.
If so, edit controls are provided.
But if the field has been declared as readonly in the field specs, no edit
controls will be provided.</dd>
<dt><strong><code>outerCls</code></strong> :&ensp;<code>string optional "fieldouter"</code></dt>
<dd>If given, an extra CSS class for the outer element that wraps the total
value. Only relevant if the type is not 'text'</dd>
<dt><strong><code>innerCls</code></strong> :&ensp;<code>string optional "fieldinner"</code></dt>
<dd>If given, an extra CSS class for the inner elements that wrap parts of the
value. Only relevant if the type is not 'text'</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>string:</code></dt>
<dd>Whatever the value is that we find for that field, converted to HTML.
If the field is not present, returns the empty string, without warning.</dd>
</dl></div>
</dd>
<dt id="control.datamodel.Field.logical"><code class="name flex">
<span>def <span class="ident">logical</span></span>(<span>self, record)</span>
</code></dt>
<dd>
<div class="desc"><p>Give the logical value of the field in a record.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>record</code></strong> :&ensp;<code>AttrDict</code></dt>
<dd>The record in which the field value is stored.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>any:</code></dt>
<dd>Whatever the value is that we find for that field.
No conversion/casting to other types will be performed.
If the field is not present, returns None, without warning.</dd>
</dl></div>
</dd>
<dt id="control.datamodel.Field.resolved"><code class="name flex">
<span>def <span class="ident">resolved</span></span>(<span>self, record)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="control.datamodel.Field.setLogical"><code class="name flex">
<span>def <span class="ident">setLogical</span></span>(<span>self, record, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the logical value of the field in a record.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>record</code></strong> :&ensp;<code>AttrDict</code></dt>
<dd>The record in which the field value is to be stored.
It will be modified in place.</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>object</code></dt>
<dd>Any value to put into the record</dd>
</dl></div>
</dd>
<dt id="control.datamodel.Field.specialize"><code class="name flex">
<span>def <span class="ident">specialize</span></span>(<span>self, table, record)</span>
</code></dt>
<dd>
<div class="desc"><p>Specializes a record to a table.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>table</code></strong> :&ensp;<code>string</code></dt>
<dd>The table in question</dd>
<dt><strong><code>record</code></strong> :&ensp;<code>dict | AttrDict</code></dt>
<dd>The record in question</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>AttrDict</code></dt>
<dd>The specialized record, a new copy</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="control.datamodel.Upload"><code class="flex name class">
<span>class <span class="ident">Upload</span></span>
<span>(</span><span>Settings, Messages, Mongo, key, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Handle upload business.</p>
<p>An upload is like a field of type 'file'.
The name of the uploaded file is stored in a record in MongoDb.
The contents of the file is stored on the file system.</p>
<p>A Upload object does not correspond with an individual field in a record.
It represents a <em>column</em>, i.e. a set of fields with the same name in all
records of a table.</p>
<p>First of all there is a method to retrieve the file name of an upload from
a specific record.</p>
<p>Then there are methods to deliver those values, either bare or formatted,
to produce widgets to upload or delete the corresponding files.</p>
<p>How to do this is steered by the specification of the upload by keys and
values that are stored in this object.</p>
<p>All upload access should be guarded by the authorisation rules.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Upload configuration arguments.
The following parts of the upload configuration
should be present: <code>table</code>, <code>accept</code>, while <code>caption</code>, <code>fileName</code>,
<code>show</code> are optional.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/99a827eec565f9f7bf0633f62d3c060d35dd93dc/src/control/datamodel.py#L1078-L1298" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Upload:
    def __init__(self, Settings, Messages, Mongo, key, **kwargs):
        &#34;&#34;&#34;Handle upload business.

        An upload is like a field of type &#39;file&#39;.
        The name of the uploaded file is stored in a record in MongoDb.
        The contents of the file is stored on the file system.

        A Upload object does not correspond with an individual field in a record.
        It represents a *column*, i.e. a set of fields with the same name in all
        records of a table.

        First of all there is a method to retrieve the file name of an upload from
        a specific record.

        Then there are methods to deliver those values, either bare or formatted,
        to produce widgets to upload or delete the corresponding files.

        How to do this is steered by the specification of the upload by keys and
        values that are stored in this object.

        All upload access should be guarded by the authorisation rules.

        Parameters
        ----------
        kwargs: dict
            Upload configuration arguments.
            The following parts of the upload configuration
            should be present: `table`, `accept`, while `caption`, `fileName`,
            `show` are optional.
        &#34;&#34;&#34;
        self.Settings = Settings
        self.Messages = Messages
        Messages.debugAdd(self)
        self.Mongo = Mongo

        self.key = key
        &#34;&#34;&#34;The identifier of this upload within the app.
        &#34;&#34;&#34;

        self.table = kwargs.get(&#34;table&#34;, None)
        &#34;&#34;&#34;Indicates the directory where the actual file will be saved.

        Possibe values:

        * `site`: top level of the working data directory of the site
        * `project`: project directory of the project in question
        * `edition`: edition directory of the project in question
        &#34;&#34;&#34;

        self.accept = kwargs.get(&#34;accept&#34;, None)
        &#34;&#34;&#34;The file types that the field accepts.
        &#34;&#34;&#34;

        self.caption = kwargs.get(&#34;caption&#34;, f&#34;{self.table} ({self.accept})&#34;)
        &#34;&#34;&#34;The text to display on the upload button.
        &#34;&#34;&#34;

        self.multiple = kwargs.get(&#34;multiple&#34;, False)
        &#34;&#34;&#34;Whether multiple files of this type may be uploaded.
        &#34;&#34;&#34;

        self.fileName = kwargs.get(&#34;fileName&#34;, None)
        &#34;&#34;&#34;The name of the file once it is uploaded.

        The file name for the upload can be passed when the file name
        is known in advance.
        In that case, a file that is uploaded in this upload widget,
        will get this as prescribed file name, regardless of the file name in the
        upload request.

        Without a file name, the upload widget will show all existing files
        conforming to the `accept` setting, and will have a control to upload a
        new file.
        &#34;&#34;&#34;

        self.show = kwargs.get(&#34;show&#34;, False)
        &#34;&#34;&#34;Whether to show the contents of the file.

        This is typically the case when the file is an image to be presented
        as a logo.
        &#34;&#34;&#34;

        # let attributes be filled in from the function **kwargs

        for arg, value in kwargs.items():
            if value is not None:
                setattr(self, arg, value)

        # try to fill in defaults for attributes that are still None

        good = True

        for arg in (&#34;table&#34;, &#34;accept&#34;):
            if getattr(self, arg, None) is None:
                Messages.error(logmsg=f&#34;Missing info in Upload spec: {arg}&#34;)
                good = False

        if not good:
            quit()

    def getDir(self, record):
        &#34;&#34;&#34;Give the path to the file in question.

        The path can be used to build the static url and the save url.

        It does not contain the file name.
        If the path is non-empty, a &#34;/&#34; will be appended.

        Parameters
        ----------
        record: string | ObjectId | AttrDict
            The record relevant to the upload
        &#34;&#34;&#34;
        table = self.table
        recordId = record._id

        projectId = (
            recordId
            if table == &#34;project&#34;
            else record.projectId if table == &#34;edition&#34; else None
        )
        editionId = recordId if table == &#34;edition&#34; else None

        path = (
            &#34;&#34;
            if table == &#34;site&#34;
            else (
                f&#34;project/{projectId}&#34;
                if table == &#34;project&#34;
                else (
                    f&#34;project/{projectId}/edition/{editionId}&#34;
                    if table == &#34;edition&#34;
                    else None
                )
            )
        )
        sep = &#34;/&#34; if path else &#34;&#34;
        return f&#34;{path}{sep}&#34;

    def formatted(self, record, mayChange=False, bust=None, wrapped=True):
        &#34;&#34;&#34;Give the formatted value of a file field in a record.

        Optionally also puts an upload control.

        Parameters
        ----------
        record: string | ObjectId | AttrDict
            The record relevant to the upload
        mayChange: boolean, optional False
            Whether the file may be changed.
            If so, an upload widget is supplied, wich contains a a delete button.
        bust: string, optional None
            If not None, the image url of the file whose name is passed in
            `bust` is made unique by adding the current time to it.
            This is a cache buster.
        wrapped: boolean, optional True
            Whether the content should be wrapped in a container element.
            See `control.html.HtmlElements.finput()`.

        Returns
        -------
        string
            The name of the uploaded file(s) and/or an upload control.
        &#34;&#34;&#34;
        Settings = self.Settings
        H = Settings.H
        workingDir = Settings.workingDir

        key = self.key
        fileName = self.fileName
        accept = self.accept
        caption = self.caption
        show = self.show

        recordId = record._id

        fileNameRep = &#34;-&#34; if fileName is None else fileName
        fid = f&#34;{recordId}/{key}/{fileNameRep}&#34;

        path = self.getDir(record)
        sep = &#34;/&#34; if path else &#34;&#34;
        fullDir = f&#34;{workingDir}{sep}{path}&#34;
        saveUrl = f&#34;/upload/{fid}{sep}{path}&#34;
        deleteUrl = f&#34;/deletefile/{fid}{sep}{path}&#34;.rstrip(&#34;/&#34;) + &#34;/&#34;

        if fileName is None:
            content = []
            for fileNm in listFilesAccepted(fullDir, accept, withExt=True):
                buster = (
                    f&#34;?v={pseudoisonow()}&#34;
                    if show and bust is not None and bust == fileNm
                    else &#34;&#34;
                )
                item = [fileNm, f&#34;/data/{path}{fileNm}{buster}&#34; if show else None]
                content.append(item)
        else:
            buster = (
                f&#34;?v={pseudoisonow()}&#34;
                if show and bust is not None and bust == fileName
                else &#34;&#34;
            )
            fullPath = (f&#34;{workingDir}{sep}{path}&#34;).rstrip(&#34;/&#34;) + f&#34;/{fileName}&#34;
            exists = fileExists(fullPath)
            content = (
                fileName,
                exists,
                f&#34;/data/{path}{fileName}{buster}&#34; if show else None,
            )

        return H.finput(
            content,
            accept,
            mayChange,
            saveUrl,
            deleteUrl,
            caption,
            wrapped=wrapped,
            buttonCls=&#34;button small&#34;,
            cls=f&#34;{key.lower()}&#34;,
        )</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="control.datamodel.Upload.accept"><code class="name">var <span class="ident">accept</span></code></dt>
<dd>
<div class="desc"><p>The file types that the field accepts.</p></div>
</dd>
<dt id="control.datamodel.Upload.caption"><code class="name">var <span class="ident">caption</span></code></dt>
<dd>
<div class="desc"><p>The text to display on the upload button.</p></div>
</dd>
<dt id="control.datamodel.Upload.fileName"><code class="name">var <span class="ident">fileName</span></code></dt>
<dd>
<div class="desc"><p>The name of the file once it is uploaded.</p>
<p>The file name for the upload can be passed when the file name
is known in advance.
In that case, a file that is uploaded in this upload widget,
will get this as prescribed file name, regardless of the file name in the
upload request.</p>
<p>Without a file name, the upload widget will show all existing files
conforming to the <code>accept</code> setting, and will have a control to upload a
new file.</p></div>
</dd>
<dt id="control.datamodel.Upload.key"><code class="name">var <span class="ident">key</span></code></dt>
<dd>
<div class="desc"><p>The identifier of this upload within the app.</p></div>
</dd>
<dt id="control.datamodel.Upload.multiple"><code class="name">var <span class="ident">multiple</span></code></dt>
<dd>
<div class="desc"><p>Whether multiple files of this type may be uploaded.</p></div>
</dd>
<dt id="control.datamodel.Upload.show"><code class="name">var <span class="ident">show</span></code></dt>
<dd>
<div class="desc"><p>Whether to show the contents of the file.</p>
<p>This is typically the case when the file is an image to be presented
as a logo.</p></div>
</dd>
<dt id="control.datamodel.Upload.table"><code class="name">var <span class="ident">table</span></code></dt>
<dd>
<div class="desc"><p>Indicates the directory where the actual file will be saved.</p>
<p>Possibe values:</p>
<ul>
<li><code>site</code>: top level of the working data directory of the site</li>
<li><code>project</code>: project directory of the project in question</li>
<li><code>edition</code>: edition directory of the project in question</li>
</ul></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="control.datamodel.Upload.formatted"><code class="name flex">
<span>def <span class="ident">formatted</span></span>(<span>self, record, mayChange=False, bust=None, wrapped=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Give the formatted value of a file field in a record.</p>
<p>Optionally also puts an upload control.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>record</code></strong> :&ensp;<code>string | ObjectId | AttrDict</code></dt>
<dd>The record relevant to the upload</dd>
<dt><strong><code>mayChange</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>Whether the file may be changed.
If so, an upload widget is supplied, wich contains a a delete button.</dd>
<dt><strong><code>bust</code></strong> :&ensp;<code>string</code>, optional <code>None</code></dt>
<dd>If not None, the image url of the file whose name is passed in
<code>bust</code> is made unique by adding the current time to it.
This is a cache buster.</dd>
<dt><strong><code>wrapped</code></strong> :&ensp;<code>boolean</code>, optional <code>True</code></dt>
<dd>Whether the content should be wrapped in a container element.
See <code><a title="control.html.HtmlElements.finput" href="html.html#control.html.HtmlElements.finput">HtmlElements.finput()</a></code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>string</code></dt>
<dd>The name of the uploaded file(s) and/or an upload control.</dd>
</dl></div>
</dd>
<dt id="control.datamodel.Upload.getDir"><code class="name flex">
<span>def <span class="ident">getDir</span></span>(<span>self, record)</span>
</code></dt>
<dd>
<div class="desc"><p>Give the path to the file in question.</p>
<p>The path can be used to build the static url and the save url.</p>
<p>It does not contain the file name.
If the path is non-empty, a "/" will be appended.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>record</code></strong> :&ensp;<code>string | ObjectId | AttrDict</code></dt>
<dd>The record relevant to the upload</dd>
</dl></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<p><a href="https://github.com/CLARIAH/pure3dx" title="GitHub repo">GitHub</a></p>
<p><a href="https://github.com/CLARIAH/pure3dx/blob/main/stats.md" title="GitHub repo">code stats</a></p>
<form>
<input id="lunr-search" name="q" placeholder="🔎 Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="control" href="index.html">control</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="control.datamodel.Datamodel" href="#control.datamodel.Datamodel">Datamodel</a></code></h4>
<ul class="two-column">
<li><code><a title="control.datamodel.Datamodel.checkMetaFields" href="#control.datamodel.Datamodel.checkMetaFields">checkMetaFields</a></code></li>
<li><code><a title="control.datamodel.Datamodel.context" href="#control.datamodel.Datamodel.context">context</a></code></li>
<li><code><a title="control.datamodel.Datamodel.getDetailRecords" href="#control.datamodel.Datamodel.getDetailRecords">getDetailRecords</a></code></li>
<li><code><a title="control.datamodel.Datamodel.getKeywords" href="#control.datamodel.Datamodel.getKeywords">getKeywords</a></code></li>
<li><code><a title="control.datamodel.Datamodel.getLinkedCrit" href="#control.datamodel.Datamodel.getLinkedCrit">getLinkedCrit</a></code></li>
<li><code><a title="control.datamodel.Datamodel.getListFields" href="#control.datamodel.Datamodel.getListFields">getListFields</a></code></li>
<li><code><a title="control.datamodel.Datamodel.getMarkdownFields" href="#control.datamodel.Datamodel.getMarkdownFields">getMarkdownFields</a></code></li>
<li><code><a title="control.datamodel.Datamodel.getMetaFields" href="#control.datamodel.Datamodel.getMetaFields">getMetaFields</a></code></li>
<li><code><a title="control.datamodel.Datamodel.getTexts" href="#control.datamodel.Datamodel.getTexts">getTexts</a></code></li>
<li><code><a title="control.datamodel.Datamodel.getUploadConfig" href="#control.datamodel.Datamodel.getUploadConfig">getUploadConfig</a></code></li>
<li><code><a title="control.datamodel.Datamodel.getUploadObject" href="#control.datamodel.Datamodel.getUploadObject">getUploadObject</a></code></li>
<li><code><a title="control.datamodel.Datamodel.getUserWork" href="#control.datamodel.Datamodel.getUserWork">getUserWork</a></code></li>
<li><code><a title="control.datamodel.Datamodel.makeField" href="#control.datamodel.Datamodel.makeField">makeField</a></code></li>
<li><code><a title="control.datamodel.Datamodel.makeUpload" href="#control.datamodel.Datamodel.makeUpload">makeUpload</a></code></li>
<li><code><a title="control.datamodel.Datamodel.relevant" href="#control.datamodel.Datamodel.relevant">relevant</a></code></li>
<li><code><a title="control.datamodel.Datamodel.specialize" href="#control.datamodel.Datamodel.specialize">specialize</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="control.datamodel.Field" href="#control.datamodel.Field">Field</a></code></h4>
<ul class="two-column">
<li><code><a title="control.datamodel.Field.bare" href="#control.datamodel.Field.bare">bare</a></code></li>
<li><code><a title="control.datamodel.Field.caption" href="#control.datamodel.Field.caption">caption</a></code></li>
<li><code><a title="control.datamodel.Field.default" href="#control.datamodel.Field.default">default</a></code></li>
<li><code><a title="control.datamodel.Field.fieldPath" href="#control.datamodel.Field.fieldPath">fieldPath</a></code></li>
<li><code><a title="control.datamodel.Field.formatted" href="#control.datamodel.Field.formatted">formatted</a></code></li>
<li><code><a title="control.datamodel.Field.key" href="#control.datamodel.Field.key">key</a></code></li>
<li><code><a title="control.datamodel.Field.logical" href="#control.datamodel.Field.logical">logical</a></code></li>
<li><code><a title="control.datamodel.Field.mandatory" href="#control.datamodel.Field.mandatory">mandatory</a></code></li>
<li><code><a title="control.datamodel.Field.multiple" href="#control.datamodel.Field.multiple">multiple</a></code></li>
<li><code><a title="control.datamodel.Field.nameSpace" href="#control.datamodel.Field.nameSpace">nameSpace</a></code></li>
<li><code><a title="control.datamodel.Field.readonly" href="#control.datamodel.Field.readonly">readonly</a></code></li>
<li><code><a title="control.datamodel.Field.resolved" href="#control.datamodel.Field.resolved">resolved</a></code></li>
<li><code><a title="control.datamodel.Field.setLogical" href="#control.datamodel.Field.setLogical">setLogical</a></code></li>
<li><code><a title="control.datamodel.Field.specialize" href="#control.datamodel.Field.specialize">specialize</a></code></li>
<li><code><a title="control.datamodel.Field.table" href="#control.datamodel.Field.table">table</a></code></li>
<li><code><a title="control.datamodel.Field.tp" href="#control.datamodel.Field.tp">tp</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="control.datamodel.Upload" href="#control.datamodel.Upload">Upload</a></code></h4>
<ul class="two-column">
<li><code><a title="control.datamodel.Upload.accept" href="#control.datamodel.Upload.accept">accept</a></code></li>
<li><code><a title="control.datamodel.Upload.caption" href="#control.datamodel.Upload.caption">caption</a></code></li>
<li><code><a title="control.datamodel.Upload.fileName" href="#control.datamodel.Upload.fileName">fileName</a></code></li>
<li><code><a title="control.datamodel.Upload.formatted" href="#control.datamodel.Upload.formatted">formatted</a></code></li>
<li><code><a title="control.datamodel.Upload.getDir" href="#control.datamodel.Upload.getDir">getDir</a></code></li>
<li><code><a title="control.datamodel.Upload.key" href="#control.datamodel.Upload.key">key</a></code></li>
<li><code><a title="control.datamodel.Upload.multiple" href="#control.datamodel.Upload.multiple">multiple</a></code></li>
<li><code><a title="control.datamodel.Upload.show" href="#control.datamodel.Upload.show">show</a></code></li>
<li><code><a title="control.datamodel.Upload.table" href="#control.datamodel.Upload.table">table</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<a href="https://pure.knaw.nl/portal/en/persons/dirk-roorda">Dirk Roorda</a>
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.11.1</a>.</p>
</footer>
</body>
</html>
