<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>control.auth API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>control.auth</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/23c61c878149a0c80bf432c2e0e320f5e806d778/src/control/auth.py#L1-L398" class="git-link">Browse git</a>
</summary>
<pre><code class="python">from itertools import chain
from control.generic import AttrDict
from control.users import Users


class Auth(Users):
    def __init__(self, Settings, Messages, Mongo, Content):
        &#34;&#34;&#34;All about authorised data access.

        This class knows users because it is based
        on the Users class.

        This class also knows content,
        and decides whether the current user is authorised to perform certain
        actions on content in question.

        It is instantiated by a singleton object.

        Parameters
        ----------
        Settings: AttrDict
            App-wide configuration data obtained from
            `control.config.Config.Settings`.
        Messages: object
            Singleton instance of `control.messages.Messages`.
        Mongo: object
            Singleton instance of `control.mongo.Mongo`.
        Content: object
            Singleton instance of `control.content.Content`.
        &#34;&#34;&#34;
        super().__init__(Settings, Messages, Mongo)
        self.Content = Content

    def authorise(self, table, record, action=None, insertTable=None):
        &#34;&#34;&#34;Check whether an action is allowed on data.

        The &#34;create&#34; action is a bit special, because we do not have any record
        to start with. In this case `table` and `record` should point to the
        master record, and `insertTable` should have the table that will
        contain the new record.

        If the action is anything else, `table` and `record` refer to
        the relevant record, and `insertTable` should not be passed.

        How do the authorisation rules work?

        First we consider the site-wise role of the user: guest, user, admin, or root.
        If the action is allowed on that basis, we return True.

        If not, we look whether the user has an additional role with regard
        to the record in question, or with any of its master records.

        If so, we apply the rules for those cases and see whether the action is
        permitted.

        Then we have the possibility that a record is in a certain state, e.g.
        projects may be visible or invisible, editions may be published or
        unpublished.

        For each of these states we have separate rules, so we inspect the
        states of the records and master records in order to select the
        appropriate rules.

        Parameters
        ----------
        table: string
            the relevant table; for `create` actions it is the master table
            of the table in which a record will be inserted.
        record: ObjectId | AttrDict
            The id of the record that is being accessed or the record itself;
            for `create` actions it is the master record to which a new record
            will be created as a detail.
        action: string, optional None
            The action for which permission is asked.
        insertTable: string
            Only relevant for &#34;create&#34; actions.
            The detail table in which the new record will be inserted.

        Returns
        -------
        boolean | dict
            If an action is passed: boolean whether action is allowed.

            If no action is passed: dict keyed by the allowed actions, the values
            are true.
            Actions with a falsy permission (False or the empty set) are not included
            in the dict.
            So, to test whether any action is allowed, it suffices to test whether
            `action in result`
        &#34;&#34;&#34;
        Messages = self.Messages
        Content = self.Content
        isCreate = action == &#34;create&#34;

        if (
            insertTable is None
            and isCreate
            or insertTable is not None
            and action is not None
            and not isCreate
        ):
            Messages.error(
                msg=&#34;Programming error in calculating authorization&#34;,
                logmsg=(
                    f&#34;Wrong call to Auth.authorise with action {action} &#34;
                    f&#34;and insertTable {insertTable}&#34;
                ),
            )
            # this is a programming error
            return False if action is None else set()

        Settings = self.Settings
        Mongo = self.Mongo

        detailMaster = Content.detailMaster

        User = self.myDetails()
        user = User.user
        role = User.role

        # we select the authorisation rules for this table

        auth = Settings.auth
        authRules = auth.authRules
        tableRules = authRules.get(insertTable if isCreate else table, AttrDict())

        # we need the state of the record that we want to apply the action to
        # If the action is create, we have no record.
        # We then use an initial state, given in the data model.
        # For all other actions, we read the state from the record,
        # its field is given in the data model.
        # If there is no state info, we assume there is no state.

        stateInfo = tableRules.state

        state = None

        (recordId, record) = Mongo.get(table, record)
        if recordId is None:
            return {} if action is None else False

        if stateInfo is not None:
            initState = stateInfo.init
            if isCreate:
                state = initState
            else:
                stateField = stateInfo.field
                state = record.get(stateField, None)
                if state is None:
                    state = initState

        # we select the rules for the given state, if any

        rules = {
            act: actInfo[state] if stateInfo else actInfo
            for (act, actInfo) in tableRules.items()
            if act != &#34;state&#34;
        }

        # for each possible action, the rules specify the roles that may perform
        # that action.

        # We collect the set of all possible roles and organize them by table

        tableFromRole = auth.tableFromRole
        userCoupled = set(auth.userCoupled)

        # for each of the roles we have to determine whether the role is
        # * site wide (table = site)
        # * associated with a master table
        # * associated with a detail table

        # First we get the tables associated with each role

        allAllowedRoles = {
            role: tableFromRole[role]
            for role in set(
                chain.from_iterable(v.keys() for v in rules.values() if v is not None)
            )
        }

        # Then we determine which of these tables are master, detail, or none of
        # those, with respect to the table we are acting upon.
        # Note that in case of &#34;create&#34; the table we act upon is a detail of
        # what we passed as &#34;table&#34;

        allRelatedTables = (
            {
                relatedTable: &#34;self&#34;
                if relatedTable == insertTable
                else &#34;detail&#34;
                if detailMaster[relatedTable] == insertTable
                else &#34;master&#34;
                if detailMaster[insertTable] == relatedTable
                else &#34;&#34;
                for relatedTable in allAllowedRoles.values()
            }
            if isCreate
            else {
                relatedTable: &#34;self&#34;
                if relatedTable == table
                else &#34;detail&#34;
                if detailMaster[relatedTable] == table
                else &#34;master&#34;
                if detailMaster[table] == relatedTable
                else &#34;&#34;
                for relatedTable in allAllowedRoles.values()
            }
        )

        # for each of the relatedTables we compute whether it leads to extra roles
        # for the current user.
        # We look for related records in those tables to which the user is related.

        userRoles = {role}

        for (relatedTable, kind) in allRelatedTables.items():
            if kind == &#34;&#34;:
                continue

            if relatedTable not in userCoupled:
                continue

            relatedIdField = f&#34;{relatedTable}Id&#34;
            relatedCrossTable = f&#34;{relatedTable}User&#34;

            if kind == &#34;self&#34;:
                if isCreate:
                    continue

                crit = {relatedIdField: recordId}
                crossRecord = Mongo.getRecord(
                    relatedCrossTable, user=user, warn=False, **crit
                )
                extraRole = crossRecord.role

                if extraRole is not None:
                    userRoles.add(extraRole)

            elif kind == &#34;master&#34;:
                # if the action is create the given record is the master
                # else we find the masterId in the given record

                if isCreate:
                    masterId = recordId
                else:
                    masterId = record[relatedIdField]

                # we do not need the master record itself,
                # instead we are interested in the coupling record
                # of the relatedTable with the user table
                # because we find a user role there

                crit = {relatedIdField: masterId}
                crossRecord = Mongo.getRecord(
                    relatedCrossTable, user=user, warn=False, **crit
                )
                extraRole = crossRecord.role

                if extraRole is not None:
                    userRoles.add(extraRole)

            elif kind == &#34;detail&#34;:
                # only relevant if recordId is given, because
                # if we want to create a record, none of its details are yet there.

                if isCreate:
                    continue

                # look up all detail records in the detail table

                idField = f&#34;{table}Id&#34;
                crit = {idField: recordId}
                detailRecords = Mongo.getList(relatedTable, **crit)
                detailIds = [detailRecord._id for detailRecord in detailRecords]

                # we need the cross records between these detail records and
                # the user table, and we read the extra roles from those
                # records

                crit = {relatedIdField: {&#34;$in&#34;: detailIds}}
                crossRecords = Mongo.getList(relatedCrossTable, user=user, **crit)

                for crossRecord in crossRecords:
                    extraRole = crossRecord.role
                    if extraRole is not None:
                        userRoles.add(extraRole)

        # Now we have
        # 1. userRoles:
        #    the set of roles that this user has mbt to the given record
        #    and all of its relevant master and detail records
        # 2. rules
        #    a dictionary mapping each possible action to the
        #    roles a user needs to have to perform that action
        #    The roles itself are given as a dict, keyed by the role
        #    and valued by a boolean or a set, depending on the action.

        # We compute the allowed actions resulting in a dict keyed by the action
        # and valued by a boolean.

        allowedActions = {}

        for (act, requiredRoles) in rules.items():
            if requiredRoles is None:
                continue

            permission = False

            for presentRole in userRoles:
                if requiredRoles.get(presentRole, False):
                    permission = True
                    break

            if permission:
                allowedActions[act] = True

        # Finally we return the result.
        #
        # If no action is given, we return the allowedActions straightaway.
        # Otherwise we lookup the given action in allowedActions, get the
        # associated value (or provide a falsy default), and return that.

        return allowedActions if action is None else allowedActions.get(action, False)

    def mayBackup(self, project=None):
        &#34;&#34;&#34;Whether the current user is allowed to make backups.

        *   Backups are not allowed in production mode, bacause the system and not the
            users are responsible for backups.
        *   Site-wide backups are only allowed for power users.
        *   Project backups are only allowed for project organisers and (power users).

        Parameters
        ----------
        project: AttrDict | ObjectId | string, optional None
            If None, we deal with site-wide backup.
            Otherwise we get the backups of this project.

        Returns
        -------
        boolean
            whether the relevant backup/restore actions are allowed.
        &#34;&#34;&#34;
        Settings = self.Settings
        runProd = Settings.runProd

        if runProd:
            return False

        User = self.myDetails()

        if User.role in {&#34;admin&#34;, &#34;root&#34;}:
            return True

        if project is None:
            return False

        Mongo = self.Mongo
        (projectId, project) = Mongo.get(&#34;project&#34;, project)
        if projectId is None:
            return False

        user = User.user
        projectUser = Mongo.getRecord(
            &#34;projectUser&#34;, user=user, projectId=projectId, warn=False
        )
        return projectUser.role == &#34;organiser&#34;

    def makeSafe(self, table, record, action):
        &#34;&#34;&#34;Changes an update action into a read action if needed.

        This function &#39;demotes&#39; an &#34;update: to a &#34;read&#34; if the
        &#34;update&#34; is not allowed.

        If &#34;read&#34; itself is not allowed, None is returned.

        If any other action tahn &#34;update&#34; or &#34;read&#34; is passed, None is returned.

        Parameters
        ----------
        table: string
            The table in which the record exists.
        record: ObjectId | AttrDict
            The id of the record or the record itself.
        action: string
            An intended action.

        Returns
        -------
        string | void
            The resulting safe action.
        &#34;&#34;&#34;
        if action not in {&#34;update&#34;, &#34;read&#34;}:
            return None

        actions = self.authorise(table, record)
        return action if action in actions else &#34;read&#34; if &#34;read&#34; in actions else None</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="control.auth.Auth"><code class="flex name class">
<span>class <span class="ident">Auth</span></span>
<span>(</span><span>Settings, Messages, Mongo, Content)</span>
</code></dt>
<dd>
<div class="desc"><p>All about authorised data access.</p>
<p>This class knows users because it is based
on the Users class.</p>
<p>This class also knows content,
and decides whether the current user is authorised to perform certain
actions on content in question.</p>
<p>It is instantiated by a singleton object.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>Settings</code></strong> :&ensp;<code>AttrDict</code></dt>
<dd>App-wide configuration data obtained from
<code><a title="control.config.Config.Settings" href="config.html#control.config.Config.Settings">Config.Settings</a></code>.</dd>
<dt><strong><code>Messages</code></strong> :&ensp;<code>object</code></dt>
<dd>Singleton instance of <code><a title="control.messages.Messages" href="messages.html#control.messages.Messages">Messages</a></code>.</dd>
<dt><strong><code>Mongo</code></strong> :&ensp;<code>object</code></dt>
<dd>Singleton instance of <code><a title="control.mongo.Mongo" href="mongo.html#control.mongo.Mongo">Mongo</a></code>.</dd>
<dt><strong><code>Content</code></strong> :&ensp;<code>object</code></dt>
<dd>Singleton instance of <code><a title="control.content.Content" href="content.html#control.content.Content">Content</a></code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/23c61c878149a0c80bf432c2e0e320f5e806d778/src/control/auth.py#L6-L398" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Auth(Users):
    def __init__(self, Settings, Messages, Mongo, Content):
        &#34;&#34;&#34;All about authorised data access.

        This class knows users because it is based
        on the Users class.

        This class also knows content,
        and decides whether the current user is authorised to perform certain
        actions on content in question.

        It is instantiated by a singleton object.

        Parameters
        ----------
        Settings: AttrDict
            App-wide configuration data obtained from
            `control.config.Config.Settings`.
        Messages: object
            Singleton instance of `control.messages.Messages`.
        Mongo: object
            Singleton instance of `control.mongo.Mongo`.
        Content: object
            Singleton instance of `control.content.Content`.
        &#34;&#34;&#34;
        super().__init__(Settings, Messages, Mongo)
        self.Content = Content

    def authorise(self, table, record, action=None, insertTable=None):
        &#34;&#34;&#34;Check whether an action is allowed on data.

        The &#34;create&#34; action is a bit special, because we do not have any record
        to start with. In this case `table` and `record` should point to the
        master record, and `insertTable` should have the table that will
        contain the new record.

        If the action is anything else, `table` and `record` refer to
        the relevant record, and `insertTable` should not be passed.

        How do the authorisation rules work?

        First we consider the site-wise role of the user: guest, user, admin, or root.
        If the action is allowed on that basis, we return True.

        If not, we look whether the user has an additional role with regard
        to the record in question, or with any of its master records.

        If so, we apply the rules for those cases and see whether the action is
        permitted.

        Then we have the possibility that a record is in a certain state, e.g.
        projects may be visible or invisible, editions may be published or
        unpublished.

        For each of these states we have separate rules, so we inspect the
        states of the records and master records in order to select the
        appropriate rules.

        Parameters
        ----------
        table: string
            the relevant table; for `create` actions it is the master table
            of the table in which a record will be inserted.
        record: ObjectId | AttrDict
            The id of the record that is being accessed or the record itself;
            for `create` actions it is the master record to which a new record
            will be created as a detail.
        action: string, optional None
            The action for which permission is asked.
        insertTable: string
            Only relevant for &#34;create&#34; actions.
            The detail table in which the new record will be inserted.

        Returns
        -------
        boolean | dict
            If an action is passed: boolean whether action is allowed.

            If no action is passed: dict keyed by the allowed actions, the values
            are true.
            Actions with a falsy permission (False or the empty set) are not included
            in the dict.
            So, to test whether any action is allowed, it suffices to test whether
            `action in result`
        &#34;&#34;&#34;
        Messages = self.Messages
        Content = self.Content
        isCreate = action == &#34;create&#34;

        if (
            insertTable is None
            and isCreate
            or insertTable is not None
            and action is not None
            and not isCreate
        ):
            Messages.error(
                msg=&#34;Programming error in calculating authorization&#34;,
                logmsg=(
                    f&#34;Wrong call to Auth.authorise with action {action} &#34;
                    f&#34;and insertTable {insertTable}&#34;
                ),
            )
            # this is a programming error
            return False if action is None else set()

        Settings = self.Settings
        Mongo = self.Mongo

        detailMaster = Content.detailMaster

        User = self.myDetails()
        user = User.user
        role = User.role

        # we select the authorisation rules for this table

        auth = Settings.auth
        authRules = auth.authRules
        tableRules = authRules.get(insertTable if isCreate else table, AttrDict())

        # we need the state of the record that we want to apply the action to
        # If the action is create, we have no record.
        # We then use an initial state, given in the data model.
        # For all other actions, we read the state from the record,
        # its field is given in the data model.
        # If there is no state info, we assume there is no state.

        stateInfo = tableRules.state

        state = None

        (recordId, record) = Mongo.get(table, record)
        if recordId is None:
            return {} if action is None else False

        if stateInfo is not None:
            initState = stateInfo.init
            if isCreate:
                state = initState
            else:
                stateField = stateInfo.field
                state = record.get(stateField, None)
                if state is None:
                    state = initState

        # we select the rules for the given state, if any

        rules = {
            act: actInfo[state] if stateInfo else actInfo
            for (act, actInfo) in tableRules.items()
            if act != &#34;state&#34;
        }

        # for each possible action, the rules specify the roles that may perform
        # that action.

        # We collect the set of all possible roles and organize them by table

        tableFromRole = auth.tableFromRole
        userCoupled = set(auth.userCoupled)

        # for each of the roles we have to determine whether the role is
        # * site wide (table = site)
        # * associated with a master table
        # * associated with a detail table

        # First we get the tables associated with each role

        allAllowedRoles = {
            role: tableFromRole[role]
            for role in set(
                chain.from_iterable(v.keys() for v in rules.values() if v is not None)
            )
        }

        # Then we determine which of these tables are master, detail, or none of
        # those, with respect to the table we are acting upon.
        # Note that in case of &#34;create&#34; the table we act upon is a detail of
        # what we passed as &#34;table&#34;

        allRelatedTables = (
            {
                relatedTable: &#34;self&#34;
                if relatedTable == insertTable
                else &#34;detail&#34;
                if detailMaster[relatedTable] == insertTable
                else &#34;master&#34;
                if detailMaster[insertTable] == relatedTable
                else &#34;&#34;
                for relatedTable in allAllowedRoles.values()
            }
            if isCreate
            else {
                relatedTable: &#34;self&#34;
                if relatedTable == table
                else &#34;detail&#34;
                if detailMaster[relatedTable] == table
                else &#34;master&#34;
                if detailMaster[table] == relatedTable
                else &#34;&#34;
                for relatedTable in allAllowedRoles.values()
            }
        )

        # for each of the relatedTables we compute whether it leads to extra roles
        # for the current user.
        # We look for related records in those tables to which the user is related.

        userRoles = {role}

        for (relatedTable, kind) in allRelatedTables.items():
            if kind == &#34;&#34;:
                continue

            if relatedTable not in userCoupled:
                continue

            relatedIdField = f&#34;{relatedTable}Id&#34;
            relatedCrossTable = f&#34;{relatedTable}User&#34;

            if kind == &#34;self&#34;:
                if isCreate:
                    continue

                crit = {relatedIdField: recordId}
                crossRecord = Mongo.getRecord(
                    relatedCrossTable, user=user, warn=False, **crit
                )
                extraRole = crossRecord.role

                if extraRole is not None:
                    userRoles.add(extraRole)

            elif kind == &#34;master&#34;:
                # if the action is create the given record is the master
                # else we find the masterId in the given record

                if isCreate:
                    masterId = recordId
                else:
                    masterId = record[relatedIdField]

                # we do not need the master record itself,
                # instead we are interested in the coupling record
                # of the relatedTable with the user table
                # because we find a user role there

                crit = {relatedIdField: masterId}
                crossRecord = Mongo.getRecord(
                    relatedCrossTable, user=user, warn=False, **crit
                )
                extraRole = crossRecord.role

                if extraRole is not None:
                    userRoles.add(extraRole)

            elif kind == &#34;detail&#34;:
                # only relevant if recordId is given, because
                # if we want to create a record, none of its details are yet there.

                if isCreate:
                    continue

                # look up all detail records in the detail table

                idField = f&#34;{table}Id&#34;
                crit = {idField: recordId}
                detailRecords = Mongo.getList(relatedTable, **crit)
                detailIds = [detailRecord._id for detailRecord in detailRecords]

                # we need the cross records between these detail records and
                # the user table, and we read the extra roles from those
                # records

                crit = {relatedIdField: {&#34;$in&#34;: detailIds}}
                crossRecords = Mongo.getList(relatedCrossTable, user=user, **crit)

                for crossRecord in crossRecords:
                    extraRole = crossRecord.role
                    if extraRole is not None:
                        userRoles.add(extraRole)

        # Now we have
        # 1. userRoles:
        #    the set of roles that this user has mbt to the given record
        #    and all of its relevant master and detail records
        # 2. rules
        #    a dictionary mapping each possible action to the
        #    roles a user needs to have to perform that action
        #    The roles itself are given as a dict, keyed by the role
        #    and valued by a boolean or a set, depending on the action.

        # We compute the allowed actions resulting in a dict keyed by the action
        # and valued by a boolean.

        allowedActions = {}

        for (act, requiredRoles) in rules.items():
            if requiredRoles is None:
                continue

            permission = False

            for presentRole in userRoles:
                if requiredRoles.get(presentRole, False):
                    permission = True
                    break

            if permission:
                allowedActions[act] = True

        # Finally we return the result.
        #
        # If no action is given, we return the allowedActions straightaway.
        # Otherwise we lookup the given action in allowedActions, get the
        # associated value (or provide a falsy default), and return that.

        return allowedActions if action is None else allowedActions.get(action, False)

    def mayBackup(self, project=None):
        &#34;&#34;&#34;Whether the current user is allowed to make backups.

        *   Backups are not allowed in production mode, bacause the system and not the
            users are responsible for backups.
        *   Site-wide backups are only allowed for power users.
        *   Project backups are only allowed for project organisers and (power users).

        Parameters
        ----------
        project: AttrDict | ObjectId | string, optional None
            If None, we deal with site-wide backup.
            Otherwise we get the backups of this project.

        Returns
        -------
        boolean
            whether the relevant backup/restore actions are allowed.
        &#34;&#34;&#34;
        Settings = self.Settings
        runProd = Settings.runProd

        if runProd:
            return False

        User = self.myDetails()

        if User.role in {&#34;admin&#34;, &#34;root&#34;}:
            return True

        if project is None:
            return False

        Mongo = self.Mongo
        (projectId, project) = Mongo.get(&#34;project&#34;, project)
        if projectId is None:
            return False

        user = User.user
        projectUser = Mongo.getRecord(
            &#34;projectUser&#34;, user=user, projectId=projectId, warn=False
        )
        return projectUser.role == &#34;organiser&#34;

    def makeSafe(self, table, record, action):
        &#34;&#34;&#34;Changes an update action into a read action if needed.

        This function &#39;demotes&#39; an &#34;update: to a &#34;read&#34; if the
        &#34;update&#34; is not allowed.

        If &#34;read&#34; itself is not allowed, None is returned.

        If any other action tahn &#34;update&#34; or &#34;read&#34; is passed, None is returned.

        Parameters
        ----------
        table: string
            The table in which the record exists.
        record: ObjectId | AttrDict
            The id of the record or the record itself.
        action: string
            An intended action.

        Returns
        -------
        string | void
            The resulting safe action.
        &#34;&#34;&#34;
        if action not in {&#34;update&#34;, &#34;read&#34;}:
            return None

        actions = self.authorise(table, record)
        return action if action in actions else &#34;read&#34; if &#34;read&#34; in actions else None</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="control.users.Users" href="users.html#control.users.Users">Users</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="control.auth.Auth.authorise"><code class="name flex">
<span>def <span class="ident">authorise</span></span>(<span>self, table, record, action=None, insertTable=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Check whether an action is allowed on data.</p>
<p>The "create" action is a bit special, because we do not have any record
to start with. In this case <code>table</code> and <code>record</code> should point to the
master record, and <code>insertTable</code> should have the table that will
contain the new record.</p>
<p>If the action is anything else, <code>table</code> and <code>record</code> refer to
the relevant record, and <code>insertTable</code> should not be passed.</p>
<p>How do the authorisation rules work?</p>
<p>First we consider the site-wise role of the user: guest, user, admin, or root.
If the action is allowed on that basis, we return True.</p>
<p>If not, we look whether the user has an additional role with regard
to the record in question, or with any of its master records.</p>
<p>If so, we apply the rules for those cases and see whether the action is
permitted.</p>
<p>Then we have the possibility that a record is in a certain state, e.g.
projects may be visible or invisible, editions may be published or
unpublished.</p>
<p>For each of these states we have separate rules, so we inspect the
states of the records and master records in order to select the
appropriate rules.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>table</code></strong> :&ensp;<code>string</code></dt>
<dd>the relevant table; for <code>create</code> actions it is the master table
of the table in which a record will be inserted.</dd>
<dt><strong><code>record</code></strong> :&ensp;<code>ObjectId | AttrDict</code></dt>
<dd>The id of the record that is being accessed or the record itself;
for <code>create</code> actions it is the master record to which a new record
will be created as a detail.</dd>
<dt><strong><code>action</code></strong> :&ensp;<code>string</code>, optional <code>None</code></dt>
<dd>The action for which permission is asked.</dd>
<dt><strong><code>insertTable</code></strong> :&ensp;<code>string</code></dt>
<dd>Only relevant for "create" actions.
The detail table in which the new record will be inserted.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>boolean | dict</code></dt>
<dd>
<p>If an action is passed: boolean whether action is allowed.</p>
<p>If no action is passed: dict keyed by the allowed actions, the values
are true.
Actions with a falsy permission (False or the empty set) are not included
in the dict.
So, to test whether any action is allowed, it suffices to test whether
<code>action in result</code></p>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/23c61c878149a0c80bf432c2e0e320f5e806d778/src/control/auth.py#L34-L324" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def authorise(self, table, record, action=None, insertTable=None):
    &#34;&#34;&#34;Check whether an action is allowed on data.

    The &#34;create&#34; action is a bit special, because we do not have any record
    to start with. In this case `table` and `record` should point to the
    master record, and `insertTable` should have the table that will
    contain the new record.

    If the action is anything else, `table` and `record` refer to
    the relevant record, and `insertTable` should not be passed.

    How do the authorisation rules work?

    First we consider the site-wise role of the user: guest, user, admin, or root.
    If the action is allowed on that basis, we return True.

    If not, we look whether the user has an additional role with regard
    to the record in question, or with any of its master records.

    If so, we apply the rules for those cases and see whether the action is
    permitted.

    Then we have the possibility that a record is in a certain state, e.g.
    projects may be visible or invisible, editions may be published or
    unpublished.

    For each of these states we have separate rules, so we inspect the
    states of the records and master records in order to select the
    appropriate rules.

    Parameters
    ----------
    table: string
        the relevant table; for `create` actions it is the master table
        of the table in which a record will be inserted.
    record: ObjectId | AttrDict
        The id of the record that is being accessed or the record itself;
        for `create` actions it is the master record to which a new record
        will be created as a detail.
    action: string, optional None
        The action for which permission is asked.
    insertTable: string
        Only relevant for &#34;create&#34; actions.
        The detail table in which the new record will be inserted.

    Returns
    -------
    boolean | dict
        If an action is passed: boolean whether action is allowed.

        If no action is passed: dict keyed by the allowed actions, the values
        are true.
        Actions with a falsy permission (False or the empty set) are not included
        in the dict.
        So, to test whether any action is allowed, it suffices to test whether
        `action in result`
    &#34;&#34;&#34;
    Messages = self.Messages
    Content = self.Content
    isCreate = action == &#34;create&#34;

    if (
        insertTable is None
        and isCreate
        or insertTable is not None
        and action is not None
        and not isCreate
    ):
        Messages.error(
            msg=&#34;Programming error in calculating authorization&#34;,
            logmsg=(
                f&#34;Wrong call to Auth.authorise with action {action} &#34;
                f&#34;and insertTable {insertTable}&#34;
            ),
        )
        # this is a programming error
        return False if action is None else set()

    Settings = self.Settings
    Mongo = self.Mongo

    detailMaster = Content.detailMaster

    User = self.myDetails()
    user = User.user
    role = User.role

    # we select the authorisation rules for this table

    auth = Settings.auth
    authRules = auth.authRules
    tableRules = authRules.get(insertTable if isCreate else table, AttrDict())

    # we need the state of the record that we want to apply the action to
    # If the action is create, we have no record.
    # We then use an initial state, given in the data model.
    # For all other actions, we read the state from the record,
    # its field is given in the data model.
    # If there is no state info, we assume there is no state.

    stateInfo = tableRules.state

    state = None

    (recordId, record) = Mongo.get(table, record)
    if recordId is None:
        return {} if action is None else False

    if stateInfo is not None:
        initState = stateInfo.init
        if isCreate:
            state = initState
        else:
            stateField = stateInfo.field
            state = record.get(stateField, None)
            if state is None:
                state = initState

    # we select the rules for the given state, if any

    rules = {
        act: actInfo[state] if stateInfo else actInfo
        for (act, actInfo) in tableRules.items()
        if act != &#34;state&#34;
    }

    # for each possible action, the rules specify the roles that may perform
    # that action.

    # We collect the set of all possible roles and organize them by table

    tableFromRole = auth.tableFromRole
    userCoupled = set(auth.userCoupled)

    # for each of the roles we have to determine whether the role is
    # * site wide (table = site)
    # * associated with a master table
    # * associated with a detail table

    # First we get the tables associated with each role

    allAllowedRoles = {
        role: tableFromRole[role]
        for role in set(
            chain.from_iterable(v.keys() for v in rules.values() if v is not None)
        )
    }

    # Then we determine which of these tables are master, detail, or none of
    # those, with respect to the table we are acting upon.
    # Note that in case of &#34;create&#34; the table we act upon is a detail of
    # what we passed as &#34;table&#34;

    allRelatedTables = (
        {
            relatedTable: &#34;self&#34;
            if relatedTable == insertTable
            else &#34;detail&#34;
            if detailMaster[relatedTable] == insertTable
            else &#34;master&#34;
            if detailMaster[insertTable] == relatedTable
            else &#34;&#34;
            for relatedTable in allAllowedRoles.values()
        }
        if isCreate
        else {
            relatedTable: &#34;self&#34;
            if relatedTable == table
            else &#34;detail&#34;
            if detailMaster[relatedTable] == table
            else &#34;master&#34;
            if detailMaster[table] == relatedTable
            else &#34;&#34;
            for relatedTable in allAllowedRoles.values()
        }
    )

    # for each of the relatedTables we compute whether it leads to extra roles
    # for the current user.
    # We look for related records in those tables to which the user is related.

    userRoles = {role}

    for (relatedTable, kind) in allRelatedTables.items():
        if kind == &#34;&#34;:
            continue

        if relatedTable not in userCoupled:
            continue

        relatedIdField = f&#34;{relatedTable}Id&#34;
        relatedCrossTable = f&#34;{relatedTable}User&#34;

        if kind == &#34;self&#34;:
            if isCreate:
                continue

            crit = {relatedIdField: recordId}
            crossRecord = Mongo.getRecord(
                relatedCrossTable, user=user, warn=False, **crit
            )
            extraRole = crossRecord.role

            if extraRole is not None:
                userRoles.add(extraRole)

        elif kind == &#34;master&#34;:
            # if the action is create the given record is the master
            # else we find the masterId in the given record

            if isCreate:
                masterId = recordId
            else:
                masterId = record[relatedIdField]

            # we do not need the master record itself,
            # instead we are interested in the coupling record
            # of the relatedTable with the user table
            # because we find a user role there

            crit = {relatedIdField: masterId}
            crossRecord = Mongo.getRecord(
                relatedCrossTable, user=user, warn=False, **crit
            )
            extraRole = crossRecord.role

            if extraRole is not None:
                userRoles.add(extraRole)

        elif kind == &#34;detail&#34;:
            # only relevant if recordId is given, because
            # if we want to create a record, none of its details are yet there.

            if isCreate:
                continue

            # look up all detail records in the detail table

            idField = f&#34;{table}Id&#34;
            crit = {idField: recordId}
            detailRecords = Mongo.getList(relatedTable, **crit)
            detailIds = [detailRecord._id for detailRecord in detailRecords]

            # we need the cross records between these detail records and
            # the user table, and we read the extra roles from those
            # records

            crit = {relatedIdField: {&#34;$in&#34;: detailIds}}
            crossRecords = Mongo.getList(relatedCrossTable, user=user, **crit)

            for crossRecord in crossRecords:
                extraRole = crossRecord.role
                if extraRole is not None:
                    userRoles.add(extraRole)

    # Now we have
    # 1. userRoles:
    #    the set of roles that this user has mbt to the given record
    #    and all of its relevant master and detail records
    # 2. rules
    #    a dictionary mapping each possible action to the
    #    roles a user needs to have to perform that action
    #    The roles itself are given as a dict, keyed by the role
    #    and valued by a boolean or a set, depending on the action.

    # We compute the allowed actions resulting in a dict keyed by the action
    # and valued by a boolean.

    allowedActions = {}

    for (act, requiredRoles) in rules.items():
        if requiredRoles is None:
            continue

        permission = False

        for presentRole in userRoles:
            if requiredRoles.get(presentRole, False):
                permission = True
                break

        if permission:
            allowedActions[act] = True

    # Finally we return the result.
    #
    # If no action is given, we return the allowedActions straightaway.
    # Otherwise we lookup the given action in allowedActions, get the
    # associated value (or provide a falsy default), and return that.

    return allowedActions if action is None else allowedActions.get(action, False)</code></pre>
</details>
</dd>
<dt id="control.auth.Auth.makeSafe"><code class="name flex">
<span>def <span class="ident">makeSafe</span></span>(<span>self, table, record, action)</span>
</code></dt>
<dd>
<div class="desc"><p>Changes an update action into a read action if needed.</p>
<p>This function 'demotes' an "update: to a "read" if the
"update" is not allowed.</p>
<p>If "read" itself is not allowed, None is returned.</p>
<p>If any other action tahn "update" or "read" is passed, None is returned.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>table</code></strong> :&ensp;<code>string</code></dt>
<dd>The table in which the record exists.</dd>
<dt><strong><code>record</code></strong> :&ensp;<code>ObjectId | AttrDict</code></dt>
<dd>The id of the record or the record itself.</dd>
<dt><strong><code>action</code></strong> :&ensp;<code>string</code></dt>
<dd>An intended action.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>string | void</code></dt>
<dd>The resulting safe action.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/23c61c878149a0c80bf432c2e0e320f5e806d778/src/control/auth.py#L370-L398" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def makeSafe(self, table, record, action):
    &#34;&#34;&#34;Changes an update action into a read action if needed.

    This function &#39;demotes&#39; an &#34;update: to a &#34;read&#34; if the
    &#34;update&#34; is not allowed.

    If &#34;read&#34; itself is not allowed, None is returned.

    If any other action tahn &#34;update&#34; or &#34;read&#34; is passed, None is returned.

    Parameters
    ----------
    table: string
        The table in which the record exists.
    record: ObjectId | AttrDict
        The id of the record or the record itself.
    action: string
        An intended action.

    Returns
    -------
    string | void
        The resulting safe action.
    &#34;&#34;&#34;
    if action not in {&#34;update&#34;, &#34;read&#34;}:
        return None

    actions = self.authorise(table, record)
    return action if action in actions else &#34;read&#34; if &#34;read&#34; in actions else None</code></pre>
</details>
</dd>
<dt id="control.auth.Auth.mayBackup"><code class="name flex">
<span>def <span class="ident">mayBackup</span></span>(<span>self, project=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Whether the current user is allowed to make backups.</p>
<ul>
<li>Backups are not allowed in production mode, bacause the system and not the
users are responsible for backups.</li>
<li>Site-wide backups are only allowed for power users.</li>
<li>Project backups are only allowed for project organisers and (power users).</li>
</ul>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>project</code></strong> :&ensp;<code>AttrDict | ObjectId | string</code>, optional <code>None</code></dt>
<dd>If None, we deal with site-wide backup.
Otherwise we get the backups of this project.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>boolean</code></dt>
<dd>whether the relevant backup/restore actions are allowed.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/23c61c878149a0c80bf432c2e0e320f5e806d778/src/control/auth.py#L326-L368" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def mayBackup(self, project=None):
    &#34;&#34;&#34;Whether the current user is allowed to make backups.

    *   Backups are not allowed in production mode, bacause the system and not the
        users are responsible for backups.
    *   Site-wide backups are only allowed for power users.
    *   Project backups are only allowed for project organisers and (power users).

    Parameters
    ----------
    project: AttrDict | ObjectId | string, optional None
        If None, we deal with site-wide backup.
        Otherwise we get the backups of this project.

    Returns
    -------
    boolean
        whether the relevant backup/restore actions are allowed.
    &#34;&#34;&#34;
    Settings = self.Settings
    runProd = Settings.runProd

    if runProd:
        return False

    User = self.myDetails()

    if User.role in {&#34;admin&#34;, &#34;root&#34;}:
        return True

    if project is None:
        return False

    Mongo = self.Mongo
    (projectId, project) = Mongo.get(&#34;project&#34;, project)
    if projectId is None:
        return False

    user = User.user
    projectUser = Mongo.getRecord(
        &#34;projectUser&#34;, user=user, projectId=projectId, warn=False
    )
    return projectUser.role == &#34;organiser&#34;</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="control.users.Users" href="users.html#control.users.Users">Users</a></b></code>:
<ul class="hlist">
<li><code><a title="control.users.Users.addAuthenticator" href="users.html#control.users.Users.addAuthenticator">addAuthenticator</a></code></li>
<li><code><a title="control.users.Users.afterLogin" href="users.html#control.users.Users.afterLogin">afterLogin</a></code></li>
<li><code><a title="control.users.Users.getInvolvedUsers" href="users.html#control.users.Users.getInvolvedUsers">getInvolvedUsers</a></code></li>
<li><code><a title="control.users.Users.getUser" href="users.html#control.users.Users.getUser">getUser</a></code></li>
<li><code><a title="control.users.Users.identify" href="users.html#control.users.Users.identify">identify</a></code></li>
<li><code><a title="control.users.Users.initUser" href="users.html#control.users.Users.initUser">initUser</a></code></li>
<li><code><a title="control.users.Users.login" href="users.html#control.users.Users.login">login</a></code></li>
<li><code><a title="control.users.Users.logout" href="users.html#control.users.Users.logout">logout</a></code></li>
<li><code><a title="control.users.Users.myDetails" href="users.html#control.users.Users.myDetails">myDetails</a></code></li>
<li><code><a title="control.users.Users.oidc" href="users.html#control.users.Users.oidc">oidc</a></code></li>
<li><code><a title="control.users.Users.presentRole" href="users.html#control.users.Users.presentRole">presentRole</a></code></li>
<li><code><a title="control.users.Users.wrapLogin" href="users.html#control.users.Users.wrapLogin">wrapLogin</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<p><a href="https://github.com/CLARIAH/pure3dx" title="GitHub repo">GitHub</a></p>
<p><a href="https://github.com/CLARIAH/pure3dx/blob/main/stats.md" title="GitHub repo">code stats</a></p>
<form>
<input id="lunr-search" name="q" placeholder=" Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="control" href="index.html">control</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="control.auth.Auth" href="#control.auth.Auth">Auth</a></code></h4>
<ul class="">
<li><code><a title="control.auth.Auth.authorise" href="#control.auth.Auth.authorise">authorise</a></code></li>
<li><code><a title="control.auth.Auth.makeSafe" href="#control.auth.Auth.makeSafe">makeSafe</a></code></li>
<li><code><a title="control.auth.Auth.mayBackup" href="#control.auth.Auth.mayBackup">mayBackup</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<a href="https://pure.knaw.nl/portal/en/persons/dirk-roorda">Dirk Roorda</a>
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>