<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>control.publish API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>control.publish</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/1a4455072b1ffa872b86f15d4e31826810cd1f2e/src/control/publish.py#L1-L464" class="git-link">Browse git</a>
</summary>
<pre><code class="python">from datetime import datetime as dt
from traceback import format_exception

from control.files import (
    dirContents,
    dirMake,
    dirRemove,
    dirCopy,
    fileCopy,
    fileExists,
    fileRemove,
    writeJson,
)
from control.generic import deepdict
from control.precheck import Precheck as PrecheckCls
from control.static import Static as StaticCls


class Publish:
    def __init__(
        self, Settings, Messages, Viewers, Mongo, Content, Tailwind, Handlebars
    ):
        &#34;&#34;&#34;Publishing content as static pages.

        It is instantiated by a singleton object.

        Parameters
        ----------
        Settings: AttrDict
            App-wide configuration data obtained from
            `control.config.Config.Settings`.
        Messages: object
            Singleton instance of `control.messages.Messages`.
        Mongo: object
            Singleton instance of `control.mongo.Mongo`.
        Tailwind: object
            Singleton instance of `control.tailwind.Tailwind`.
        &#34;&#34;&#34;
        self.Settings = Settings
        self.Messages = Messages
        self.Viewers = Viewers
        self.Mongo = Mongo
        self.Content = Content
        self.Tailwind = Tailwind
        self.Handlebars = Handlebars
        Messages.debugAdd(self)
        Content.addPublish(self)

        self.Precheck = (
            None if Content is None else PrecheckCls(Settings, Messages, Viewers)
        )

    def getPubNums(self, project, edition):
        &#34;&#34;&#34;Determine project and edition publication numbers.

        Those numbers are inside the project and edition records in the database
        if the project/edition has been published before;
        otherwise we pick an unused number for the project;
        and within the project an unused edition number.

        When we look for those numbers, we look in the database records,
        and we look on the filesystem, and we take the number one higher than
        the maximum number used in the database and on the file system.
        &#34;&#34;&#34;
        Mongo = self.Mongo
        Settings = self.Settings
        pubModeDir = Settings.pubModeDir
        projectDir = f&#34;{pubModeDir}/project&#34;

        pPubNumLast = project.pubNum
        ePubNumLast = edition.pubNum

        def getNum(kind, item, pubNumLast, condition, itemsDir):
            if pubNumLast is None:
                itemsDb = Mongo.getList(kind, stop=False, **condition)
                nDb = len(itemsDb)
                maxDb = 0 if nDb == 0 else max(r.pubNum or 0 for r in itemsDb)

                itemsFile = [int(n) for n in dirContents(itemsDir)[1] if n.isdecimal()]
                nFile = len(itemsFile)

                maxFile = 0 if nFile == 0 else max(itemsFile)
                pubNum = max((maxDb, maxFile)) + 1
            else:
                pubNum = pubNumLast

            return pubNum

        kind = &#34;project&#34;
        item = project
        pubNumLast = pPubNumLast
        condition = {}
        itemsDir = projectDir

        pPubNum = getNum(kind, item, pubNumLast, condition, itemsDir)

        kind = &#34;edition&#34;
        item = edition
        pubNumLast = ePubNumLast
        condition = dict(projectId=project._id)
        itemsDir = f&#34;{projectDir}/{pPubNum}/edition&#34;

        ePubNum = getNum(kind, item, pubNumLast, condition, itemsDir)

        return (pPubNum, ePubNum)

    def generatePages(self, pPubNum, ePubNum):
        Settings = self.Settings
        Messages = self.Messages
        Viewers = self.Viewers
        Content = self.Content
        Tailwind = self.Tailwind
        Handlebars = self.Handlebars

        site = Content.relevant()[-1]
        featured = Content.getValue(&#34;site&#34;, site, &#34;featured&#34;, manner=&#34;logical&#34;)

        Static = StaticCls(Settings, Messages, Viewers, Tailwind, Handlebars)

        try:
            good = Static.genPages(pPubNum, ePubNum, featured=featured)

        except Exception as e1:
            Messages.error(logmsg=&#34;&#34;.join(format_exception(e1)), stop=False)
            good = False

        return good

    def updateEdition(self, site, project, edition, action, force=False, again=False):
        Settings = self.Settings
        Messages = self.Messages
        Mongo = self.Mongo
        Precheck = self.Precheck

        if action not in {&#34;add&#34;, &#34;remove&#34;}:
            Messages.error(msg=f&#34;unknown action {action}&#34;, stop=False)
            return

        processing = site.processing

        # quit early if another processing action is taking place

        if processing:
            Messages.warning(
                msg=&#34;Site is being published. Try again a minute later&#34;,
                logmsg=(
                    f&#34;Refusing to publish {project._id}/{edition._id} &#34;
                    &#34;while site is being republished&#34;
                ),
            )
            return

        # put a flag in the database that the site is publishing
        # this will prevent other publishing actions while this action is running

        last = site.lastPublished
        now = dt.utcnow().isoformat(timespec=&#34;seconds&#34;).replace(&#34;:&#34;, &#34;-&#34;)

        Mongo.updateRecord(
            &#34;site&#34;, dict(processing=True, lastPublished=now), _id=site._id
        )

        # make sure that if something fails, the publishing flag will be reset

        pubModeDir = Settings.pubModeDir
        projectDir = f&#34;{pubModeDir}/project&#34;

        def restore(table, record):
            key = &#34;isVisible&#34; if table == &#34;project&#34; else &#34;isPublished&#34;
            Mongo.updateRecord(
                table,
                {
                    &#34;pubNum&#34;: record.pubNum,
                    &#34;lastPublished&#34;: record.lastPublished,
                    key: record[key] or False,
                },
                _id=record._id,
            )

        # quit early, without doing anything, if the action is not applicable

        good = True

        if action == &#34;add&#34;:
            thisGood = Precheck.checkEdition(project, edition._id, edition)

            if thisGood:
                Messages.info(&#34;Edition validation OK&#34;)
            else:
                Messages.info(&#34;Edition validation not OK&#34;)
                good = False

                if force:
                    Messages.info(&#34;Continuing nevertheless&#34;)
                    good = True

            (pPubNum, ePubNum) = self.getPubNums(project, edition)

            if pPubNum is None:
                Messages.error(
                    msg=&#34;Could not find a publication number for project&#34;,
                    logmsg=f&#34;Could not find a pubnum for project {project._id}&#34;,
                    stop=False,
                )
                good = False

            if ePubNum is None:
                Messages.error(
                    msg=&#34;Could not find a publication number for edition&#34;,
                    logmsg=f&#34;Could not find a pubnum for {project._id}/{edition._id}&#34;,
                    stop=False,
                )
                good = False

            # if all went well, pPubNum and ePubNum are defined

        elif action == &#34;remove&#34;:
            pPubNum = project.pubNum
            ePubNum = edition.pubNum
            pPubNumNew = pPubNum
            ePubNumNew = ePubNum

            if pPubNum is None:
                Messages.warning(
                    msg=&#34;Project is not a published one and cannot be unpublished&#34;,
                    logmsg=f&#34;Project {project._id} has no pubnum&#34;,
                )
                good = False

            if ePubNum is None:
                Messages.warning(
                    msg=&#34;Edition is not a published one and cannot be unpublished&#34;,
                    logmsg=f&#34;Edition {project._id}/{edition._id} has no pubnum&#34;,
                )
                good = False

        if good:
            thisProjectDir = f&#34;{projectDir}/{pPubNum}&#34;
            logmsg = None

            if action == &#34;add&#34;:
                try:
                    stage = f&#34;set pubnum for project to {pPubNum}&#34;
                    update = dict(pubNum=pPubNum, lastPublished=now, isVisible=True)
                    Mongo.updateRecord(&#34;project&#34;, update, _id=project._id)

                    stage = f&#34;set pubnum for edition to {ePubNum}&#34;
                    update = dict(pubNum=ePubNum, lastPublished=now, isPublished=True)
                    Mongo.updateRecord(&#34;edition&#34;, update, _id=edition._id)

                    stage = &#34;add site files&#34;
                    self.addSiteFiles(site)

                    stage = f&#34;add project files to {pPubNum}&#34;
                    self.addProjectFiles(project, pPubNum)

                    stage = f&#34;add edition files to {pPubNum}/{ePubNum}&#34;
                    self.addEditionFiles(project, pPubNum, edition, ePubNum)

                    stage = f&#34;generate static pages for {pPubNum}/{ePubNum}&#34;

                    if self.generatePages(pPubNum, ePubNum):
                        Messages.info(
                            msg=f&#34;Published edition to {pPubNum}/{ePubNum}&#34;,
                            logmsg=(
                                f&#34;Published {project._id}/{edition._id} &#34;
                                f&#34;as {pPubNum}/{ePubNum}&#34;
                            ),
                        )
                    else:
                        good = False

                except Exception as e:
                    good = False
                    logmsg = (
                        f&#34;Publishing {project._id}/{edition._id} &#34;
                        f&#34;as {pPubNum}/{ePubNum} failed with error {e}&#34;
                        f&#34;at stage &#39;{stage}&#39;&#34;
                    )

                if not good:
                    Messages.error(
                        msg=&#34;Publishing of edition failed&#34;,
                        logmsg=logmsg,
                        stop=False,
                    )
                    self.removeEditionFiles(pPubNum, ePubNum)
                    theseEditions = dirContents(f&#34;{thisProjectDir}/edition&#34;)[1]

                    if len(theseEditions) == 0:
                        self.removeProjectFiles(pPubNum)

            elif action == &#34;remove&#34;:
                try:
                    stage = f&#34;unset pubnum for edition from {ePubNum} to None&#34;
                    update = dict(pubNum=None, isPublished=False)
                    Mongo.updateRecord(&#34;edition&#34;, update, _id=edition._id)

                    stage = f&#34;remove edition files {pPubNum}/{ePubNum}&#34;
                    self.removeEditionFiles(pPubNum, ePubNum)
                    Messages.info(
                        msg=f&#34;Unpublished edition {pPubNum}/{ePubNum}&#34;,
                        logmsg=(
                            f&#34;Unpublished edition {pPubNum}/{ePubNum} = &#34;
                            f&#34;{project._id}/{edition._id}&#34;
                        ),
                    )
                    ePubNumNew = None

                    # check whether there are other published editions in this project
                    # on the file system

                    stage = f&#34;check remaining editions in project {pPubNum}&#34;
                    theseEditions = dirContents(f&#34;{thisProjectDir}/edition&#34;)[1]

                    if len(theseEditions) == 0:
                        stage = f&#34;unset pubnum for project from {pPubNum} to None&#34;
                        update = dict(pubNum=None, isVisible=False)
                        Mongo.updateRecord(&#34;project&#34;, update, _id=project._id)

                        stage = f&#34;remove project files {pPubNum}&#34;
                        self.removeProjectFiles(pPubNum)

                        pPubNumNew = None

                    else:
                        Messages.info(
                            msg=(
                                f&#34;Project {pPubNum} still has {len(theseEditions)} &#34;
                                &#34;published editions&#34;
                            ),
                        )

                    pNumRep = (
                        pPubNum if pPubNumNew == pPubNum else f&#34;{pPubNum}=&gt;{pPubNumNew}&#34;
                    )
                    eNumRep = (
                        ePubNum if ePubNumNew == ePubNum else f&#34;{ePubNum}=&gt;{ePubNumNew}&#34;
                    )

                    stage = f&#34;regenerate static pages for {pNumRep}/{eNumRep}&#34;

                    if self.generatePages(pPubNum, ePubNum):
                        Messages.info(
                            msg=f&#34;Unpublished project {pPubNum}&#34;,
                            logmsg=(f&#34;Unpublished project {pPubNum} = {project._id}&#34;),
                        )
                    else:
                        good = False

                except Exception as e:
                    good = False
                    logmsg = (
                        f&#34;Unpublishing edition {pPubNum}/{ePubNum} = &#34;
                        f&#34;{project._id}/{edition._id} failed with error {e}.&#34;
                        f&#34;at stage &#39;{stage}&#39;&#34;
                    )

                if not good:
                    Messages.error(
                        msg=&#34;Unpublishing of edition failed&#34;,
                        logmsg=logmsg,
                        stop=False,
                    )

        # finish off with unsetting the processing flag in the database

        if good:
            lastPublished = now
        else:
            restore(&#34;project&#34;, project)
            restore(&#34;edition&#34;, edition)
            lastPublished = last

        Mongo.updateRecord(
            &#34;site&#34;, dict(processing=False, lastPublished=lastPublished), _id=site._id
        )

    def addSiteFiles(self, site):
        Settings = self.Settings
        workingDir = Settings.workingDir
        pubModeDir = Settings.pubModeDir
        dbFile = Settings.dbFile

        dirMake(pubModeDir)

        (files, dirs) = dirContents(workingDir)

        for x in files:
            fileCopy(f&#34;{workingDir}/{x}&#34;, f&#34;{pubModeDir}/{x}&#34;)

        for x in dirs:
            if x in {&#34;project&#34;, &#34;meta&#34;}:
                continue

            dirCopy(f&#34;{workingDir}/{x}&#34;, f&#34;{pubModeDir}/{x}&#34;)

        dirMake(f&#34;{pubModeDir}/project&#34;)
        writeJson(deepdict(site), asFile=f&#34;{pubModeDir}/{dbFile}&#34;)

    def addProjectFiles(self, project, pPubNum):
        Settings = self.Settings
        workingDir = Settings.workingDir
        pubModeDir = Settings.pubModeDir
        dbFile = Settings.dbFile

        inDir = f&#34;{workingDir}/project/{project._id}&#34;
        outDir = f&#34;{pubModeDir}/project/{pPubNum}&#34;
        dirMake(outDir)

        (files, dirs) = dirContents(inDir)

        for x in files:
            fileCopy(f&#34;{inDir}/{x}&#34;, f&#34;{outDir}/{x}&#34;)

        for x in dirs:
            if x in {&#34;edition&#34;, &#34;meta&#34;}:
                continue

            dirCopy(f&#34;{inDir}/{x}&#34;, f&#34;{outDir}/{x}&#34;)

        writeJson(deepdict(project), asFile=f&#34;{outDir}/{dbFile}&#34;)

    def addEditionFiles(self, project, pPubNum, edition, ePubNum):
        Settings = self.Settings
        workingDir = Settings.workingDir
        pubModeDir = Settings.pubModeDir
        tocFile = Settings.tocFile
        dbFile = Settings.dbFile

        inDir = f&#34;{workingDir}/project/{project._id}/edition/{edition._id}&#34;
        outDir = f&#34;{pubModeDir}/project/{pPubNum}/edition/{ePubNum}&#34;
        dirMake(outDir)
        tocPath = f&#34;{outDir}/{tocFile}&#34;

        if fileExists(tocPath):
            fileRemove(tocPath)

        (files, dirs) = dirContents(inDir)

        for x in files:
            fileCopy(f&#34;{inDir}/{x}&#34;, f&#34;{outDir}/{x}&#34;)

        for x in dirs:
            if x in {&#34;meta&#34;}:
                continue

            dirCopy(f&#34;{inDir}/{x}&#34;, f&#34;{outDir}/{x}&#34;)

        writeJson(deepdict(edition), asFile=f&#34;{outDir}/{dbFile}&#34;)

    def removeProjectFiles(self, pPubNum):
        Settings = self.Settings
        pubModeDir = Settings.pubModeDir

        outDir = f&#34;{pubModeDir}/project/{pPubNum}&#34;
        dirRemove(outDir)

    def removeEditionFiles(self, pPubNum, ePubNum):
        Settings = self.Settings
        pubModeDir = Settings.pubModeDir

        outDir = f&#34;{pubModeDir}/project/{pPubNum}/edition/{ePubNum}&#34;
        dirRemove(outDir)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="control.publish.Publish"><code class="flex name class">
<span>class <span class="ident">Publish</span></span>
<span>(</span><span>Settings, Messages, Viewers, Mongo, Content, Tailwind, Handlebars)</span>
</code></dt>
<dd>
<div class="desc"><p>Publishing content as static pages.</p>
<p>It is instantiated by a singleton object.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>Settings</code></strong> :&ensp;<code>AttrDict</code></dt>
<dd>App-wide configuration data obtained from
<code><a title="control.config.Config.Settings" href="config.html#control.config.Config.Settings">Config.Settings</a></code>.</dd>
<dt><strong><code>Messages</code></strong> :&ensp;<code>object</code></dt>
<dd>Singleton instance of <code><a title="control.messages.Messages" href="messages.html#control.messages.Messages">Messages</a></code>.</dd>
<dt><strong><code>Mongo</code></strong> :&ensp;<code>object</code></dt>
<dd>Singleton instance of <code><a title="control.mongo.Mongo" href="mongo.html#control.mongo.Mongo">Mongo</a></code>.</dd>
<dt><strong><code>Tailwind</code></strong> :&ensp;<code>object</code></dt>
<dd>Singleton instance of <code><a title="control.tailwind.Tailwind" href="tailwind.html#control.tailwind.Tailwind">Tailwind</a></code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/1a4455072b1ffa872b86f15d4e31826810cd1f2e/src/control/publish.py#L19-L464" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Publish:
    def __init__(
        self, Settings, Messages, Viewers, Mongo, Content, Tailwind, Handlebars
    ):
        &#34;&#34;&#34;Publishing content as static pages.

        It is instantiated by a singleton object.

        Parameters
        ----------
        Settings: AttrDict
            App-wide configuration data obtained from
            `control.config.Config.Settings`.
        Messages: object
            Singleton instance of `control.messages.Messages`.
        Mongo: object
            Singleton instance of `control.mongo.Mongo`.
        Tailwind: object
            Singleton instance of `control.tailwind.Tailwind`.
        &#34;&#34;&#34;
        self.Settings = Settings
        self.Messages = Messages
        self.Viewers = Viewers
        self.Mongo = Mongo
        self.Content = Content
        self.Tailwind = Tailwind
        self.Handlebars = Handlebars
        Messages.debugAdd(self)
        Content.addPublish(self)

        self.Precheck = (
            None if Content is None else PrecheckCls(Settings, Messages, Viewers)
        )

    def getPubNums(self, project, edition):
        &#34;&#34;&#34;Determine project and edition publication numbers.

        Those numbers are inside the project and edition records in the database
        if the project/edition has been published before;
        otherwise we pick an unused number for the project;
        and within the project an unused edition number.

        When we look for those numbers, we look in the database records,
        and we look on the filesystem, and we take the number one higher than
        the maximum number used in the database and on the file system.
        &#34;&#34;&#34;
        Mongo = self.Mongo
        Settings = self.Settings
        pubModeDir = Settings.pubModeDir
        projectDir = f&#34;{pubModeDir}/project&#34;

        pPubNumLast = project.pubNum
        ePubNumLast = edition.pubNum

        def getNum(kind, item, pubNumLast, condition, itemsDir):
            if pubNumLast is None:
                itemsDb = Mongo.getList(kind, stop=False, **condition)
                nDb = len(itemsDb)
                maxDb = 0 if nDb == 0 else max(r.pubNum or 0 for r in itemsDb)

                itemsFile = [int(n) for n in dirContents(itemsDir)[1] if n.isdecimal()]
                nFile = len(itemsFile)

                maxFile = 0 if nFile == 0 else max(itemsFile)
                pubNum = max((maxDb, maxFile)) + 1
            else:
                pubNum = pubNumLast

            return pubNum

        kind = &#34;project&#34;
        item = project
        pubNumLast = pPubNumLast
        condition = {}
        itemsDir = projectDir

        pPubNum = getNum(kind, item, pubNumLast, condition, itemsDir)

        kind = &#34;edition&#34;
        item = edition
        pubNumLast = ePubNumLast
        condition = dict(projectId=project._id)
        itemsDir = f&#34;{projectDir}/{pPubNum}/edition&#34;

        ePubNum = getNum(kind, item, pubNumLast, condition, itemsDir)

        return (pPubNum, ePubNum)

    def generatePages(self, pPubNum, ePubNum):
        Settings = self.Settings
        Messages = self.Messages
        Viewers = self.Viewers
        Content = self.Content
        Tailwind = self.Tailwind
        Handlebars = self.Handlebars

        site = Content.relevant()[-1]
        featured = Content.getValue(&#34;site&#34;, site, &#34;featured&#34;, manner=&#34;logical&#34;)

        Static = StaticCls(Settings, Messages, Viewers, Tailwind, Handlebars)

        try:
            good = Static.genPages(pPubNum, ePubNum, featured=featured)

        except Exception as e1:
            Messages.error(logmsg=&#34;&#34;.join(format_exception(e1)), stop=False)
            good = False

        return good

    def updateEdition(self, site, project, edition, action, force=False, again=False):
        Settings = self.Settings
        Messages = self.Messages
        Mongo = self.Mongo
        Precheck = self.Precheck

        if action not in {&#34;add&#34;, &#34;remove&#34;}:
            Messages.error(msg=f&#34;unknown action {action}&#34;, stop=False)
            return

        processing = site.processing

        # quit early if another processing action is taking place

        if processing:
            Messages.warning(
                msg=&#34;Site is being published. Try again a minute later&#34;,
                logmsg=(
                    f&#34;Refusing to publish {project._id}/{edition._id} &#34;
                    &#34;while site is being republished&#34;
                ),
            )
            return

        # put a flag in the database that the site is publishing
        # this will prevent other publishing actions while this action is running

        last = site.lastPublished
        now = dt.utcnow().isoformat(timespec=&#34;seconds&#34;).replace(&#34;:&#34;, &#34;-&#34;)

        Mongo.updateRecord(
            &#34;site&#34;, dict(processing=True, lastPublished=now), _id=site._id
        )

        # make sure that if something fails, the publishing flag will be reset

        pubModeDir = Settings.pubModeDir
        projectDir = f&#34;{pubModeDir}/project&#34;

        def restore(table, record):
            key = &#34;isVisible&#34; if table == &#34;project&#34; else &#34;isPublished&#34;
            Mongo.updateRecord(
                table,
                {
                    &#34;pubNum&#34;: record.pubNum,
                    &#34;lastPublished&#34;: record.lastPublished,
                    key: record[key] or False,
                },
                _id=record._id,
            )

        # quit early, without doing anything, if the action is not applicable

        good = True

        if action == &#34;add&#34;:
            thisGood = Precheck.checkEdition(project, edition._id, edition)

            if thisGood:
                Messages.info(&#34;Edition validation OK&#34;)
            else:
                Messages.info(&#34;Edition validation not OK&#34;)
                good = False

                if force:
                    Messages.info(&#34;Continuing nevertheless&#34;)
                    good = True

            (pPubNum, ePubNum) = self.getPubNums(project, edition)

            if pPubNum is None:
                Messages.error(
                    msg=&#34;Could not find a publication number for project&#34;,
                    logmsg=f&#34;Could not find a pubnum for project {project._id}&#34;,
                    stop=False,
                )
                good = False

            if ePubNum is None:
                Messages.error(
                    msg=&#34;Could not find a publication number for edition&#34;,
                    logmsg=f&#34;Could not find a pubnum for {project._id}/{edition._id}&#34;,
                    stop=False,
                )
                good = False

            # if all went well, pPubNum and ePubNum are defined

        elif action == &#34;remove&#34;:
            pPubNum = project.pubNum
            ePubNum = edition.pubNum
            pPubNumNew = pPubNum
            ePubNumNew = ePubNum

            if pPubNum is None:
                Messages.warning(
                    msg=&#34;Project is not a published one and cannot be unpublished&#34;,
                    logmsg=f&#34;Project {project._id} has no pubnum&#34;,
                )
                good = False

            if ePubNum is None:
                Messages.warning(
                    msg=&#34;Edition is not a published one and cannot be unpublished&#34;,
                    logmsg=f&#34;Edition {project._id}/{edition._id} has no pubnum&#34;,
                )
                good = False

        if good:
            thisProjectDir = f&#34;{projectDir}/{pPubNum}&#34;
            logmsg = None

            if action == &#34;add&#34;:
                try:
                    stage = f&#34;set pubnum for project to {pPubNum}&#34;
                    update = dict(pubNum=pPubNum, lastPublished=now, isVisible=True)
                    Mongo.updateRecord(&#34;project&#34;, update, _id=project._id)

                    stage = f&#34;set pubnum for edition to {ePubNum}&#34;
                    update = dict(pubNum=ePubNum, lastPublished=now, isPublished=True)
                    Mongo.updateRecord(&#34;edition&#34;, update, _id=edition._id)

                    stage = &#34;add site files&#34;
                    self.addSiteFiles(site)

                    stage = f&#34;add project files to {pPubNum}&#34;
                    self.addProjectFiles(project, pPubNum)

                    stage = f&#34;add edition files to {pPubNum}/{ePubNum}&#34;
                    self.addEditionFiles(project, pPubNum, edition, ePubNum)

                    stage = f&#34;generate static pages for {pPubNum}/{ePubNum}&#34;

                    if self.generatePages(pPubNum, ePubNum):
                        Messages.info(
                            msg=f&#34;Published edition to {pPubNum}/{ePubNum}&#34;,
                            logmsg=(
                                f&#34;Published {project._id}/{edition._id} &#34;
                                f&#34;as {pPubNum}/{ePubNum}&#34;
                            ),
                        )
                    else:
                        good = False

                except Exception as e:
                    good = False
                    logmsg = (
                        f&#34;Publishing {project._id}/{edition._id} &#34;
                        f&#34;as {pPubNum}/{ePubNum} failed with error {e}&#34;
                        f&#34;at stage &#39;{stage}&#39;&#34;
                    )

                if not good:
                    Messages.error(
                        msg=&#34;Publishing of edition failed&#34;,
                        logmsg=logmsg,
                        stop=False,
                    )
                    self.removeEditionFiles(pPubNum, ePubNum)
                    theseEditions = dirContents(f&#34;{thisProjectDir}/edition&#34;)[1]

                    if len(theseEditions) == 0:
                        self.removeProjectFiles(pPubNum)

            elif action == &#34;remove&#34;:
                try:
                    stage = f&#34;unset pubnum for edition from {ePubNum} to None&#34;
                    update = dict(pubNum=None, isPublished=False)
                    Mongo.updateRecord(&#34;edition&#34;, update, _id=edition._id)

                    stage = f&#34;remove edition files {pPubNum}/{ePubNum}&#34;
                    self.removeEditionFiles(pPubNum, ePubNum)
                    Messages.info(
                        msg=f&#34;Unpublished edition {pPubNum}/{ePubNum}&#34;,
                        logmsg=(
                            f&#34;Unpublished edition {pPubNum}/{ePubNum} = &#34;
                            f&#34;{project._id}/{edition._id}&#34;
                        ),
                    )
                    ePubNumNew = None

                    # check whether there are other published editions in this project
                    # on the file system

                    stage = f&#34;check remaining editions in project {pPubNum}&#34;
                    theseEditions = dirContents(f&#34;{thisProjectDir}/edition&#34;)[1]

                    if len(theseEditions) == 0:
                        stage = f&#34;unset pubnum for project from {pPubNum} to None&#34;
                        update = dict(pubNum=None, isVisible=False)
                        Mongo.updateRecord(&#34;project&#34;, update, _id=project._id)

                        stage = f&#34;remove project files {pPubNum}&#34;
                        self.removeProjectFiles(pPubNum)

                        pPubNumNew = None

                    else:
                        Messages.info(
                            msg=(
                                f&#34;Project {pPubNum} still has {len(theseEditions)} &#34;
                                &#34;published editions&#34;
                            ),
                        )

                    pNumRep = (
                        pPubNum if pPubNumNew == pPubNum else f&#34;{pPubNum}=&gt;{pPubNumNew}&#34;
                    )
                    eNumRep = (
                        ePubNum if ePubNumNew == ePubNum else f&#34;{ePubNum}=&gt;{ePubNumNew}&#34;
                    )

                    stage = f&#34;regenerate static pages for {pNumRep}/{eNumRep}&#34;

                    if self.generatePages(pPubNum, ePubNum):
                        Messages.info(
                            msg=f&#34;Unpublished project {pPubNum}&#34;,
                            logmsg=(f&#34;Unpublished project {pPubNum} = {project._id}&#34;),
                        )
                    else:
                        good = False

                except Exception as e:
                    good = False
                    logmsg = (
                        f&#34;Unpublishing edition {pPubNum}/{ePubNum} = &#34;
                        f&#34;{project._id}/{edition._id} failed with error {e}.&#34;
                        f&#34;at stage &#39;{stage}&#39;&#34;
                    )

                if not good:
                    Messages.error(
                        msg=&#34;Unpublishing of edition failed&#34;,
                        logmsg=logmsg,
                        stop=False,
                    )

        # finish off with unsetting the processing flag in the database

        if good:
            lastPublished = now
        else:
            restore(&#34;project&#34;, project)
            restore(&#34;edition&#34;, edition)
            lastPublished = last

        Mongo.updateRecord(
            &#34;site&#34;, dict(processing=False, lastPublished=lastPublished), _id=site._id
        )

    def addSiteFiles(self, site):
        Settings = self.Settings
        workingDir = Settings.workingDir
        pubModeDir = Settings.pubModeDir
        dbFile = Settings.dbFile

        dirMake(pubModeDir)

        (files, dirs) = dirContents(workingDir)

        for x in files:
            fileCopy(f&#34;{workingDir}/{x}&#34;, f&#34;{pubModeDir}/{x}&#34;)

        for x in dirs:
            if x in {&#34;project&#34;, &#34;meta&#34;}:
                continue

            dirCopy(f&#34;{workingDir}/{x}&#34;, f&#34;{pubModeDir}/{x}&#34;)

        dirMake(f&#34;{pubModeDir}/project&#34;)
        writeJson(deepdict(site), asFile=f&#34;{pubModeDir}/{dbFile}&#34;)

    def addProjectFiles(self, project, pPubNum):
        Settings = self.Settings
        workingDir = Settings.workingDir
        pubModeDir = Settings.pubModeDir
        dbFile = Settings.dbFile

        inDir = f&#34;{workingDir}/project/{project._id}&#34;
        outDir = f&#34;{pubModeDir}/project/{pPubNum}&#34;
        dirMake(outDir)

        (files, dirs) = dirContents(inDir)

        for x in files:
            fileCopy(f&#34;{inDir}/{x}&#34;, f&#34;{outDir}/{x}&#34;)

        for x in dirs:
            if x in {&#34;edition&#34;, &#34;meta&#34;}:
                continue

            dirCopy(f&#34;{inDir}/{x}&#34;, f&#34;{outDir}/{x}&#34;)

        writeJson(deepdict(project), asFile=f&#34;{outDir}/{dbFile}&#34;)

    def addEditionFiles(self, project, pPubNum, edition, ePubNum):
        Settings = self.Settings
        workingDir = Settings.workingDir
        pubModeDir = Settings.pubModeDir
        tocFile = Settings.tocFile
        dbFile = Settings.dbFile

        inDir = f&#34;{workingDir}/project/{project._id}/edition/{edition._id}&#34;
        outDir = f&#34;{pubModeDir}/project/{pPubNum}/edition/{ePubNum}&#34;
        dirMake(outDir)
        tocPath = f&#34;{outDir}/{tocFile}&#34;

        if fileExists(tocPath):
            fileRemove(tocPath)

        (files, dirs) = dirContents(inDir)

        for x in files:
            fileCopy(f&#34;{inDir}/{x}&#34;, f&#34;{outDir}/{x}&#34;)

        for x in dirs:
            if x in {&#34;meta&#34;}:
                continue

            dirCopy(f&#34;{inDir}/{x}&#34;, f&#34;{outDir}/{x}&#34;)

        writeJson(deepdict(edition), asFile=f&#34;{outDir}/{dbFile}&#34;)

    def removeProjectFiles(self, pPubNum):
        Settings = self.Settings
        pubModeDir = Settings.pubModeDir

        outDir = f&#34;{pubModeDir}/project/{pPubNum}&#34;
        dirRemove(outDir)

    def removeEditionFiles(self, pPubNum, ePubNum):
        Settings = self.Settings
        pubModeDir = Settings.pubModeDir

        outDir = f&#34;{pubModeDir}/project/{pPubNum}/edition/{ePubNum}&#34;
        dirRemove(outDir)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="control.publish.Publish.addEditionFiles"><code class="name flex">
<span>def <span class="ident">addEditionFiles</span></span>(<span>self, project, pPubNum, edition, ePubNum)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/1a4455072b1ffa872b86f15d4e31826810cd1f2e/src/control/publish.py#L424-L450" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def addEditionFiles(self, project, pPubNum, edition, ePubNum):
    Settings = self.Settings
    workingDir = Settings.workingDir
    pubModeDir = Settings.pubModeDir
    tocFile = Settings.tocFile
    dbFile = Settings.dbFile

    inDir = f&#34;{workingDir}/project/{project._id}/edition/{edition._id}&#34;
    outDir = f&#34;{pubModeDir}/project/{pPubNum}/edition/{ePubNum}&#34;
    dirMake(outDir)
    tocPath = f&#34;{outDir}/{tocFile}&#34;

    if fileExists(tocPath):
        fileRemove(tocPath)

    (files, dirs) = dirContents(inDir)

    for x in files:
        fileCopy(f&#34;{inDir}/{x}&#34;, f&#34;{outDir}/{x}&#34;)

    for x in dirs:
        if x in {&#34;meta&#34;}:
            continue

        dirCopy(f&#34;{inDir}/{x}&#34;, f&#34;{outDir}/{x}&#34;)

    writeJson(deepdict(edition), asFile=f&#34;{outDir}/{dbFile}&#34;)</code></pre>
</details>
</dd>
<dt id="control.publish.Publish.addProjectFiles"><code class="name flex">
<span>def <span class="ident">addProjectFiles</span></span>(<span>self, project, pPubNum)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/1a4455072b1ffa872b86f15d4e31826810cd1f2e/src/control/publish.py#L401-L422" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def addProjectFiles(self, project, pPubNum):
    Settings = self.Settings
    workingDir = Settings.workingDir
    pubModeDir = Settings.pubModeDir
    dbFile = Settings.dbFile

    inDir = f&#34;{workingDir}/project/{project._id}&#34;
    outDir = f&#34;{pubModeDir}/project/{pPubNum}&#34;
    dirMake(outDir)

    (files, dirs) = dirContents(inDir)

    for x in files:
        fileCopy(f&#34;{inDir}/{x}&#34;, f&#34;{outDir}/{x}&#34;)

    for x in dirs:
        if x in {&#34;edition&#34;, &#34;meta&#34;}:
            continue

        dirCopy(f&#34;{inDir}/{x}&#34;, f&#34;{outDir}/{x}&#34;)

    writeJson(deepdict(project), asFile=f&#34;{outDir}/{dbFile}&#34;)</code></pre>
</details>
</dd>
<dt id="control.publish.Publish.addSiteFiles"><code class="name flex">
<span>def <span class="ident">addSiteFiles</span></span>(<span>self, site)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/1a4455072b1ffa872b86f15d4e31826810cd1f2e/src/control/publish.py#L379-L399" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def addSiteFiles(self, site):
    Settings = self.Settings
    workingDir = Settings.workingDir
    pubModeDir = Settings.pubModeDir
    dbFile = Settings.dbFile

    dirMake(pubModeDir)

    (files, dirs) = dirContents(workingDir)

    for x in files:
        fileCopy(f&#34;{workingDir}/{x}&#34;, f&#34;{pubModeDir}/{x}&#34;)

    for x in dirs:
        if x in {&#34;project&#34;, &#34;meta&#34;}:
            continue

        dirCopy(f&#34;{workingDir}/{x}&#34;, f&#34;{pubModeDir}/{x}&#34;)

    dirMake(f&#34;{pubModeDir}/project&#34;)
    writeJson(deepdict(site), asFile=f&#34;{pubModeDir}/{dbFile}&#34;)</code></pre>
</details>
</dd>
<dt id="control.publish.Publish.generatePages"><code class="name flex">
<span>def <span class="ident">generatePages</span></span>(<span>self, pPubNum, ePubNum)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/1a4455072b1ffa872b86f15d4e31826810cd1f2e/src/control/publish.py#L107-L127" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def generatePages(self, pPubNum, ePubNum):
    Settings = self.Settings
    Messages = self.Messages
    Viewers = self.Viewers
    Content = self.Content
    Tailwind = self.Tailwind
    Handlebars = self.Handlebars

    site = Content.relevant()[-1]
    featured = Content.getValue(&#34;site&#34;, site, &#34;featured&#34;, manner=&#34;logical&#34;)

    Static = StaticCls(Settings, Messages, Viewers, Tailwind, Handlebars)

    try:
        good = Static.genPages(pPubNum, ePubNum, featured=featured)

    except Exception as e1:
        Messages.error(logmsg=&#34;&#34;.join(format_exception(e1)), stop=False)
        good = False

    return good</code></pre>
</details>
</dd>
<dt id="control.publish.Publish.getPubNums"><code class="name flex">
<span>def <span class="ident">getPubNums</span></span>(<span>self, project, edition)</span>
</code></dt>
<dd>
<div class="desc"><p>Determine project and edition publication numbers.</p>
<p>Those numbers are inside the project and edition records in the database
if the project/edition has been published before;
otherwise we pick an unused number for the project;
and within the project an unused edition number.</p>
<p>When we look for those numbers, we look in the database records,
and we look on the filesystem, and we take the number one higher than
the maximum number used in the database and on the file system.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/1a4455072b1ffa872b86f15d4e31826810cd1f2e/src/control/publish.py#L53-L105" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getPubNums(self, project, edition):
    &#34;&#34;&#34;Determine project and edition publication numbers.

    Those numbers are inside the project and edition records in the database
    if the project/edition has been published before;
    otherwise we pick an unused number for the project;
    and within the project an unused edition number.

    When we look for those numbers, we look in the database records,
    and we look on the filesystem, and we take the number one higher than
    the maximum number used in the database and on the file system.
    &#34;&#34;&#34;
    Mongo = self.Mongo
    Settings = self.Settings
    pubModeDir = Settings.pubModeDir
    projectDir = f&#34;{pubModeDir}/project&#34;

    pPubNumLast = project.pubNum
    ePubNumLast = edition.pubNum

    def getNum(kind, item, pubNumLast, condition, itemsDir):
        if pubNumLast is None:
            itemsDb = Mongo.getList(kind, stop=False, **condition)
            nDb = len(itemsDb)
            maxDb = 0 if nDb == 0 else max(r.pubNum or 0 for r in itemsDb)

            itemsFile = [int(n) for n in dirContents(itemsDir)[1] if n.isdecimal()]
            nFile = len(itemsFile)

            maxFile = 0 if nFile == 0 else max(itemsFile)
            pubNum = max((maxDb, maxFile)) + 1
        else:
            pubNum = pubNumLast

        return pubNum

    kind = &#34;project&#34;
    item = project
    pubNumLast = pPubNumLast
    condition = {}
    itemsDir = projectDir

    pPubNum = getNum(kind, item, pubNumLast, condition, itemsDir)

    kind = &#34;edition&#34;
    item = edition
    pubNumLast = ePubNumLast
    condition = dict(projectId=project._id)
    itemsDir = f&#34;{projectDir}/{pPubNum}/edition&#34;

    ePubNum = getNum(kind, item, pubNumLast, condition, itemsDir)

    return (pPubNum, ePubNum)</code></pre>
</details>
</dd>
<dt id="control.publish.Publish.removeEditionFiles"><code class="name flex">
<span>def <span class="ident">removeEditionFiles</span></span>(<span>self, pPubNum, ePubNum)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/1a4455072b1ffa872b86f15d4e31826810cd1f2e/src/control/publish.py#L459-L464" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def removeEditionFiles(self, pPubNum, ePubNum):
    Settings = self.Settings
    pubModeDir = Settings.pubModeDir

    outDir = f&#34;{pubModeDir}/project/{pPubNum}/edition/{ePubNum}&#34;
    dirRemove(outDir)</code></pre>
</details>
</dd>
<dt id="control.publish.Publish.removeProjectFiles"><code class="name flex">
<span>def <span class="ident">removeProjectFiles</span></span>(<span>self, pPubNum)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/1a4455072b1ffa872b86f15d4e31826810cd1f2e/src/control/publish.py#L452-L457" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def removeProjectFiles(self, pPubNum):
    Settings = self.Settings
    pubModeDir = Settings.pubModeDir

    outDir = f&#34;{pubModeDir}/project/{pPubNum}&#34;
    dirRemove(outDir)</code></pre>
</details>
</dd>
<dt id="control.publish.Publish.updateEdition"><code class="name flex">
<span>def <span class="ident">updateEdition</span></span>(<span>self, site, project, edition, action, force=False, again=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/1a4455072b1ffa872b86f15d4e31826810cd1f2e/src/control/publish.py#L129-L377" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def updateEdition(self, site, project, edition, action, force=False, again=False):
    Settings = self.Settings
    Messages = self.Messages
    Mongo = self.Mongo
    Precheck = self.Precheck

    if action not in {&#34;add&#34;, &#34;remove&#34;}:
        Messages.error(msg=f&#34;unknown action {action}&#34;, stop=False)
        return

    processing = site.processing

    # quit early if another processing action is taking place

    if processing:
        Messages.warning(
            msg=&#34;Site is being published. Try again a minute later&#34;,
            logmsg=(
                f&#34;Refusing to publish {project._id}/{edition._id} &#34;
                &#34;while site is being republished&#34;
            ),
        )
        return

    # put a flag in the database that the site is publishing
    # this will prevent other publishing actions while this action is running

    last = site.lastPublished
    now = dt.utcnow().isoformat(timespec=&#34;seconds&#34;).replace(&#34;:&#34;, &#34;-&#34;)

    Mongo.updateRecord(
        &#34;site&#34;, dict(processing=True, lastPublished=now), _id=site._id
    )

    # make sure that if something fails, the publishing flag will be reset

    pubModeDir = Settings.pubModeDir
    projectDir = f&#34;{pubModeDir}/project&#34;

    def restore(table, record):
        key = &#34;isVisible&#34; if table == &#34;project&#34; else &#34;isPublished&#34;
        Mongo.updateRecord(
            table,
            {
                &#34;pubNum&#34;: record.pubNum,
                &#34;lastPublished&#34;: record.lastPublished,
                key: record[key] or False,
            },
            _id=record._id,
        )

    # quit early, without doing anything, if the action is not applicable

    good = True

    if action == &#34;add&#34;:
        thisGood = Precheck.checkEdition(project, edition._id, edition)

        if thisGood:
            Messages.info(&#34;Edition validation OK&#34;)
        else:
            Messages.info(&#34;Edition validation not OK&#34;)
            good = False

            if force:
                Messages.info(&#34;Continuing nevertheless&#34;)
                good = True

        (pPubNum, ePubNum) = self.getPubNums(project, edition)

        if pPubNum is None:
            Messages.error(
                msg=&#34;Could not find a publication number for project&#34;,
                logmsg=f&#34;Could not find a pubnum for project {project._id}&#34;,
                stop=False,
            )
            good = False

        if ePubNum is None:
            Messages.error(
                msg=&#34;Could not find a publication number for edition&#34;,
                logmsg=f&#34;Could not find a pubnum for {project._id}/{edition._id}&#34;,
                stop=False,
            )
            good = False

        # if all went well, pPubNum and ePubNum are defined

    elif action == &#34;remove&#34;:
        pPubNum = project.pubNum
        ePubNum = edition.pubNum
        pPubNumNew = pPubNum
        ePubNumNew = ePubNum

        if pPubNum is None:
            Messages.warning(
                msg=&#34;Project is not a published one and cannot be unpublished&#34;,
                logmsg=f&#34;Project {project._id} has no pubnum&#34;,
            )
            good = False

        if ePubNum is None:
            Messages.warning(
                msg=&#34;Edition is not a published one and cannot be unpublished&#34;,
                logmsg=f&#34;Edition {project._id}/{edition._id} has no pubnum&#34;,
            )
            good = False

    if good:
        thisProjectDir = f&#34;{projectDir}/{pPubNum}&#34;
        logmsg = None

        if action == &#34;add&#34;:
            try:
                stage = f&#34;set pubnum for project to {pPubNum}&#34;
                update = dict(pubNum=pPubNum, lastPublished=now, isVisible=True)
                Mongo.updateRecord(&#34;project&#34;, update, _id=project._id)

                stage = f&#34;set pubnum for edition to {ePubNum}&#34;
                update = dict(pubNum=ePubNum, lastPublished=now, isPublished=True)
                Mongo.updateRecord(&#34;edition&#34;, update, _id=edition._id)

                stage = &#34;add site files&#34;
                self.addSiteFiles(site)

                stage = f&#34;add project files to {pPubNum}&#34;
                self.addProjectFiles(project, pPubNum)

                stage = f&#34;add edition files to {pPubNum}/{ePubNum}&#34;
                self.addEditionFiles(project, pPubNum, edition, ePubNum)

                stage = f&#34;generate static pages for {pPubNum}/{ePubNum}&#34;

                if self.generatePages(pPubNum, ePubNum):
                    Messages.info(
                        msg=f&#34;Published edition to {pPubNum}/{ePubNum}&#34;,
                        logmsg=(
                            f&#34;Published {project._id}/{edition._id} &#34;
                            f&#34;as {pPubNum}/{ePubNum}&#34;
                        ),
                    )
                else:
                    good = False

            except Exception as e:
                good = False
                logmsg = (
                    f&#34;Publishing {project._id}/{edition._id} &#34;
                    f&#34;as {pPubNum}/{ePubNum} failed with error {e}&#34;
                    f&#34;at stage &#39;{stage}&#39;&#34;
                )

            if not good:
                Messages.error(
                    msg=&#34;Publishing of edition failed&#34;,
                    logmsg=logmsg,
                    stop=False,
                )
                self.removeEditionFiles(pPubNum, ePubNum)
                theseEditions = dirContents(f&#34;{thisProjectDir}/edition&#34;)[1]

                if len(theseEditions) == 0:
                    self.removeProjectFiles(pPubNum)

        elif action == &#34;remove&#34;:
            try:
                stage = f&#34;unset pubnum for edition from {ePubNum} to None&#34;
                update = dict(pubNum=None, isPublished=False)
                Mongo.updateRecord(&#34;edition&#34;, update, _id=edition._id)

                stage = f&#34;remove edition files {pPubNum}/{ePubNum}&#34;
                self.removeEditionFiles(pPubNum, ePubNum)
                Messages.info(
                    msg=f&#34;Unpublished edition {pPubNum}/{ePubNum}&#34;,
                    logmsg=(
                        f&#34;Unpublished edition {pPubNum}/{ePubNum} = &#34;
                        f&#34;{project._id}/{edition._id}&#34;
                    ),
                )
                ePubNumNew = None

                # check whether there are other published editions in this project
                # on the file system

                stage = f&#34;check remaining editions in project {pPubNum}&#34;
                theseEditions = dirContents(f&#34;{thisProjectDir}/edition&#34;)[1]

                if len(theseEditions) == 0:
                    stage = f&#34;unset pubnum for project from {pPubNum} to None&#34;
                    update = dict(pubNum=None, isVisible=False)
                    Mongo.updateRecord(&#34;project&#34;, update, _id=project._id)

                    stage = f&#34;remove project files {pPubNum}&#34;
                    self.removeProjectFiles(pPubNum)

                    pPubNumNew = None

                else:
                    Messages.info(
                        msg=(
                            f&#34;Project {pPubNum} still has {len(theseEditions)} &#34;
                            &#34;published editions&#34;
                        ),
                    )

                pNumRep = (
                    pPubNum if pPubNumNew == pPubNum else f&#34;{pPubNum}=&gt;{pPubNumNew}&#34;
                )
                eNumRep = (
                    ePubNum if ePubNumNew == ePubNum else f&#34;{ePubNum}=&gt;{ePubNumNew}&#34;
                )

                stage = f&#34;regenerate static pages for {pNumRep}/{eNumRep}&#34;

                if self.generatePages(pPubNum, ePubNum):
                    Messages.info(
                        msg=f&#34;Unpublished project {pPubNum}&#34;,
                        logmsg=(f&#34;Unpublished project {pPubNum} = {project._id}&#34;),
                    )
                else:
                    good = False

            except Exception as e:
                good = False
                logmsg = (
                    f&#34;Unpublishing edition {pPubNum}/{ePubNum} = &#34;
                    f&#34;{project._id}/{edition._id} failed with error {e}.&#34;
                    f&#34;at stage &#39;{stage}&#39;&#34;
                )

            if not good:
                Messages.error(
                    msg=&#34;Unpublishing of edition failed&#34;,
                    logmsg=logmsg,
                    stop=False,
                )

    # finish off with unsetting the processing flag in the database

    if good:
        lastPublished = now
    else:
        restore(&#34;project&#34;, project)
        restore(&#34;edition&#34;, edition)
        lastPublished = last

    Mongo.updateRecord(
        &#34;site&#34;, dict(processing=False, lastPublished=lastPublished), _id=site._id
    )</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<p><a href="https://github.com/CLARIAH/pure3dx" title="GitHub repo">GitHub</a></p>
<p><a href="https://github.com/CLARIAH/pure3dx/blob/main/stats.md" title="GitHub repo">code stats</a></p>
<form>
<input id="lunr-search" name="q" placeholder="🔎 Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="control" href="index.html">control</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="control.publish.Publish" href="#control.publish.Publish">Publish</a></code></h4>
<ul class="two-column">
<li><code><a title="control.publish.Publish.addEditionFiles" href="#control.publish.Publish.addEditionFiles">addEditionFiles</a></code></li>
<li><code><a title="control.publish.Publish.addProjectFiles" href="#control.publish.Publish.addProjectFiles">addProjectFiles</a></code></li>
<li><code><a title="control.publish.Publish.addSiteFiles" href="#control.publish.Publish.addSiteFiles">addSiteFiles</a></code></li>
<li><code><a title="control.publish.Publish.generatePages" href="#control.publish.Publish.generatePages">generatePages</a></code></li>
<li><code><a title="control.publish.Publish.getPubNums" href="#control.publish.Publish.getPubNums">getPubNums</a></code></li>
<li><code><a title="control.publish.Publish.removeEditionFiles" href="#control.publish.Publish.removeEditionFiles">removeEditionFiles</a></code></li>
<li><code><a title="control.publish.Publish.removeProjectFiles" href="#control.publish.Publish.removeProjectFiles">removeProjectFiles</a></code></li>
<li><code><a title="control.publish.Publish.updateEdition" href="#control.publish.Publish.updateEdition">updateEdition</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<a href="https://pure.knaw.nl/portal/en/persons/dirk-roorda">Dirk Roorda</a>
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>