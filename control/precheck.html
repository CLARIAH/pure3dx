<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>control.precheck API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>control.precheck</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/1a4455072b1ffa872b86f15d4e31826810cd1f2e/src/control/precheck.py#L1-L391" class="git-link">Browse git</a>
</summary>
<pre><code class="python">import re
import collections
from urllib.parse import unquote_plus as uq
from unicodedata import normalize as un

from control.files import (
    dirNm,
    dirContents,
    dirRemove,
    fileRemove,
    fileExists,
    readJson,
    writeYaml,
)
from control.helpers import showDict, htmlUnEsc


ONLINE_RE = re.compile(r&#34;&#34;&#34;^https?://&#34;&#34;&#34;, re.I)
MAILTO_RE = re.compile(r&#34;&#34;&#34;^mailto:&#34;&#34;&#34;, re.I)

STATUS = dict(
    unconfined=(&#34;error&#34;, &#34;link(s) to  a file outside the edition&#34;),
    external=(&#34;good&#34;, &#34;external link(s)&#34;),
    resolved=(&#34;good&#34;, &#34;resolved link(s)&#34;),
    missing=(&#34;error&#34;, &#34;link(s) with missing target&#34;),
    unreferenced=(&#34;warning&#34;, &#34;file(s) that are not referenced from anywhere&#34;),
)

SKIP = set(
    &#34;&#34;&#34;
 .DS_Store
&#34;&#34;&#34;.strip().split()
)


class Precheck:
    def __init__(self, Settings, Messages, Viewers):
        &#34;&#34;&#34;All about checking the files of an edition prior to publishing.&#34;&#34;&#34;
        self.Settings = Settings
        self.Messages = Messages
        self.Viewers = Viewers
        Messages.debugAdd(self)

    def checkEdition(self, project, edition, eInfo, asPublished=False):
        &#34;&#34;&#34;Checks the article and media files in an editon and produces a toc.

        Articles and media are files and directories that the user creates through
        the Voyager interface.

        Before publishing we want to make sure that these files pass some basic
        sanity checks:

        *   All links in the articles are either external links, or they point at an
            existing file within the edition.
        *   All non-html files are referred to by a link in an html file.
            Not meeting this requirement does not block publishing, but
            unreferenced files will not be published.

        We also create a table of contents of all html files in the edition, so they
        can be inspected outside the Voyager.

        To that, we add a table of the media files, together with the information
        which html files refer to them.

        The table of contents in the Pure3d author app is slightly different from
        that in the Pure3d pub app, because the internal links work differently.

        You can trigger the generation of a toc that works for the published edition
        as well.

        Parameters
        ----------
        project: string | ObjectId | AttrDict | int
            The id of the project in question.
        edition: string | ObjectId | AttrDict | int
            The id of the edition in question.
        asPublished: boolean, optional False
            If False, the project and edition refer to the edition in the
            Pure3D author app, and the toc file will be created there.

            If True, the project and edition are numbers that refer to the
            published edition;
            it is assumed that all checks pass and the only task is
            to create a toc that is valid in the published edition.

        Returns
        -------
        boolean | string
            If `asPublished` is True, it returns the toc as a string, otherwise
            it returns whether the edition passed all checks.
        &#34;&#34;&#34;
        Viewers = self.Viewers
        Messages = self.Messages
        Settings = self.Settings
        H = Settings.H
        workingDir = Settings.workingDir
        pubModeDir = Settings.pubModeDir
        tocFile = Settings.tocFile
        article = Settings.article
        media = Settings.media

        if asPublished:
            editionDir = f&#34;{pubModeDir}/project/{project}/edition/{edition}&#34;
        else:
            editionDir = f&#34;{workingDir}/project/{project._id}/edition/{edition}&#34;
            editionUrl = f&#34;/data/project/{project._id}/edition/{edition}&#34;

        sceneFile = Viewers.getViewInfo(eInfo)[1]
        scenePath = f&#34;{editionDir}/{sceneFile}&#34;

        REF_RE = re.compile(
            r&#34;&#34;&#34;
            \b(src|href)
            =
            [&#39;&#34;]
            ([^&#39;&#34;]*)
            [&#39;&#34;]
            &#34;&#34;&#34;,
            re.X | re.I,
        )

        sceneInfo = []
        references = []

        filesFound = dict(media=[], articles=[], models=[])
        filesReferenced = collections.defaultdict(collections.Counter)
        filesIssues = dict(
            unconfined=collections.defaultdict(collections.Counter),
            missing=collections.defaultdict(collections.Counter),
        )
        statusIndex = dict(
            unconfined=0, external=0, resolved=0, missing=0, unreferenced=0
        )
        targetA = {} if asPublished else dict(target=article)
        targetM = {} if asPublished else dict(target=media)
        preUrl = &#34;&#34; if asPublished else f&#34;{editionUrl}/&#34;

        def getUris(data, underUri):
            td = type(data)

            if td is list:
                return set().union(*(getUris(item, underUri) for item in data))

            if td is dict:
                return set().union(
                    *(
                        getUris(item, underUri or k in {&#34;uri&#34;, &#34;uris&#34;, &#34;url&#34;, &#34;urls&#34;})
                        for (k, item) in data.items()
                    )
                )

            if td is str and underUri:
                return {data}

            return set()

        def removeEmptyDirs(base):
            (files, dirs) = dirContents(base)

            for fl in files:
                if fl in SKIP:
                    fileRemove(f&#34;{base}/{fl}&#34;)
            for dr in dirs:
                removeEmptyDirs(f&#34;{base}/{dr}&#34;)

            (files, dirs) = dirContents(base)

            if len(files) == 0 and len(dirs) == 0:
                dirRemove(base)

        def checkScene():
            scene = readJson(asFile=scenePath, plain=True)
            sceneYaml = scenePath.removesuffix(&#34;json&#34;) + &#34;yaml&#34;
            writeYaml(scene, asFile=sceneYaml)

            for uri in sorted(getUris(scene, False)):
                references.append((sceneFile, &#34;models&#34;, un(&#34;NFC&#34;, htmlUnEsc(uri))))

            return scene

        def checkFile(target):
            sep = &#34;/&#34; if editionDir else &#34;&#34;

            with open(f&#34;{editionDir}{sep}{target}&#34;) as fh:
                for i, line in enumerate(fh):
                    for kind, url in REF_RE.findall(line):
                        references.append((target, kind, un(&#34;NFC&#34;, htmlUnEsc(url))))

        def checkFiles(path):
            nPath = len(path)
            pathRep = &#34;/&#34;.join(path)
            sep = &#34;/&#34; if nPath &gt; 0 and editionDir else &#34;&#34;
            (files, dirs) = dirContents(f&#34;{editionDir}{sep}{pathRep}&#34;)

            for name in files:
                namel = name.lower()
                nPath = len(path)
                pathRep = &#34;/&#34;.join(path)
                sep = &#34;/&#34; if nPath &gt; 0 else &#34;&#34;
                target = un(&#34;NFC&#34;, f&#34;{pathRep}{sep}{name}&#34;)

                if nPath &gt; 0 and namel.endswith(&#34;.html&#34;):
                    checkFile(target)
                    filesFound[&#34;articles&#34;].append(target)
                elif nPath == 0 and (namel.endswith(&#34;.glb&#34;) or namel.endswith(&#34;gltf&#34;)):
                    filesFound[&#34;models&#34;].append(target)
                elif nPath &gt; 0 and name not in SKIP:
                    filesFound[&#34;media&#34;].append(target)

            for name in dirs:
                checkFiles(path + (name,))

        def checkLinks():
            for kind, thisFileList in filesFound.items():
                for target in thisFileList:
                    filesReferenced[target] = collections.Counter()

            for source, kind, url in references:
                sourcePath = source
                sourceDir = dirNm(sourcePath)
                sep = &#34;/&#34; if sourceDir and url else &#34;&#34;
                targetPath = un(&#34;NFC&#34;, f&#34;{sourceDir}{sep}{uq(url)}&#34;)
                sep1 = &#34;/&#34; if targetPath and editionDir else &#34;&#34;

                if url.startswith(&#34;..&#34;):
                    status = &#34;unconfined&#34;
                    filesIssues[status][targetPath][sourcePath] += 1
                elif ONLINE_RE.match(url) or MAILTO_RE.match(url):
                    status = &#34;external&#34;
                elif fileExists(f&#34;{editionDir}{sep1}{targetPath}&#34;):
                    status = &#34;resolved&#34;
                    kind = (
                        &#34;articles&#34;
                        if targetPath.endswith(&#34;.html&#34;)
                        else &#34;models&#34;
                        if targetPath.endswith(&#34;.glb&#34;) or targetPath.endswith(&#34;gltf&#34;)
                        else &#34;media&#34;
                    )
                    filesReferenced[targetPath][sourcePath] += 1
                else:
                    status = &#34;missing&#34;
                    filesIssues[status][targetPath][sourcePath] += 1

                statusIndex[status] += 1

            good = True

            Messages.special(msg=&#34;Quality control report&#34;)

            if asPublished:
                nUnref = 0

                for target, sources in filesReferenced.items():
                    if len(sources) &gt; 0:
                        continue

                    fPath = f&#34;{editionDir}/{target}&#34;
                    fileRemove(fPath)
                    nUnref += 1

                removeEmptyDirs(editionDir)

                if nUnref:
                    Messages.warning(
                        f&#34;{nUnref} unreferenced files skipped from being published&#34;
                    )
            else:
                for sources in filesReferenced.values():
                    if len(sources) == 0:
                        statusIndex[&#34;unreferenced&#34;] += 1

                for kind, n in statusIndex.items():
                    (msgKind, kindRep) = STATUS[kind]
                    if msgKind in {&#34;error&#34;, &#34;warning&#34;} and n == 0:
                        msgKind = &#34;good&#34;
                    Messages.message(msgKind, f&#34;{n} {kindRep}&#34;, None, stop=False)

                    if msgKind == &#34;error&#34;:
                        good = False

            return good

        def wrapScene(sceneInfo):
            issues = {}

            for (status, theseFiles) in filesIssues.items():
                for file in theseFiles:
                    issues[file] = STATUS[status][0]

            return showDict(sceneFile, sceneInfo, issues=issues)

        def wrapFiles(kind):
            items = []

            theseFiles = filesFound[kind]

            outerCls = &#34;&#34;

            for i, target in enumerate(sorted(theseFiles, key=lambda x: x.lower())):
                sources = filesReferenced[target]

                total = sum(sources.values())
                cls = &#34;warning&#34; if total == 0 else &#34;&#34; if total == 1 else &#34;special&#34;

                if (
                    cls == &#34;warning&#34;
                    and outerCls == &#34;&#34;
                    or cls == &#34;error&#34;
                    and outerCls != &#34;error&#34;
                ):
                    outerCls = cls

                entryHead = H.a(target, f&#34;{preUrl}{target}&#34;, **targetM, cls=cls)
                sourceEntries = H.ul(
                    H.li(
                        [
                            H.a(s, f&#34;{preUrl}{s}&#34;, **targetA),
                            H.span(f&#34; - {n} x&#34;, cls=&#34;small mono&#34;),
                        ],
                    )
                    for (s, n) in sorted(sources.items(), key=lambda x: x[0].lower())
                )
                items.append(
                    H.li(
                        H.div(entryHead)
                        if total == 0
                        else H.details(entryHead, sourceEntries, f&#34;{kind}-{i}&#34;)
                    )
                )
            kindRep = kind[0].upper() + kind[1:]
            return H.details(
                H.b(f&#34;Table of {kindRep}&#34;, cls=outerCls), H.ul(items), kind
            )

        def wrapIssues(status):
            items = []

            theseFiles = filesIssues[status]

            if len(theseFiles) == 0:
                return &#34;&#34;

            for i, target in enumerate(sorted(theseFiles, key=lambda x: x.lower())):
                sources = theseFiles[target]

                cls = &#34;error&#34;

                entryHead = H.a(target, f&#34;{preUrl}{target}&#34;, **targetM, cls=cls)
                sourceEntries = H.ul(
                    H.li(
                        [
                            H.a(s, f&#34;{preUrl}{s}&#34;, **targetA),
                            H.span(f&#34; - {n} x&#34;, cls=&#34;small mono&#34;),
                        ],
                    )
                    for (s, n) in sorted(sources.items(), key=lambda x: x[0].lower())
                )
                items.append(H.li(H.details(entryHead, sourceEntries, f&#34;issues-{i}&#34;)))
            statusRep = STATUS[status][1]
            return H.details(H.b(f&#34;Table of {statusRep}&#34;, cls=cls), H.ul(items), status)

        def wrapReport():
            return (
                H.h(3, &#34;Scene information&#34;)
                + wrapScene(sceneInfo)
                + wrapFiles(&#34;models&#34;)
                + wrapFiles(&#34;articles&#34;)
                + wrapFiles(&#34;media&#34;)
                + wrapIssues(&#34;unconfined&#34;)
                + wrapIssues(&#34;missing&#34;)
            )

        sceneInfo = checkScene()
        checkFiles(())
        good = checkLinks()
        allTocs = wrapReport()

        if asPublished:
            return allTocs

        with open(f&#34;{editionDir}/{tocFile}&#34;, &#34;w&#34;) as fh:
            fh.write(allTocs)

        Messages.special(msg=&#34;Outcome&#34;)

        if good:
            Messages.good(msg=&#34;All checks OK&#34;)
        else:
            Messages.error(msg=&#34;Some checks failed&#34;, stop=False)

        return good</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="control.precheck.Precheck"><code class="flex name class">
<span>class <span class="ident">Precheck</span></span>
<span>(</span><span>Settings, Messages, Viewers)</span>
</code></dt>
<dd>
<div class="desc"><p>All about checking the files of an edition prior to publishing.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/1a4455072b1ffa872b86f15d4e31826810cd1f2e/src/control/precheck.py#L36-L391" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Precheck:
    def __init__(self, Settings, Messages, Viewers):
        &#34;&#34;&#34;All about checking the files of an edition prior to publishing.&#34;&#34;&#34;
        self.Settings = Settings
        self.Messages = Messages
        self.Viewers = Viewers
        Messages.debugAdd(self)

    def checkEdition(self, project, edition, eInfo, asPublished=False):
        &#34;&#34;&#34;Checks the article and media files in an editon and produces a toc.

        Articles and media are files and directories that the user creates through
        the Voyager interface.

        Before publishing we want to make sure that these files pass some basic
        sanity checks:

        *   All links in the articles are either external links, or they point at an
            existing file within the edition.
        *   All non-html files are referred to by a link in an html file.
            Not meeting this requirement does not block publishing, but
            unreferenced files will not be published.

        We also create a table of contents of all html files in the edition, so they
        can be inspected outside the Voyager.

        To that, we add a table of the media files, together with the information
        which html files refer to them.

        The table of contents in the Pure3d author app is slightly different from
        that in the Pure3d pub app, because the internal links work differently.

        You can trigger the generation of a toc that works for the published edition
        as well.

        Parameters
        ----------
        project: string | ObjectId | AttrDict | int
            The id of the project in question.
        edition: string | ObjectId | AttrDict | int
            The id of the edition in question.
        asPublished: boolean, optional False
            If False, the project and edition refer to the edition in the
            Pure3D author app, and the toc file will be created there.

            If True, the project and edition are numbers that refer to the
            published edition;
            it is assumed that all checks pass and the only task is
            to create a toc that is valid in the published edition.

        Returns
        -------
        boolean | string
            If `asPublished` is True, it returns the toc as a string, otherwise
            it returns whether the edition passed all checks.
        &#34;&#34;&#34;
        Viewers = self.Viewers
        Messages = self.Messages
        Settings = self.Settings
        H = Settings.H
        workingDir = Settings.workingDir
        pubModeDir = Settings.pubModeDir
        tocFile = Settings.tocFile
        article = Settings.article
        media = Settings.media

        if asPublished:
            editionDir = f&#34;{pubModeDir}/project/{project}/edition/{edition}&#34;
        else:
            editionDir = f&#34;{workingDir}/project/{project._id}/edition/{edition}&#34;
            editionUrl = f&#34;/data/project/{project._id}/edition/{edition}&#34;

        sceneFile = Viewers.getViewInfo(eInfo)[1]
        scenePath = f&#34;{editionDir}/{sceneFile}&#34;

        REF_RE = re.compile(
            r&#34;&#34;&#34;
            \b(src|href)
            =
            [&#39;&#34;]
            ([^&#39;&#34;]*)
            [&#39;&#34;]
            &#34;&#34;&#34;,
            re.X | re.I,
        )

        sceneInfo = []
        references = []

        filesFound = dict(media=[], articles=[], models=[])
        filesReferenced = collections.defaultdict(collections.Counter)
        filesIssues = dict(
            unconfined=collections.defaultdict(collections.Counter),
            missing=collections.defaultdict(collections.Counter),
        )
        statusIndex = dict(
            unconfined=0, external=0, resolved=0, missing=0, unreferenced=0
        )
        targetA = {} if asPublished else dict(target=article)
        targetM = {} if asPublished else dict(target=media)
        preUrl = &#34;&#34; if asPublished else f&#34;{editionUrl}/&#34;

        def getUris(data, underUri):
            td = type(data)

            if td is list:
                return set().union(*(getUris(item, underUri) for item in data))

            if td is dict:
                return set().union(
                    *(
                        getUris(item, underUri or k in {&#34;uri&#34;, &#34;uris&#34;, &#34;url&#34;, &#34;urls&#34;})
                        for (k, item) in data.items()
                    )
                )

            if td is str and underUri:
                return {data}

            return set()

        def removeEmptyDirs(base):
            (files, dirs) = dirContents(base)

            for fl in files:
                if fl in SKIP:
                    fileRemove(f&#34;{base}/{fl}&#34;)
            for dr in dirs:
                removeEmptyDirs(f&#34;{base}/{dr}&#34;)

            (files, dirs) = dirContents(base)

            if len(files) == 0 and len(dirs) == 0:
                dirRemove(base)

        def checkScene():
            scene = readJson(asFile=scenePath, plain=True)
            sceneYaml = scenePath.removesuffix(&#34;json&#34;) + &#34;yaml&#34;
            writeYaml(scene, asFile=sceneYaml)

            for uri in sorted(getUris(scene, False)):
                references.append((sceneFile, &#34;models&#34;, un(&#34;NFC&#34;, htmlUnEsc(uri))))

            return scene

        def checkFile(target):
            sep = &#34;/&#34; if editionDir else &#34;&#34;

            with open(f&#34;{editionDir}{sep}{target}&#34;) as fh:
                for i, line in enumerate(fh):
                    for kind, url in REF_RE.findall(line):
                        references.append((target, kind, un(&#34;NFC&#34;, htmlUnEsc(url))))

        def checkFiles(path):
            nPath = len(path)
            pathRep = &#34;/&#34;.join(path)
            sep = &#34;/&#34; if nPath &gt; 0 and editionDir else &#34;&#34;
            (files, dirs) = dirContents(f&#34;{editionDir}{sep}{pathRep}&#34;)

            for name in files:
                namel = name.lower()
                nPath = len(path)
                pathRep = &#34;/&#34;.join(path)
                sep = &#34;/&#34; if nPath &gt; 0 else &#34;&#34;
                target = un(&#34;NFC&#34;, f&#34;{pathRep}{sep}{name}&#34;)

                if nPath &gt; 0 and namel.endswith(&#34;.html&#34;):
                    checkFile(target)
                    filesFound[&#34;articles&#34;].append(target)
                elif nPath == 0 and (namel.endswith(&#34;.glb&#34;) or namel.endswith(&#34;gltf&#34;)):
                    filesFound[&#34;models&#34;].append(target)
                elif nPath &gt; 0 and name not in SKIP:
                    filesFound[&#34;media&#34;].append(target)

            for name in dirs:
                checkFiles(path + (name,))

        def checkLinks():
            for kind, thisFileList in filesFound.items():
                for target in thisFileList:
                    filesReferenced[target] = collections.Counter()

            for source, kind, url in references:
                sourcePath = source
                sourceDir = dirNm(sourcePath)
                sep = &#34;/&#34; if sourceDir and url else &#34;&#34;
                targetPath = un(&#34;NFC&#34;, f&#34;{sourceDir}{sep}{uq(url)}&#34;)
                sep1 = &#34;/&#34; if targetPath and editionDir else &#34;&#34;

                if url.startswith(&#34;..&#34;):
                    status = &#34;unconfined&#34;
                    filesIssues[status][targetPath][sourcePath] += 1
                elif ONLINE_RE.match(url) or MAILTO_RE.match(url):
                    status = &#34;external&#34;
                elif fileExists(f&#34;{editionDir}{sep1}{targetPath}&#34;):
                    status = &#34;resolved&#34;
                    kind = (
                        &#34;articles&#34;
                        if targetPath.endswith(&#34;.html&#34;)
                        else &#34;models&#34;
                        if targetPath.endswith(&#34;.glb&#34;) or targetPath.endswith(&#34;gltf&#34;)
                        else &#34;media&#34;
                    )
                    filesReferenced[targetPath][sourcePath] += 1
                else:
                    status = &#34;missing&#34;
                    filesIssues[status][targetPath][sourcePath] += 1

                statusIndex[status] += 1

            good = True

            Messages.special(msg=&#34;Quality control report&#34;)

            if asPublished:
                nUnref = 0

                for target, sources in filesReferenced.items():
                    if len(sources) &gt; 0:
                        continue

                    fPath = f&#34;{editionDir}/{target}&#34;
                    fileRemove(fPath)
                    nUnref += 1

                removeEmptyDirs(editionDir)

                if nUnref:
                    Messages.warning(
                        f&#34;{nUnref} unreferenced files skipped from being published&#34;
                    )
            else:
                for sources in filesReferenced.values():
                    if len(sources) == 0:
                        statusIndex[&#34;unreferenced&#34;] += 1

                for kind, n in statusIndex.items():
                    (msgKind, kindRep) = STATUS[kind]
                    if msgKind in {&#34;error&#34;, &#34;warning&#34;} and n == 0:
                        msgKind = &#34;good&#34;
                    Messages.message(msgKind, f&#34;{n} {kindRep}&#34;, None, stop=False)

                    if msgKind == &#34;error&#34;:
                        good = False

            return good

        def wrapScene(sceneInfo):
            issues = {}

            for (status, theseFiles) in filesIssues.items():
                for file in theseFiles:
                    issues[file] = STATUS[status][0]

            return showDict(sceneFile, sceneInfo, issues=issues)

        def wrapFiles(kind):
            items = []

            theseFiles = filesFound[kind]

            outerCls = &#34;&#34;

            for i, target in enumerate(sorted(theseFiles, key=lambda x: x.lower())):
                sources = filesReferenced[target]

                total = sum(sources.values())
                cls = &#34;warning&#34; if total == 0 else &#34;&#34; if total == 1 else &#34;special&#34;

                if (
                    cls == &#34;warning&#34;
                    and outerCls == &#34;&#34;
                    or cls == &#34;error&#34;
                    and outerCls != &#34;error&#34;
                ):
                    outerCls = cls

                entryHead = H.a(target, f&#34;{preUrl}{target}&#34;, **targetM, cls=cls)
                sourceEntries = H.ul(
                    H.li(
                        [
                            H.a(s, f&#34;{preUrl}{s}&#34;, **targetA),
                            H.span(f&#34; - {n} x&#34;, cls=&#34;small mono&#34;),
                        ],
                    )
                    for (s, n) in sorted(sources.items(), key=lambda x: x[0].lower())
                )
                items.append(
                    H.li(
                        H.div(entryHead)
                        if total == 0
                        else H.details(entryHead, sourceEntries, f&#34;{kind}-{i}&#34;)
                    )
                )
            kindRep = kind[0].upper() + kind[1:]
            return H.details(
                H.b(f&#34;Table of {kindRep}&#34;, cls=outerCls), H.ul(items), kind
            )

        def wrapIssues(status):
            items = []

            theseFiles = filesIssues[status]

            if len(theseFiles) == 0:
                return &#34;&#34;

            for i, target in enumerate(sorted(theseFiles, key=lambda x: x.lower())):
                sources = theseFiles[target]

                cls = &#34;error&#34;

                entryHead = H.a(target, f&#34;{preUrl}{target}&#34;, **targetM, cls=cls)
                sourceEntries = H.ul(
                    H.li(
                        [
                            H.a(s, f&#34;{preUrl}{s}&#34;, **targetA),
                            H.span(f&#34; - {n} x&#34;, cls=&#34;small mono&#34;),
                        ],
                    )
                    for (s, n) in sorted(sources.items(), key=lambda x: x[0].lower())
                )
                items.append(H.li(H.details(entryHead, sourceEntries, f&#34;issues-{i}&#34;)))
            statusRep = STATUS[status][1]
            return H.details(H.b(f&#34;Table of {statusRep}&#34;, cls=cls), H.ul(items), status)

        def wrapReport():
            return (
                H.h(3, &#34;Scene information&#34;)
                + wrapScene(sceneInfo)
                + wrapFiles(&#34;models&#34;)
                + wrapFiles(&#34;articles&#34;)
                + wrapFiles(&#34;media&#34;)
                + wrapIssues(&#34;unconfined&#34;)
                + wrapIssues(&#34;missing&#34;)
            )

        sceneInfo = checkScene()
        checkFiles(())
        good = checkLinks()
        allTocs = wrapReport()

        if asPublished:
            return allTocs

        with open(f&#34;{editionDir}/{tocFile}&#34;, &#34;w&#34;) as fh:
            fh.write(allTocs)

        Messages.special(msg=&#34;Outcome&#34;)

        if good:
            Messages.good(msg=&#34;All checks OK&#34;)
        else:
            Messages.error(msg=&#34;Some checks failed&#34;, stop=False)

        return good</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="control.precheck.Precheck.checkEdition"><code class="name flex">
<span>def <span class="ident">checkEdition</span></span>(<span>self, project, edition, eInfo, asPublished=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Checks the article and media files in an editon and produces a toc.</p>
<p>Articles and media are files and directories that the user creates through
the Voyager interface.</p>
<p>Before publishing we want to make sure that these files pass some basic
sanity checks:</p>
<ul>
<li>All links in the articles are either external links, or they point at an
existing file within the edition.</li>
<li>All non-html files are referred to by a link in an html file.
Not meeting this requirement does not block publishing, but
unreferenced files will not be published.</li>
</ul>
<p>We also create a table of contents of all html files in the edition, so they
can be inspected outside the Voyager.</p>
<p>To that, we add a table of the media files, together with the information
which html files refer to them.</p>
<p>The table of contents in the Pure3d author app is slightly different from
that in the Pure3d pub app, because the internal links work differently.</p>
<p>You can trigger the generation of a toc that works for the published edition
as well.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>project</code></strong> :&ensp;<code>string | ObjectId | AttrDict | int</code></dt>
<dd>The id of the project in question.</dd>
<dt><strong><code>edition</code></strong> :&ensp;<code>string | ObjectId | AttrDict | int</code></dt>
<dd>The id of the edition in question.</dd>
<dt><strong><code>asPublished</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>
<p>If False, the project and edition refer to the edition in the
Pure3D author app, and the toc file will be created there.</p>
<p>If True, the project and edition are numbers that refer to the
published edition;
it is assumed that all checks pass and the only task is
to create a toc that is valid in the published edition.</p>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>boolean | string</code></dt>
<dd>If <code>asPublished</code> is True, it returns the toc as a string, otherwise
it returns whether the edition passed all checks.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/1a4455072b1ffa872b86f15d4e31826810cd1f2e/src/control/precheck.py#L44-L391" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def checkEdition(self, project, edition, eInfo, asPublished=False):
    &#34;&#34;&#34;Checks the article and media files in an editon and produces a toc.

    Articles and media are files and directories that the user creates through
    the Voyager interface.

    Before publishing we want to make sure that these files pass some basic
    sanity checks:

    *   All links in the articles are either external links, or they point at an
        existing file within the edition.
    *   All non-html files are referred to by a link in an html file.
        Not meeting this requirement does not block publishing, but
        unreferenced files will not be published.

    We also create a table of contents of all html files in the edition, so they
    can be inspected outside the Voyager.

    To that, we add a table of the media files, together with the information
    which html files refer to them.

    The table of contents in the Pure3d author app is slightly different from
    that in the Pure3d pub app, because the internal links work differently.

    You can trigger the generation of a toc that works for the published edition
    as well.

    Parameters
    ----------
    project: string | ObjectId | AttrDict | int
        The id of the project in question.
    edition: string | ObjectId | AttrDict | int
        The id of the edition in question.
    asPublished: boolean, optional False
        If False, the project and edition refer to the edition in the
        Pure3D author app, and the toc file will be created there.

        If True, the project and edition are numbers that refer to the
        published edition;
        it is assumed that all checks pass and the only task is
        to create a toc that is valid in the published edition.

    Returns
    -------
    boolean | string
        If `asPublished` is True, it returns the toc as a string, otherwise
        it returns whether the edition passed all checks.
    &#34;&#34;&#34;
    Viewers = self.Viewers
    Messages = self.Messages
    Settings = self.Settings
    H = Settings.H
    workingDir = Settings.workingDir
    pubModeDir = Settings.pubModeDir
    tocFile = Settings.tocFile
    article = Settings.article
    media = Settings.media

    if asPublished:
        editionDir = f&#34;{pubModeDir}/project/{project}/edition/{edition}&#34;
    else:
        editionDir = f&#34;{workingDir}/project/{project._id}/edition/{edition}&#34;
        editionUrl = f&#34;/data/project/{project._id}/edition/{edition}&#34;

    sceneFile = Viewers.getViewInfo(eInfo)[1]
    scenePath = f&#34;{editionDir}/{sceneFile}&#34;

    REF_RE = re.compile(
        r&#34;&#34;&#34;
        \b(src|href)
        =
        [&#39;&#34;]
        ([^&#39;&#34;]*)
        [&#39;&#34;]
        &#34;&#34;&#34;,
        re.X | re.I,
    )

    sceneInfo = []
    references = []

    filesFound = dict(media=[], articles=[], models=[])
    filesReferenced = collections.defaultdict(collections.Counter)
    filesIssues = dict(
        unconfined=collections.defaultdict(collections.Counter),
        missing=collections.defaultdict(collections.Counter),
    )
    statusIndex = dict(
        unconfined=0, external=0, resolved=0, missing=0, unreferenced=0
    )
    targetA = {} if asPublished else dict(target=article)
    targetM = {} if asPublished else dict(target=media)
    preUrl = &#34;&#34; if asPublished else f&#34;{editionUrl}/&#34;

    def getUris(data, underUri):
        td = type(data)

        if td is list:
            return set().union(*(getUris(item, underUri) for item in data))

        if td is dict:
            return set().union(
                *(
                    getUris(item, underUri or k in {&#34;uri&#34;, &#34;uris&#34;, &#34;url&#34;, &#34;urls&#34;})
                    for (k, item) in data.items()
                )
            )

        if td is str and underUri:
            return {data}

        return set()

    def removeEmptyDirs(base):
        (files, dirs) = dirContents(base)

        for fl in files:
            if fl in SKIP:
                fileRemove(f&#34;{base}/{fl}&#34;)
        for dr in dirs:
            removeEmptyDirs(f&#34;{base}/{dr}&#34;)

        (files, dirs) = dirContents(base)

        if len(files) == 0 and len(dirs) == 0:
            dirRemove(base)

    def checkScene():
        scene = readJson(asFile=scenePath, plain=True)
        sceneYaml = scenePath.removesuffix(&#34;json&#34;) + &#34;yaml&#34;
        writeYaml(scene, asFile=sceneYaml)

        for uri in sorted(getUris(scene, False)):
            references.append((sceneFile, &#34;models&#34;, un(&#34;NFC&#34;, htmlUnEsc(uri))))

        return scene

    def checkFile(target):
        sep = &#34;/&#34; if editionDir else &#34;&#34;

        with open(f&#34;{editionDir}{sep}{target}&#34;) as fh:
            for i, line in enumerate(fh):
                for kind, url in REF_RE.findall(line):
                    references.append((target, kind, un(&#34;NFC&#34;, htmlUnEsc(url))))

    def checkFiles(path):
        nPath = len(path)
        pathRep = &#34;/&#34;.join(path)
        sep = &#34;/&#34; if nPath &gt; 0 and editionDir else &#34;&#34;
        (files, dirs) = dirContents(f&#34;{editionDir}{sep}{pathRep}&#34;)

        for name in files:
            namel = name.lower()
            nPath = len(path)
            pathRep = &#34;/&#34;.join(path)
            sep = &#34;/&#34; if nPath &gt; 0 else &#34;&#34;
            target = un(&#34;NFC&#34;, f&#34;{pathRep}{sep}{name}&#34;)

            if nPath &gt; 0 and namel.endswith(&#34;.html&#34;):
                checkFile(target)
                filesFound[&#34;articles&#34;].append(target)
            elif nPath == 0 and (namel.endswith(&#34;.glb&#34;) or namel.endswith(&#34;gltf&#34;)):
                filesFound[&#34;models&#34;].append(target)
            elif nPath &gt; 0 and name not in SKIP:
                filesFound[&#34;media&#34;].append(target)

        for name in dirs:
            checkFiles(path + (name,))

    def checkLinks():
        for kind, thisFileList in filesFound.items():
            for target in thisFileList:
                filesReferenced[target] = collections.Counter()

        for source, kind, url in references:
            sourcePath = source
            sourceDir = dirNm(sourcePath)
            sep = &#34;/&#34; if sourceDir and url else &#34;&#34;
            targetPath = un(&#34;NFC&#34;, f&#34;{sourceDir}{sep}{uq(url)}&#34;)
            sep1 = &#34;/&#34; if targetPath and editionDir else &#34;&#34;

            if url.startswith(&#34;..&#34;):
                status = &#34;unconfined&#34;
                filesIssues[status][targetPath][sourcePath] += 1
            elif ONLINE_RE.match(url) or MAILTO_RE.match(url):
                status = &#34;external&#34;
            elif fileExists(f&#34;{editionDir}{sep1}{targetPath}&#34;):
                status = &#34;resolved&#34;
                kind = (
                    &#34;articles&#34;
                    if targetPath.endswith(&#34;.html&#34;)
                    else &#34;models&#34;
                    if targetPath.endswith(&#34;.glb&#34;) or targetPath.endswith(&#34;gltf&#34;)
                    else &#34;media&#34;
                )
                filesReferenced[targetPath][sourcePath] += 1
            else:
                status = &#34;missing&#34;
                filesIssues[status][targetPath][sourcePath] += 1

            statusIndex[status] += 1

        good = True

        Messages.special(msg=&#34;Quality control report&#34;)

        if asPublished:
            nUnref = 0

            for target, sources in filesReferenced.items():
                if len(sources) &gt; 0:
                    continue

                fPath = f&#34;{editionDir}/{target}&#34;
                fileRemove(fPath)
                nUnref += 1

            removeEmptyDirs(editionDir)

            if nUnref:
                Messages.warning(
                    f&#34;{nUnref} unreferenced files skipped from being published&#34;
                )
        else:
            for sources in filesReferenced.values():
                if len(sources) == 0:
                    statusIndex[&#34;unreferenced&#34;] += 1

            for kind, n in statusIndex.items():
                (msgKind, kindRep) = STATUS[kind]
                if msgKind in {&#34;error&#34;, &#34;warning&#34;} and n == 0:
                    msgKind = &#34;good&#34;
                Messages.message(msgKind, f&#34;{n} {kindRep}&#34;, None, stop=False)

                if msgKind == &#34;error&#34;:
                    good = False

        return good

    def wrapScene(sceneInfo):
        issues = {}

        for (status, theseFiles) in filesIssues.items():
            for file in theseFiles:
                issues[file] = STATUS[status][0]

        return showDict(sceneFile, sceneInfo, issues=issues)

    def wrapFiles(kind):
        items = []

        theseFiles = filesFound[kind]

        outerCls = &#34;&#34;

        for i, target in enumerate(sorted(theseFiles, key=lambda x: x.lower())):
            sources = filesReferenced[target]

            total = sum(sources.values())
            cls = &#34;warning&#34; if total == 0 else &#34;&#34; if total == 1 else &#34;special&#34;

            if (
                cls == &#34;warning&#34;
                and outerCls == &#34;&#34;
                or cls == &#34;error&#34;
                and outerCls != &#34;error&#34;
            ):
                outerCls = cls

            entryHead = H.a(target, f&#34;{preUrl}{target}&#34;, **targetM, cls=cls)
            sourceEntries = H.ul(
                H.li(
                    [
                        H.a(s, f&#34;{preUrl}{s}&#34;, **targetA),
                        H.span(f&#34; - {n} x&#34;, cls=&#34;small mono&#34;),
                    ],
                )
                for (s, n) in sorted(sources.items(), key=lambda x: x[0].lower())
            )
            items.append(
                H.li(
                    H.div(entryHead)
                    if total == 0
                    else H.details(entryHead, sourceEntries, f&#34;{kind}-{i}&#34;)
                )
            )
        kindRep = kind[0].upper() + kind[1:]
        return H.details(
            H.b(f&#34;Table of {kindRep}&#34;, cls=outerCls), H.ul(items), kind
        )

    def wrapIssues(status):
        items = []

        theseFiles = filesIssues[status]

        if len(theseFiles) == 0:
            return &#34;&#34;

        for i, target in enumerate(sorted(theseFiles, key=lambda x: x.lower())):
            sources = theseFiles[target]

            cls = &#34;error&#34;

            entryHead = H.a(target, f&#34;{preUrl}{target}&#34;, **targetM, cls=cls)
            sourceEntries = H.ul(
                H.li(
                    [
                        H.a(s, f&#34;{preUrl}{s}&#34;, **targetA),
                        H.span(f&#34; - {n} x&#34;, cls=&#34;small mono&#34;),
                    ],
                )
                for (s, n) in sorted(sources.items(), key=lambda x: x[0].lower())
            )
            items.append(H.li(H.details(entryHead, sourceEntries, f&#34;issues-{i}&#34;)))
        statusRep = STATUS[status][1]
        return H.details(H.b(f&#34;Table of {statusRep}&#34;, cls=cls), H.ul(items), status)

    def wrapReport():
        return (
            H.h(3, &#34;Scene information&#34;)
            + wrapScene(sceneInfo)
            + wrapFiles(&#34;models&#34;)
            + wrapFiles(&#34;articles&#34;)
            + wrapFiles(&#34;media&#34;)
            + wrapIssues(&#34;unconfined&#34;)
            + wrapIssues(&#34;missing&#34;)
        )

    sceneInfo = checkScene()
    checkFiles(())
    good = checkLinks()
    allTocs = wrapReport()

    if asPublished:
        return allTocs

    with open(f&#34;{editionDir}/{tocFile}&#34;, &#34;w&#34;) as fh:
        fh.write(allTocs)

    Messages.special(msg=&#34;Outcome&#34;)

    if good:
        Messages.good(msg=&#34;All checks OK&#34;)
    else:
        Messages.error(msg=&#34;Some checks failed&#34;, stop=False)

    return good</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<p><a href="https://github.com/CLARIAH/pure3dx" title="GitHub repo">GitHub</a></p>
<p><a href="https://github.com/CLARIAH/pure3dx/blob/main/stats.md" title="GitHub repo">code stats</a></p>
<form>
<input id="lunr-search" name="q" placeholder="ðŸ”Ž Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="control" href="index.html">control</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="control.precheck.Precheck" href="#control.precheck.Precheck">Precheck</a></code></h4>
<ul class="">
<li><code><a title="control.precheck.Precheck.checkEdition" href="#control.precheck.Precheck.checkEdition">checkEdition</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<a href="https://pure.knaw.nl/portal/en/persons/dirk-roorda">Dirk Roorda</a>
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>