<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>control.content API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>control.content</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/5948f0757efdfdd0b019d9d5582f265e8b31e9f2/src/pure3d/control/content.py#L1-L502" class="git-link">Browse git</a>
</summary>
<pre><code class="python">from markdown import markdown

from control.helpers.files import fileExists
from control.helpers.generic import AttrDict


COMPONENT = dict(
    me=(None, None, None, None),
    home=(&#34;texts/intro&#34;, &#34;md&#34;, True, &#34;&#34;),
    about=(&#34;texts/about&#34;, &#34;md&#34;, True, &#34;## About\n\n&#34;),
    intro=(&#34;texts/intro&#34;, &#34;md&#34;, True, &#34;&#34;),
    usage=(&#34;texts/usage&#34;, &#34;md&#34;, True, &#34;## Guide\n\n&#34;),
    description=(&#34;texts/description&#34;, &#34;md&#34;, True, &#34;## Description\n\n&#34;),
    sources=(&#34;texts/sources&#34;, &#34;md&#34;, True, &#34;## Sources\n\n&#34;),
    title=(&#34;meta/dc&#34;, &#34;json&#34;, &#34;dc.title&#34;, None),
    icon=(&#34;candy/icon&#34;, &#34;png&#34;, None, None),
    list=(None, None, None, None),
)


class Content:
    def __init__(self, Settings, Viewers, Messages, Mongo):
        &#34;&#34;&#34;Retrieving content from database and file system.

        This class has methods to retrieve various pieces of content
        from the data sources, and hand it over to the `control.pages.Pages`
        class that will compose a response out of it.

        It is instantiated by a singleton object.

        Parameters
        ----------
        Settings: `control.helpers.generic.AttrDict`
            App-wide configuration data obtained from
            `control.config.Config.Settings`.
        Viewers: object
            Singleton instance of `control.viewers.Viewers`.
        Messages: object
            Singleton instance of `control.messages.Messages`.
        Mongo: object
            Singleton instance of `control.mongo.Mongo`.
        &#34;&#34;&#34;
        self.Settings = Settings
        self.Viewers = Viewers
        self.Messages = Messages
        Messages.debugAdd(self)
        self.Mongo = Mongo

    def addAuth(self, Auth):
        &#34;&#34;&#34;Give this object a handle to the Auth object.

        Because of cyclic dependencies some objects require to be given
        a handle to Auth after their initialization.
        &#34;&#34;&#34;
        self.Auth = Auth

    def getMeta(self, nameSpace, fieldPath, projectId=None, editionId=None, asMd=False):
        &#34;&#34;&#34;Retrieve a metadata string.

        Metadata sits in a big, potentially deeply nested dictionary of keys
        and values.
        This function retrieves the information based on a path of keys.

        Parameters
        ----------
        nameSpace: string
            The first selector in the metadata, e.g. `dc` for Dublin Core.
        fieldPath: string
            A `.`-separated list of keys. This is a selector in the nested
            metadata dict selected by the `nameSpace` argument.
        projectId: ObjectId, optional None
            The project whose metadata we need. If it is None, we need metadata
            outside all of the projects.
        editionId: ObjectId, optional None
            The edition whose metadata we need. If it is None, we need metadata of
            a project or outer metadata.
        asMd: boolean, optional False
            If True, and the resulting metadata is a string, we assume that it is
            a markdown string, and we convert it to HTML.

        Returns
        -------
        string
            It is assumed that the metadata that is addressed
            by the `nameSpace` and `fieldPath` arguments exists and is a string.
            If not, we return the empty string.
        &#34;&#34;&#34;
        Mongo = self.Mongo

        fields = fieldPath.split(&#34;.&#34;)

        meta = (
            Mongo.getRecord(&#34;editions&#34;, _id=editionId)
            if editionId is not None
            else Mongo.getRecord(&#34;projects&#34;, _id=projectId)
            if projectId is not None
            else Mongo.getRecord(&#34;meta&#34;)
        ).meta or {}
        text = meta.get(nameSpace, {}).get(fields[0], &#34;&#34; if len(fields) == 0 else {})

        for field in fields[1:]:
            text = text.get(field, {})
        if type(text) is not str:
            text = &#34;&#34;
        return markdown(text) if asMd else text

    def getSurprise(self):
        &#34;&#34;&#34;Get the data that belongs to the surprise-me functionality.&#34;&#34;&#34;
        return &#34;&lt;h2&gt;You will be surprised!&lt;/h2&gt;&#34;

    def getProjects(self):
        &#34;&#34;&#34;Get the list of all projects.

        Well, the list of all projects visible to the current user.
        Unpublished projects are only visible to users that belong to that project.

        Visible projects are each displayed by means of an icon and a title.
        Both link to a landing page for the project.

        Returns
        -------
        string
            A list of captions of the projects,
            wrapped in a HTML string.
        &#34;&#34;&#34;
        Mongo = self.Mongo
        Auth = self.Auth

        wrapped = []

        for row in Mongo.execute(&#34;projects&#34;, &#34;find&#34;):
            row = AttrDict(row)
            projectId = row._id
            permitted = Auth.authorise(&#34;view&#34;, project=projectId)
            if not permitted:
                continue

            title = row.title
            candy = row.candy

            projectUrl = f&#34;/projects/{projectId}&#34;
            projectName = row.name
            iconUrlBase = f&#34;/data/projects/{projectName}/candy&#34;
            caption = self.getCaption(title, candy, projectUrl, iconUrlBase)
            wrapped.append(caption)

        return &#34;\n&#34;.join(wrapped)

    def getEditions(self, projectId):
        &#34;&#34;&#34;Get the list of the editions of a project.

        Well, only if the project is visible to the current user.
        See `Content.getProjects()`.

        Editions are each displayed by means of an icon and a title.
        Both link to a landing page for the edition.

        Parameters
        ----------
        projectId: ObjectId
            The project in question.

        Returns
        -------
        string
            A list of captions of the editions of the project,
            wrapped in a HTML string.
        &#34;&#34;&#34;
        Mongo = self.Mongo
        Auth = self.Auth

        projectInfo = Mongo.getRecord(&#34;projects&#34;, _id=projectId)
        projectName = projectInfo.name

        wrapped = []

        for row in Mongo.execute(&#34;editions&#34;, &#34;find&#34;, dict(projectId=projectId)):
            row = AttrDict(row)
            editionId = row._id
            permitted = Auth.authorise(&#34;view&#34;, project=projectId, edition=editionId)
            if not permitted:
                continue

            title = row.title
            candy = row.candy

            editionUrl = f&#34;/editions/{editionId}&#34;
            editionName = row.name
            iconUrlBase = f&#34;/data/projects/{projectName}/editions/{editionName}/candy&#34;
            caption = self.getCaption(title, candy, editionUrl, iconUrlBase)
            wrapped.append(caption)

        return &#34;\n&#34;.join(wrapped)

    def getScenes(
        self,
        projectId,
        editionId,
        sceneId=None,
        viewer=&#34;&#34;,
        version=&#34;&#34;,
        action=&#34;view&#34;,
    ):
        &#34;&#34;&#34;Get the list of the scenes of an edition of a project.

        Well, only if the project is visible to the current user.
        See `Content.getProjects()`.

        Scenes are each displayed by means of an icon a title and a row of buttons.
        The title is the file name (without the `.json` extension) of the scene.
        Both link to a landing page for the edition.

        One of the scenes is made *active*, i.e.
        it is loaded in a specific version of a viewer in a specific
        mode (`view` or `edit`).

        Which scene is loaded in which viewer and version in which mode,
        is determined by the parameters.
        If the parameters do not specify values, sensible defaults are chosen.

        Parameters
        ----------
        projectId: ObjectId
            The project in question.
        editionId: ObjectId
            The edition in question.
        sceneId: ObjectId, optional None
            The active scene. If None the default scene is chosen.
            A scene record specifies whether that scene is the default scene for
            that edition.
        viewer: string, optional &#34;&#34;
            The viewer to be used for the 3D viewing. It should be a supported viewer.
            If &#34;&#34;, the default viewer is chosen.
            The list of those viewers is in the `yaml/viewers.yml` file,
            which also specifies what the default viewer is.
        version: string, optional &#34;&#34;
            The version of the chosen viewer that will be used.
            If no version or a non-existing version are specified,
            the latest existing version for that viewer will be chosen.
        action: string, optional `&#34;view&#34;`
            The mode in which the viewer should be opened.
            If the mode is `edit`, the viewer is opened in edit mode.
            All other modes lead to the viewer being opened in read-only
            mode.

        Returns
        -------
        string
            A list of captions of the scenes of the edition,
            with one caption replaced by a 3D viewer showing the scene.
            The list is wrapped in a HTML string.
        &#34;&#34;&#34;
        Mongo = self.Mongo
        Auth = self.Auth
        Viewers = self.Viewers

        projectInfo = Mongo.getRecord(&#34;projects&#34;, _id=projectId)
        projectName = projectInfo.name
        editionInfo = Mongo.getRecord(&#34;editions&#34;, _id=editionId)
        editionName = editionInfo.name

        wrapped = []

        permitted = Auth.authorise(&#34;view&#34;, project=projectId, edition=editionId)
        if not permitted:
            return []

        action = Auth.checkModifiable(projectId, editionId, action)
        actions = [&#34;view&#34;]
        if Auth.isModifiable(projectId, editionId):
            actions.append(&#34;edit&#34;)

        (viewer, version) = Viewers.check(viewer, version)

        wrapped = []

        for row in Mongo.execute(&#34;scenes&#34;, &#34;find&#34;, dict(editionId=editionId)):
            row = AttrDict(row)

            isSceneActive = sceneId is None and row.default or row._id == sceneId
            (frame, buttons) = Viewers.getButtons(
                row._id, actions, isSceneActive, viewer, version, action
            )

            sceneUrl = f&#34;/scenes/{row._id}&#34;
            iconUrlBase = f&#34;/data/projects/{projectName}/editions/{editionName}/candy&#34;
            caption = self.getCaption(
                row.name,
                row.candy,
                sceneUrl,
                iconUrlBase,
                active=isSceneActive,
                frame=frame,
                buttons=buttons,
            )
            wrapped.append(caption)

        return &#34;\n&#34;.join(wrapped)

    def getCaption(
        self, title, candy, url, iconUrlBase, active=False, buttons=&#34;&#34;, frame=&#34;&#34;
    ):
        &#34;&#34;&#34;Get a caption for a project, edition, or scene.

        A caption consists of an icon, and a textual title, both with
        a hyperlink to the full or active version of the item.

        Parameters
        ----------
        title: string
            The textual bit of the caption.
        candy: dict
            A dictionary of visual elements to chose from.
            If one of the elements is called `icon`, that will be chosen.
        url: string
            The url to link to.
        iconUrlBase: string
            The url that almost points to the icon image file,
            only the selected name from `candy` needs to be appended to it.
        active: boolean, optional False
            Whether the caption should be displayed as being *active*.
        buttons: string, optional &#34;&#34;
            A set of buttons that should be displayed below the captions.
            This applies to captions for *scenes*: there we want to display
            buttons to open the scene in a variety of veiwers, versions and
            modes.
        frame: string, optional &#34;&#34;
            An iframe to display instead of the visual element of the caption.
            This applies to scene captions, for the case where we want to show
            the scene loaded in a viewer. That will be done in an iframe,
            and this is the HTML for that iframe.

        Returns
        -------
        string
            The HTML representing the caption.
        &#34;&#34;&#34;
        icon = self.getIcon(candy)

        activeCls = &#34;active&#34; if active else &#34;&#34;
        start = f&#34;&#34;&#34;&lt;div class=&#34;caption {activeCls}&#34;&gt;&#34;&#34;&#34;
        visual = (
            f&#34;&#34;&#34;&lt;img class=&#34;previewicon&#34; src=&#34;{iconUrlBase}/{icon}&#34;&gt;&#34;&#34;&#34; if icon else &#34;&#34;
        )
        heading = (
            f&#34;&#34;&#34;{frame}&lt;a href=&#34;{url}&#34;&gt;{title}&lt;/a&gt;&#34;&#34;&#34;
            if frame
            else f&#34;&#34;&#34;&lt;a href=&#34;{url}&#34;&gt;{visual}{title}&lt;/a&gt;&#34;&#34;&#34;
        )
        end = &#34;&#34;&#34;&lt;/div&gt;&#34;&#34;&#34;
        caption = f&#34;&#34;&#34;{start}{heading}{buttons}{end}&#34;&#34;&#34;
        return caption

    def getIcon(self, candy):
        &#34;&#34;&#34;Select an icon from a set of candidates.

        Parameters
        ----------
        candy: dict
            A set of candidates, given as a dict, keyed by file names
            (without directory information) and valued by a boolean that
            indicates whether the image may act as an icon.

        Returns
        -------
        string or None
            The first candidate in candy that is an icon.
            If there are no candidates that qualify, None is returned.
        &#34;&#34;&#34;

        if candy is None:
            return None
        first = [image for (image, isIcon) in candy.items() if isIcon]
        if first:
            return first[0]
        return None

    def getViewerFile(self, path):
        &#34;&#34;&#34;Gets a viewer-related file from the file system.

        This is about files that are part of the viewer software.

        The viewer software is located in a specific directory on the server.
        This is the viewer base.

        Parameters
        ----------
        path: string
            The path of the viewer file within viewer base.

        Returns
        -------
        string
            The contents of the viewer file, if it exists.
            Otherwise, we raise an error that will lead to a 404 response.
        &#34;&#34;&#34;
        Settings = self.Settings
        Messages = self.Messages

        dataDir = Settings.dataDir

        dataPath = f&#34;{dataDir}/viewers/{path}&#34;

        if not fileExists(dataPath):
            logmsg = f&#34;Accessing {dataPath}: &#34;
            logmsg += &#34;does not exist. &#34;
            Messages.error(
                msg=&#34;Accessing a file&#34;,
                logmsg=logmsg,
            )

        with open(dataPath, &#34;rb&#34;) as fh:
            textData = fh.read()

        return textData

    def getData(self, path, projectName=&#34;&#34;, editionName=&#34;&#34;):
        &#34;&#34;&#34;Gets a data file from the file system.

        All data files are located under a specific directory on the server.
        This is the data directory.
        Below that the files are organized by projects and editions.

        At least one of the parameters `projectName` and `editionName`
        should be present. And if `editionName` is present,
        `projectName` should also be present.

        Parameters
        ----------
        path: string
            The path of the data file within project/edition directory
            within the data directory.
        projectName: string, optional &#34;&#34;
            The name of the project in question.
        editionName: string, optional &#34;&#34;
            The name of the edition in question.

        Returns
        -------
        string
            The contents of the data file, if it exists.
            Otherwise, we raise an error that will lead to a 404 response.
        &#34;&#34;&#34;
        Settings = self.Settings
        Messages = self.Messages
        Auth = self.Auth

        dataDir = Settings.dataDir

        if (
            projectName == &#34;&#34;
            and editionName == &#34;&#34;
            or projectName == &#34;&#34;
            and editionName != &#34;&#34;
        ):
            logmsg = &#34;no project/edition specified&#34;
            Messages.error(
                msg=&#34;Accessing a file&#34;,
                logmsg=logmsg,
            )

        urlBase = (
            f&#34;projects/{projectName}&#34;
            if editionName == &#34;&#34;
            else f&#34;projects/{projectName}/editions/{editionName}&#34;
        )

        dataPath = f&#34;{dataDir}/{urlBase}/{path}&#34;

        permitted = Auth.authorise(
            &#34;view&#34;, project=projectName, edition=editionName, byName=True
        )

        fexists = fileExists(dataPath)
        if not permitted or not fexists:
            logmsg = f&#34;Accessing {dataPath}: &#34;
            if not permitted:
                logmsg = &#34;not allowed. &#34;
            if not fexists:
                logmsg += &#34;does not exist. &#34;
            Messages.error(
                msg=&#34;Accessing a file&#34;,
                logmsg=logmsg,
            )

        with open(dataPath, &#34;rb&#34;) as fh:
            textData = fh.read()

        return textData

    def getRecord(self, *args, **kwargs):
        &#34;&#34;&#34;Get a record from MongoDb.

        This is just a trivial wrapper around a method with the same
        name `control.mongo.Mongo.getRecord`.

        We have this for reasons of abstraction:
        the `control.pages.Pages` object relies
        on this Content object to retrieve content,
        and does not want to know where the content comes from.
        &#34;&#34;&#34;
        return self.Mongo.getRecord(*args, **kwargs)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="control.content.Content"><code class="flex name class">
<span>class <span class="ident">Content</span></span>
<span>(</span><span>Settings, Viewers, Messages, Mongo)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieving content from database and file system.</p>
<p>This class has methods to retrieve various pieces of content
from the data sources, and hand it over to the <code><a title="control.pages.Pages" href="pages.html#control.pages.Pages">Pages</a></code>
class that will compose a response out of it.</p>
<p>It is instantiated by a singleton object.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>Settings</code></strong> :&ensp;<code><a title="control.helpers.generic.AttrDict" href="helpers/generic.html#control.helpers.generic.AttrDict">AttrDict</a></code></dt>
<dd>App-wide configuration data obtained from
<code><a title="control.config.Config.Settings" href="config.html#control.config.Config.Settings">Config.Settings</a></code>.</dd>
<dt><strong><code>Viewers</code></strong> :&ensp;<code>object</code></dt>
<dd>Singleton instance of <code><a title="control.viewers.Viewers" href="viewers.html#control.viewers.Viewers">Viewers</a></code>.</dd>
<dt><strong><code>Messages</code></strong> :&ensp;<code>object</code></dt>
<dd>Singleton instance of <code><a title="control.messages.Messages" href="messages.html#control.messages.Messages">Messages</a></code>.</dd>
<dt><strong><code>Mongo</code></strong> :&ensp;<code>object</code></dt>
<dd>Singleton instance of <code><a title="control.mongo.Mongo" href="mongo.html#control.mongo.Mongo">Mongo</a></code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/5948f0757efdfdd0b019d9d5582f265e8b31e9f2/src/pure3d/control/content.py#L21-L502" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Content:
    def __init__(self, Settings, Viewers, Messages, Mongo):
        &#34;&#34;&#34;Retrieving content from database and file system.

        This class has methods to retrieve various pieces of content
        from the data sources, and hand it over to the `control.pages.Pages`
        class that will compose a response out of it.

        It is instantiated by a singleton object.

        Parameters
        ----------
        Settings: `control.helpers.generic.AttrDict`
            App-wide configuration data obtained from
            `control.config.Config.Settings`.
        Viewers: object
            Singleton instance of `control.viewers.Viewers`.
        Messages: object
            Singleton instance of `control.messages.Messages`.
        Mongo: object
            Singleton instance of `control.mongo.Mongo`.
        &#34;&#34;&#34;
        self.Settings = Settings
        self.Viewers = Viewers
        self.Messages = Messages
        Messages.debugAdd(self)
        self.Mongo = Mongo

    def addAuth(self, Auth):
        &#34;&#34;&#34;Give this object a handle to the Auth object.

        Because of cyclic dependencies some objects require to be given
        a handle to Auth after their initialization.
        &#34;&#34;&#34;
        self.Auth = Auth

    def getMeta(self, nameSpace, fieldPath, projectId=None, editionId=None, asMd=False):
        &#34;&#34;&#34;Retrieve a metadata string.

        Metadata sits in a big, potentially deeply nested dictionary of keys
        and values.
        This function retrieves the information based on a path of keys.

        Parameters
        ----------
        nameSpace: string
            The first selector in the metadata, e.g. `dc` for Dublin Core.
        fieldPath: string
            A `.`-separated list of keys. This is a selector in the nested
            metadata dict selected by the `nameSpace` argument.
        projectId: ObjectId, optional None
            The project whose metadata we need. If it is None, we need metadata
            outside all of the projects.
        editionId: ObjectId, optional None
            The edition whose metadata we need. If it is None, we need metadata of
            a project or outer metadata.
        asMd: boolean, optional False
            If True, and the resulting metadata is a string, we assume that it is
            a markdown string, and we convert it to HTML.

        Returns
        -------
        string
            It is assumed that the metadata that is addressed
            by the `nameSpace` and `fieldPath` arguments exists and is a string.
            If not, we return the empty string.
        &#34;&#34;&#34;
        Mongo = self.Mongo

        fields = fieldPath.split(&#34;.&#34;)

        meta = (
            Mongo.getRecord(&#34;editions&#34;, _id=editionId)
            if editionId is not None
            else Mongo.getRecord(&#34;projects&#34;, _id=projectId)
            if projectId is not None
            else Mongo.getRecord(&#34;meta&#34;)
        ).meta or {}
        text = meta.get(nameSpace, {}).get(fields[0], &#34;&#34; if len(fields) == 0 else {})

        for field in fields[1:]:
            text = text.get(field, {})
        if type(text) is not str:
            text = &#34;&#34;
        return markdown(text) if asMd else text

    def getSurprise(self):
        &#34;&#34;&#34;Get the data that belongs to the surprise-me functionality.&#34;&#34;&#34;
        return &#34;&lt;h2&gt;You will be surprised!&lt;/h2&gt;&#34;

    def getProjects(self):
        &#34;&#34;&#34;Get the list of all projects.

        Well, the list of all projects visible to the current user.
        Unpublished projects are only visible to users that belong to that project.

        Visible projects are each displayed by means of an icon and a title.
        Both link to a landing page for the project.

        Returns
        -------
        string
            A list of captions of the projects,
            wrapped in a HTML string.
        &#34;&#34;&#34;
        Mongo = self.Mongo
        Auth = self.Auth

        wrapped = []

        for row in Mongo.execute(&#34;projects&#34;, &#34;find&#34;):
            row = AttrDict(row)
            projectId = row._id
            permitted = Auth.authorise(&#34;view&#34;, project=projectId)
            if not permitted:
                continue

            title = row.title
            candy = row.candy

            projectUrl = f&#34;/projects/{projectId}&#34;
            projectName = row.name
            iconUrlBase = f&#34;/data/projects/{projectName}/candy&#34;
            caption = self.getCaption(title, candy, projectUrl, iconUrlBase)
            wrapped.append(caption)

        return &#34;\n&#34;.join(wrapped)

    def getEditions(self, projectId):
        &#34;&#34;&#34;Get the list of the editions of a project.

        Well, only if the project is visible to the current user.
        See `Content.getProjects()`.

        Editions are each displayed by means of an icon and a title.
        Both link to a landing page for the edition.

        Parameters
        ----------
        projectId: ObjectId
            The project in question.

        Returns
        -------
        string
            A list of captions of the editions of the project,
            wrapped in a HTML string.
        &#34;&#34;&#34;
        Mongo = self.Mongo
        Auth = self.Auth

        projectInfo = Mongo.getRecord(&#34;projects&#34;, _id=projectId)
        projectName = projectInfo.name

        wrapped = []

        for row in Mongo.execute(&#34;editions&#34;, &#34;find&#34;, dict(projectId=projectId)):
            row = AttrDict(row)
            editionId = row._id
            permitted = Auth.authorise(&#34;view&#34;, project=projectId, edition=editionId)
            if not permitted:
                continue

            title = row.title
            candy = row.candy

            editionUrl = f&#34;/editions/{editionId}&#34;
            editionName = row.name
            iconUrlBase = f&#34;/data/projects/{projectName}/editions/{editionName}/candy&#34;
            caption = self.getCaption(title, candy, editionUrl, iconUrlBase)
            wrapped.append(caption)

        return &#34;\n&#34;.join(wrapped)

    def getScenes(
        self,
        projectId,
        editionId,
        sceneId=None,
        viewer=&#34;&#34;,
        version=&#34;&#34;,
        action=&#34;view&#34;,
    ):
        &#34;&#34;&#34;Get the list of the scenes of an edition of a project.

        Well, only if the project is visible to the current user.
        See `Content.getProjects()`.

        Scenes are each displayed by means of an icon a title and a row of buttons.
        The title is the file name (without the `.json` extension) of the scene.
        Both link to a landing page for the edition.

        One of the scenes is made *active*, i.e.
        it is loaded in a specific version of a viewer in a specific
        mode (`view` or `edit`).

        Which scene is loaded in which viewer and version in which mode,
        is determined by the parameters.
        If the parameters do not specify values, sensible defaults are chosen.

        Parameters
        ----------
        projectId: ObjectId
            The project in question.
        editionId: ObjectId
            The edition in question.
        sceneId: ObjectId, optional None
            The active scene. If None the default scene is chosen.
            A scene record specifies whether that scene is the default scene for
            that edition.
        viewer: string, optional &#34;&#34;
            The viewer to be used for the 3D viewing. It should be a supported viewer.
            If &#34;&#34;, the default viewer is chosen.
            The list of those viewers is in the `yaml/viewers.yml` file,
            which also specifies what the default viewer is.
        version: string, optional &#34;&#34;
            The version of the chosen viewer that will be used.
            If no version or a non-existing version are specified,
            the latest existing version for that viewer will be chosen.
        action: string, optional `&#34;view&#34;`
            The mode in which the viewer should be opened.
            If the mode is `edit`, the viewer is opened in edit mode.
            All other modes lead to the viewer being opened in read-only
            mode.

        Returns
        -------
        string
            A list of captions of the scenes of the edition,
            with one caption replaced by a 3D viewer showing the scene.
            The list is wrapped in a HTML string.
        &#34;&#34;&#34;
        Mongo = self.Mongo
        Auth = self.Auth
        Viewers = self.Viewers

        projectInfo = Mongo.getRecord(&#34;projects&#34;, _id=projectId)
        projectName = projectInfo.name
        editionInfo = Mongo.getRecord(&#34;editions&#34;, _id=editionId)
        editionName = editionInfo.name

        wrapped = []

        permitted = Auth.authorise(&#34;view&#34;, project=projectId, edition=editionId)
        if not permitted:
            return []

        action = Auth.checkModifiable(projectId, editionId, action)
        actions = [&#34;view&#34;]
        if Auth.isModifiable(projectId, editionId):
            actions.append(&#34;edit&#34;)

        (viewer, version) = Viewers.check(viewer, version)

        wrapped = []

        for row in Mongo.execute(&#34;scenes&#34;, &#34;find&#34;, dict(editionId=editionId)):
            row = AttrDict(row)

            isSceneActive = sceneId is None and row.default or row._id == sceneId
            (frame, buttons) = Viewers.getButtons(
                row._id, actions, isSceneActive, viewer, version, action
            )

            sceneUrl = f&#34;/scenes/{row._id}&#34;
            iconUrlBase = f&#34;/data/projects/{projectName}/editions/{editionName}/candy&#34;
            caption = self.getCaption(
                row.name,
                row.candy,
                sceneUrl,
                iconUrlBase,
                active=isSceneActive,
                frame=frame,
                buttons=buttons,
            )
            wrapped.append(caption)

        return &#34;\n&#34;.join(wrapped)

    def getCaption(
        self, title, candy, url, iconUrlBase, active=False, buttons=&#34;&#34;, frame=&#34;&#34;
    ):
        &#34;&#34;&#34;Get a caption for a project, edition, or scene.

        A caption consists of an icon, and a textual title, both with
        a hyperlink to the full or active version of the item.

        Parameters
        ----------
        title: string
            The textual bit of the caption.
        candy: dict
            A dictionary of visual elements to chose from.
            If one of the elements is called `icon`, that will be chosen.
        url: string
            The url to link to.
        iconUrlBase: string
            The url that almost points to the icon image file,
            only the selected name from `candy` needs to be appended to it.
        active: boolean, optional False
            Whether the caption should be displayed as being *active*.
        buttons: string, optional &#34;&#34;
            A set of buttons that should be displayed below the captions.
            This applies to captions for *scenes*: there we want to display
            buttons to open the scene in a variety of veiwers, versions and
            modes.
        frame: string, optional &#34;&#34;
            An iframe to display instead of the visual element of the caption.
            This applies to scene captions, for the case where we want to show
            the scene loaded in a viewer. That will be done in an iframe,
            and this is the HTML for that iframe.

        Returns
        -------
        string
            The HTML representing the caption.
        &#34;&#34;&#34;
        icon = self.getIcon(candy)

        activeCls = &#34;active&#34; if active else &#34;&#34;
        start = f&#34;&#34;&#34;&lt;div class=&#34;caption {activeCls}&#34;&gt;&#34;&#34;&#34;
        visual = (
            f&#34;&#34;&#34;&lt;img class=&#34;previewicon&#34; src=&#34;{iconUrlBase}/{icon}&#34;&gt;&#34;&#34;&#34; if icon else &#34;&#34;
        )
        heading = (
            f&#34;&#34;&#34;{frame}&lt;a href=&#34;{url}&#34;&gt;{title}&lt;/a&gt;&#34;&#34;&#34;
            if frame
            else f&#34;&#34;&#34;&lt;a href=&#34;{url}&#34;&gt;{visual}{title}&lt;/a&gt;&#34;&#34;&#34;
        )
        end = &#34;&#34;&#34;&lt;/div&gt;&#34;&#34;&#34;
        caption = f&#34;&#34;&#34;{start}{heading}{buttons}{end}&#34;&#34;&#34;
        return caption

    def getIcon(self, candy):
        &#34;&#34;&#34;Select an icon from a set of candidates.

        Parameters
        ----------
        candy: dict
            A set of candidates, given as a dict, keyed by file names
            (without directory information) and valued by a boolean that
            indicates whether the image may act as an icon.

        Returns
        -------
        string or None
            The first candidate in candy that is an icon.
            If there are no candidates that qualify, None is returned.
        &#34;&#34;&#34;

        if candy is None:
            return None
        first = [image for (image, isIcon) in candy.items() if isIcon]
        if first:
            return first[0]
        return None

    def getViewerFile(self, path):
        &#34;&#34;&#34;Gets a viewer-related file from the file system.

        This is about files that are part of the viewer software.

        The viewer software is located in a specific directory on the server.
        This is the viewer base.

        Parameters
        ----------
        path: string
            The path of the viewer file within viewer base.

        Returns
        -------
        string
            The contents of the viewer file, if it exists.
            Otherwise, we raise an error that will lead to a 404 response.
        &#34;&#34;&#34;
        Settings = self.Settings
        Messages = self.Messages

        dataDir = Settings.dataDir

        dataPath = f&#34;{dataDir}/viewers/{path}&#34;

        if not fileExists(dataPath):
            logmsg = f&#34;Accessing {dataPath}: &#34;
            logmsg += &#34;does not exist. &#34;
            Messages.error(
                msg=&#34;Accessing a file&#34;,
                logmsg=logmsg,
            )

        with open(dataPath, &#34;rb&#34;) as fh:
            textData = fh.read()

        return textData

    def getData(self, path, projectName=&#34;&#34;, editionName=&#34;&#34;):
        &#34;&#34;&#34;Gets a data file from the file system.

        All data files are located under a specific directory on the server.
        This is the data directory.
        Below that the files are organized by projects and editions.

        At least one of the parameters `projectName` and `editionName`
        should be present. And if `editionName` is present,
        `projectName` should also be present.

        Parameters
        ----------
        path: string
            The path of the data file within project/edition directory
            within the data directory.
        projectName: string, optional &#34;&#34;
            The name of the project in question.
        editionName: string, optional &#34;&#34;
            The name of the edition in question.

        Returns
        -------
        string
            The contents of the data file, if it exists.
            Otherwise, we raise an error that will lead to a 404 response.
        &#34;&#34;&#34;
        Settings = self.Settings
        Messages = self.Messages
        Auth = self.Auth

        dataDir = Settings.dataDir

        if (
            projectName == &#34;&#34;
            and editionName == &#34;&#34;
            or projectName == &#34;&#34;
            and editionName != &#34;&#34;
        ):
            logmsg = &#34;no project/edition specified&#34;
            Messages.error(
                msg=&#34;Accessing a file&#34;,
                logmsg=logmsg,
            )

        urlBase = (
            f&#34;projects/{projectName}&#34;
            if editionName == &#34;&#34;
            else f&#34;projects/{projectName}/editions/{editionName}&#34;
        )

        dataPath = f&#34;{dataDir}/{urlBase}/{path}&#34;

        permitted = Auth.authorise(
            &#34;view&#34;, project=projectName, edition=editionName, byName=True
        )

        fexists = fileExists(dataPath)
        if not permitted or not fexists:
            logmsg = f&#34;Accessing {dataPath}: &#34;
            if not permitted:
                logmsg = &#34;not allowed. &#34;
            if not fexists:
                logmsg += &#34;does not exist. &#34;
            Messages.error(
                msg=&#34;Accessing a file&#34;,
                logmsg=logmsg,
            )

        with open(dataPath, &#34;rb&#34;) as fh:
            textData = fh.read()

        return textData

    def getRecord(self, *args, **kwargs):
        &#34;&#34;&#34;Get a record from MongoDb.

        This is just a trivial wrapper around a method with the same
        name `control.mongo.Mongo.getRecord`.

        We have this for reasons of abstraction:
        the `control.pages.Pages` object relies
        on this Content object to retrieve content,
        and does not want to know where the content comes from.
        &#34;&#34;&#34;
        return self.Mongo.getRecord(*args, **kwargs)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="control.content.Content.addAuth"><code class="name flex">
<span>def <span class="ident">addAuth</span></span>(<span>self, Auth)</span>
</code></dt>
<dd>
<div class="desc"><p>Give this object a handle to the Auth object.</p>
<p>Because of cyclic dependencies some objects require to be given
a handle to Auth after their initialization.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/5948f0757efdfdd0b019d9d5582f265e8b31e9f2/src/pure3d/control/content.py#L49-L55" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def addAuth(self, Auth):
    &#34;&#34;&#34;Give this object a handle to the Auth object.

    Because of cyclic dependencies some objects require to be given
    a handle to Auth after their initialization.
    &#34;&#34;&#34;
    self.Auth = Auth</code></pre>
</details>
</dd>
<dt id="control.content.Content.getCaption"><code class="name flex">
<span>def <span class="ident">getCaption</span></span>(<span>self, title, candy, url, iconUrlBase, active=False, buttons='', frame='')</span>
</code></dt>
<dd>
<div class="desc"><p>Get a caption for a project, edition, or scene.</p>
<p>A caption consists of an icon, and a textual title, both with
a hyperlink to the full or active version of the item.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>title</code></strong> :&ensp;<code>string</code></dt>
<dd>The textual bit of the caption.</dd>
<dt><strong><code>candy</code></strong> :&ensp;<code>dict</code></dt>
<dd>A dictionary of visual elements to chose from.
If one of the elements is called <code>icon</code>, that will be chosen.</dd>
<dt><strong><code>url</code></strong> :&ensp;<code>string</code></dt>
<dd>The url to link to.</dd>
<dt><strong><code>iconUrlBase</code></strong> :&ensp;<code>string</code></dt>
<dd>The url that almost points to the icon image file,
only the selected name from <code>candy</code> needs to be appended to it.</dd>
<dt><strong><code>active</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>Whether the caption should be displayed as being <em>active</em>.</dd>
<dt><strong><code>buttons</code></strong> :&ensp;<code>string</code>, optional <code>""</code></dt>
<dd>A set of buttons that should be displayed below the captions.
This applies to captions for <em>scenes</em>: there we want to display
buttons to open the scene in a variety of veiwers, versions and
modes.</dd>
<dt><strong><code>frame</code></strong> :&ensp;<code>string</code>, optional <code>""</code></dt>
<dd>An iframe to display instead of the visual element of the caption.
This applies to scene captions, for the case where we want to show
the scene loaded in a viewer. That will be done in an iframe,
and this is the HTML for that iframe.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>string</code></dt>
<dd>The HTML representing the caption.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/5948f0757efdfdd0b019d9d5582f265e8b31e9f2/src/pure3d/control/content.py#L300-L352" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getCaption(
    self, title, candy, url, iconUrlBase, active=False, buttons=&#34;&#34;, frame=&#34;&#34;
):
    &#34;&#34;&#34;Get a caption for a project, edition, or scene.

    A caption consists of an icon, and a textual title, both with
    a hyperlink to the full or active version of the item.

    Parameters
    ----------
    title: string
        The textual bit of the caption.
    candy: dict
        A dictionary of visual elements to chose from.
        If one of the elements is called `icon`, that will be chosen.
    url: string
        The url to link to.
    iconUrlBase: string
        The url that almost points to the icon image file,
        only the selected name from `candy` needs to be appended to it.
    active: boolean, optional False
        Whether the caption should be displayed as being *active*.
    buttons: string, optional &#34;&#34;
        A set of buttons that should be displayed below the captions.
        This applies to captions for *scenes*: there we want to display
        buttons to open the scene in a variety of veiwers, versions and
        modes.
    frame: string, optional &#34;&#34;
        An iframe to display instead of the visual element of the caption.
        This applies to scene captions, for the case where we want to show
        the scene loaded in a viewer. That will be done in an iframe,
        and this is the HTML for that iframe.

    Returns
    -------
    string
        The HTML representing the caption.
    &#34;&#34;&#34;
    icon = self.getIcon(candy)

    activeCls = &#34;active&#34; if active else &#34;&#34;
    start = f&#34;&#34;&#34;&lt;div class=&#34;caption {activeCls}&#34;&gt;&#34;&#34;&#34;
    visual = (
        f&#34;&#34;&#34;&lt;img class=&#34;previewicon&#34; src=&#34;{iconUrlBase}/{icon}&#34;&gt;&#34;&#34;&#34; if icon else &#34;&#34;
    )
    heading = (
        f&#34;&#34;&#34;{frame}&lt;a href=&#34;{url}&#34;&gt;{title}&lt;/a&gt;&#34;&#34;&#34;
        if frame
        else f&#34;&#34;&#34;&lt;a href=&#34;{url}&#34;&gt;{visual}{title}&lt;/a&gt;&#34;&#34;&#34;
    )
    end = &#34;&#34;&#34;&lt;/div&gt;&#34;&#34;&#34;
    caption = f&#34;&#34;&#34;{start}{heading}{buttons}{end}&#34;&#34;&#34;
    return caption</code></pre>
</details>
</dd>
<dt id="control.content.Content.getData"><code class="name flex">
<span>def <span class="ident">getData</span></span>(<span>self, path, projectName='', editionName='')</span>
</code></dt>
<dd>
<div class="desc"><p>Gets a data file from the file system.</p>
<p>All data files are located under a specific directory on the server.
This is the data directory.
Below that the files are organized by projects and editions.</p>
<p>At least one of the parameters <code>projectName</code> and <code>editionName</code>
should be present. And if <code>editionName</code> is present,
<code>projectName</code> should also be present.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>string</code></dt>
<dd>The path of the data file within project/edition directory
within the data directory.</dd>
<dt><strong><code>projectName</code></strong> :&ensp;<code>string</code>, optional <code>""</code></dt>
<dd>The name of the project in question.</dd>
<dt><strong><code>editionName</code></strong> :&ensp;<code>string</code>, optional <code>""</code></dt>
<dd>The name of the edition in question.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>string</code></dt>
<dd>The contents of the data file, if it exists.
Otherwise, we raise an error that will lead to a 404 response.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/5948f0757efdfdd0b019d9d5582f265e8b31e9f2/src/pure3d/control/content.py#L417-L489" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getData(self, path, projectName=&#34;&#34;, editionName=&#34;&#34;):
    &#34;&#34;&#34;Gets a data file from the file system.

    All data files are located under a specific directory on the server.
    This is the data directory.
    Below that the files are organized by projects and editions.

    At least one of the parameters `projectName` and `editionName`
    should be present. And if `editionName` is present,
    `projectName` should also be present.

    Parameters
    ----------
    path: string
        The path of the data file within project/edition directory
        within the data directory.
    projectName: string, optional &#34;&#34;
        The name of the project in question.
    editionName: string, optional &#34;&#34;
        The name of the edition in question.

    Returns
    -------
    string
        The contents of the data file, if it exists.
        Otherwise, we raise an error that will lead to a 404 response.
    &#34;&#34;&#34;
    Settings = self.Settings
    Messages = self.Messages
    Auth = self.Auth

    dataDir = Settings.dataDir

    if (
        projectName == &#34;&#34;
        and editionName == &#34;&#34;
        or projectName == &#34;&#34;
        and editionName != &#34;&#34;
    ):
        logmsg = &#34;no project/edition specified&#34;
        Messages.error(
            msg=&#34;Accessing a file&#34;,
            logmsg=logmsg,
        )

    urlBase = (
        f&#34;projects/{projectName}&#34;
        if editionName == &#34;&#34;
        else f&#34;projects/{projectName}/editions/{editionName}&#34;
    )

    dataPath = f&#34;{dataDir}/{urlBase}/{path}&#34;

    permitted = Auth.authorise(
        &#34;view&#34;, project=projectName, edition=editionName, byName=True
    )

    fexists = fileExists(dataPath)
    if not permitted or not fexists:
        logmsg = f&#34;Accessing {dataPath}: &#34;
        if not permitted:
            logmsg = &#34;not allowed. &#34;
        if not fexists:
            logmsg += &#34;does not exist. &#34;
        Messages.error(
            msg=&#34;Accessing a file&#34;,
            logmsg=logmsg,
        )

    with open(dataPath, &#34;rb&#34;) as fh:
        textData = fh.read()

    return textData</code></pre>
</details>
</dd>
<dt id="control.content.Content.getEditions"><code class="name flex">
<span>def <span class="ident">getEditions</span></span>(<span>self, projectId)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the list of the editions of a project.</p>
<p>Well, only if the project is visible to the current user.
See <code><a title="control.content.Content.getProjects" href="#control.content.Content.getProjects">Content.getProjects()</a></code>.</p>
<p>Editions are each displayed by means of an icon and a title.
Both link to a landing page for the edition.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>projectId</code></strong> :&ensp;<code>ObjectId</code></dt>
<dd>The project in question.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>string</code></dt>
<dd>A list of captions of the editions of the project,
wrapped in a HTML string.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/5948f0757efdfdd0b019d9d5582f265e8b31e9f2/src/pure3d/control/content.py#L149-L193" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getEditions(self, projectId):
    &#34;&#34;&#34;Get the list of the editions of a project.

    Well, only if the project is visible to the current user.
    See `Content.getProjects()`.

    Editions are each displayed by means of an icon and a title.
    Both link to a landing page for the edition.

    Parameters
    ----------
    projectId: ObjectId
        The project in question.

    Returns
    -------
    string
        A list of captions of the editions of the project,
        wrapped in a HTML string.
    &#34;&#34;&#34;
    Mongo = self.Mongo
    Auth = self.Auth

    projectInfo = Mongo.getRecord(&#34;projects&#34;, _id=projectId)
    projectName = projectInfo.name

    wrapped = []

    for row in Mongo.execute(&#34;editions&#34;, &#34;find&#34;, dict(projectId=projectId)):
        row = AttrDict(row)
        editionId = row._id
        permitted = Auth.authorise(&#34;view&#34;, project=projectId, edition=editionId)
        if not permitted:
            continue

        title = row.title
        candy = row.candy

        editionUrl = f&#34;/editions/{editionId}&#34;
        editionName = row.name
        iconUrlBase = f&#34;/data/projects/{projectName}/editions/{editionName}/candy&#34;
        caption = self.getCaption(title, candy, editionUrl, iconUrlBase)
        wrapped.append(caption)

    return &#34;\n&#34;.join(wrapped)</code></pre>
</details>
</dd>
<dt id="control.content.Content.getIcon"><code class="name flex">
<span>def <span class="ident">getIcon</span></span>(<span>self, candy)</span>
</code></dt>
<dd>
<div class="desc"><p>Select an icon from a set of candidates.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>candy</code></strong> :&ensp;<code>dict</code></dt>
<dd>A set of candidates, given as a dict, keyed by file names
(without directory information) and valued by a boolean that
indicates whether the image may act as an icon.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>string</code> or <code>None</code></dt>
<dd>The first candidate in candy that is an icon.
If there are no candidates that qualify, None is returned.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/5948f0757efdfdd0b019d9d5582f265e8b31e9f2/src/pure3d/control/content.py#L354-L376" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getIcon(self, candy):
    &#34;&#34;&#34;Select an icon from a set of candidates.

    Parameters
    ----------
    candy: dict
        A set of candidates, given as a dict, keyed by file names
        (without directory information) and valued by a boolean that
        indicates whether the image may act as an icon.

    Returns
    -------
    string or None
        The first candidate in candy that is an icon.
        If there are no candidates that qualify, None is returned.
    &#34;&#34;&#34;

    if candy is None:
        return None
    first = [image for (image, isIcon) in candy.items() if isIcon]
    if first:
        return first[0]
    return None</code></pre>
</details>
</dd>
<dt id="control.content.Content.getMeta"><code class="name flex">
<span>def <span class="ident">getMeta</span></span>(<span>self, nameSpace, fieldPath, projectId=None, editionId=None, asMd=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve a metadata string.</p>
<p>Metadata sits in a big, potentially deeply nested dictionary of keys
and values.
This function retrieves the information based on a path of keys.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>nameSpace</code></strong> :&ensp;<code>string</code></dt>
<dd>The first selector in the metadata, e.g. <code>dc</code> for Dublin Core.</dd>
<dt><strong><code>fieldPath</code></strong> :&ensp;<code>string</code></dt>
<dd>A <code>.</code>-separated list of keys. This is a selector in the nested
metadata dict selected by the <code>nameSpace</code> argument.</dd>
<dt><strong><code>projectId</code></strong> :&ensp;<code>ObjectId</code>, optional <code>None</code></dt>
<dd>The project whose metadata we need. If it is None, we need metadata
outside all of the projects.</dd>
<dt><strong><code>editionId</code></strong> :&ensp;<code>ObjectId</code>, optional <code>None</code></dt>
<dd>The edition whose metadata we need. If it is None, we need metadata of
a project or outer metadata.</dd>
<dt><strong><code>asMd</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>If True, and the resulting metadata is a string, we assume that it is
a markdown string, and we convert it to HTML.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>string</code></dt>
<dd>It is assumed that the metadata that is addressed
by the <code>nameSpace</code> and <code>fieldPath</code> arguments exists and is a string.
If not, we return the empty string.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/5948f0757efdfdd0b019d9d5582f265e8b31e9f2/src/pure3d/control/content.py#L57-L105" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getMeta(self, nameSpace, fieldPath, projectId=None, editionId=None, asMd=False):
    &#34;&#34;&#34;Retrieve a metadata string.

    Metadata sits in a big, potentially deeply nested dictionary of keys
    and values.
    This function retrieves the information based on a path of keys.

    Parameters
    ----------
    nameSpace: string
        The first selector in the metadata, e.g. `dc` for Dublin Core.
    fieldPath: string
        A `.`-separated list of keys. This is a selector in the nested
        metadata dict selected by the `nameSpace` argument.
    projectId: ObjectId, optional None
        The project whose metadata we need. If it is None, we need metadata
        outside all of the projects.
    editionId: ObjectId, optional None
        The edition whose metadata we need. If it is None, we need metadata of
        a project or outer metadata.
    asMd: boolean, optional False
        If True, and the resulting metadata is a string, we assume that it is
        a markdown string, and we convert it to HTML.

    Returns
    -------
    string
        It is assumed that the metadata that is addressed
        by the `nameSpace` and `fieldPath` arguments exists and is a string.
        If not, we return the empty string.
    &#34;&#34;&#34;
    Mongo = self.Mongo

    fields = fieldPath.split(&#34;.&#34;)

    meta = (
        Mongo.getRecord(&#34;editions&#34;, _id=editionId)
        if editionId is not None
        else Mongo.getRecord(&#34;projects&#34;, _id=projectId)
        if projectId is not None
        else Mongo.getRecord(&#34;meta&#34;)
    ).meta or {}
    text = meta.get(nameSpace, {}).get(fields[0], &#34;&#34; if len(fields) == 0 else {})

    for field in fields[1:]:
        text = text.get(field, {})
    if type(text) is not str:
        text = &#34;&#34;
    return markdown(text) if asMd else text</code></pre>
</details>
</dd>
<dt id="control.content.Content.getProjects"><code class="name flex">
<span>def <span class="ident">getProjects</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the list of all projects.</p>
<p>Well, the list of all projects visible to the current user.
Unpublished projects are only visible to users that belong to that project.</p>
<p>Visible projects are each displayed by means of an icon and a title.
Both link to a landing page for the project.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>string</code></dt>
<dd>A list of captions of the projects,
wrapped in a HTML string.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/5948f0757efdfdd0b019d9d5582f265e8b31e9f2/src/pure3d/control/content.py#L111-L147" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getProjects(self):
    &#34;&#34;&#34;Get the list of all projects.

    Well, the list of all projects visible to the current user.
    Unpublished projects are only visible to users that belong to that project.

    Visible projects are each displayed by means of an icon and a title.
    Both link to a landing page for the project.

    Returns
    -------
    string
        A list of captions of the projects,
        wrapped in a HTML string.
    &#34;&#34;&#34;
    Mongo = self.Mongo
    Auth = self.Auth

    wrapped = []

    for row in Mongo.execute(&#34;projects&#34;, &#34;find&#34;):
        row = AttrDict(row)
        projectId = row._id
        permitted = Auth.authorise(&#34;view&#34;, project=projectId)
        if not permitted:
            continue

        title = row.title
        candy = row.candy

        projectUrl = f&#34;/projects/{projectId}&#34;
        projectName = row.name
        iconUrlBase = f&#34;/data/projects/{projectName}/candy&#34;
        caption = self.getCaption(title, candy, projectUrl, iconUrlBase)
        wrapped.append(caption)

    return &#34;\n&#34;.join(wrapped)</code></pre>
</details>
</dd>
<dt id="control.content.Content.getRecord"><code class="name flex">
<span>def <span class="ident">getRecord</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Get a record from MongoDb.</p>
<p>This is just a trivial wrapper around a method with the same
name <code><a title="control.mongo.Mongo.getRecord" href="mongo.html#control.mongo.Mongo.getRecord">Mongo.getRecord()</a></code>.</p>
<p>We have this for reasons of abstraction:
the <code><a title="control.pages.Pages" href="pages.html#control.pages.Pages">Pages</a></code> object relies
on this Content object to retrieve content,
and does not want to know where the content comes from.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/5948f0757efdfdd0b019d9d5582f265e8b31e9f2/src/pure3d/control/content.py#L491-L502" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getRecord(self, *args, **kwargs):
    &#34;&#34;&#34;Get a record from MongoDb.

    This is just a trivial wrapper around a method with the same
    name `control.mongo.Mongo.getRecord`.

    We have this for reasons of abstraction:
    the `control.pages.Pages` object relies
    on this Content object to retrieve content,
    and does not want to know where the content comes from.
    &#34;&#34;&#34;
    return self.Mongo.getRecord(*args, **kwargs)</code></pre>
</details>
</dd>
<dt id="control.content.Content.getScenes"><code class="name flex">
<span>def <span class="ident">getScenes</span></span>(<span>self, projectId, editionId, sceneId=None, viewer='', version='', action='view')</span>
</code></dt>
<dd>
<div class="desc"><p>Get the list of the scenes of an edition of a project.</p>
<p>Well, only if the project is visible to the current user.
See <code><a title="control.content.Content.getProjects" href="#control.content.Content.getProjects">Content.getProjects()</a></code>.</p>
<p>Scenes are each displayed by means of an icon a title and a row of buttons.
The title is the file name (without the <code>.json</code> extension) of the scene.
Both link to a landing page for the edition.</p>
<p>One of the scenes is made <em>active</em>, i.e.
it is loaded in a specific version of a viewer in a specific
mode (<code>view</code> or <code>edit</code>).</p>
<p>Which scene is loaded in which viewer and version in which mode,
is determined by the parameters.
If the parameters do not specify values, sensible defaults are chosen.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>projectId</code></strong> :&ensp;<code>ObjectId</code></dt>
<dd>The project in question.</dd>
<dt><strong><code>editionId</code></strong> :&ensp;<code>ObjectId</code></dt>
<dd>The edition in question.</dd>
<dt><strong><code>sceneId</code></strong> :&ensp;<code>ObjectId</code>, optional <code>None</code></dt>
<dd>The active scene. If None the default scene is chosen.
A scene record specifies whether that scene is the default scene for
that edition.</dd>
<dt><strong><code>viewer</code></strong> :&ensp;<code>string</code>, optional <code>""</code></dt>
<dd>The viewer to be used for the 3D viewing. It should be a supported viewer.
If "", the default viewer is chosen.
The list of those viewers is in the <code>yaml/viewers.yml</code> file,
which also specifies what the default viewer is.</dd>
<dt><strong><code>version</code></strong> :&ensp;<code>string</code>, optional <code>""</code></dt>
<dd>The version of the chosen viewer that will be used.
If no version or a non-existing version are specified,
the latest existing version for that viewer will be chosen.</dd>
<dt><strong><code>action</code></strong> :&ensp;<code>string</code>, optional <code>"view"</code></dt>
<dd>The mode in which the viewer should be opened.
If the mode is <code>edit</code>, the viewer is opened in edit mode.
All other modes lead to the viewer being opened in read-only
mode.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>string</code></dt>
<dd>A list of captions of the scenes of the edition,
with one caption replaced by a 3D viewer showing the scene.
The list is wrapped in a HTML string.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/5948f0757efdfdd0b019d9d5582f265e8b31e9f2/src/pure3d/control/content.py#L195-L298" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getScenes(
    self,
    projectId,
    editionId,
    sceneId=None,
    viewer=&#34;&#34;,
    version=&#34;&#34;,
    action=&#34;view&#34;,
):
    &#34;&#34;&#34;Get the list of the scenes of an edition of a project.

    Well, only if the project is visible to the current user.
    See `Content.getProjects()`.

    Scenes are each displayed by means of an icon a title and a row of buttons.
    The title is the file name (without the `.json` extension) of the scene.
    Both link to a landing page for the edition.

    One of the scenes is made *active*, i.e.
    it is loaded in a specific version of a viewer in a specific
    mode (`view` or `edit`).

    Which scene is loaded in which viewer and version in which mode,
    is determined by the parameters.
    If the parameters do not specify values, sensible defaults are chosen.

    Parameters
    ----------
    projectId: ObjectId
        The project in question.
    editionId: ObjectId
        The edition in question.
    sceneId: ObjectId, optional None
        The active scene. If None the default scene is chosen.
        A scene record specifies whether that scene is the default scene for
        that edition.
    viewer: string, optional &#34;&#34;
        The viewer to be used for the 3D viewing. It should be a supported viewer.
        If &#34;&#34;, the default viewer is chosen.
        The list of those viewers is in the `yaml/viewers.yml` file,
        which also specifies what the default viewer is.
    version: string, optional &#34;&#34;
        The version of the chosen viewer that will be used.
        If no version or a non-existing version are specified,
        the latest existing version for that viewer will be chosen.
    action: string, optional `&#34;view&#34;`
        The mode in which the viewer should be opened.
        If the mode is `edit`, the viewer is opened in edit mode.
        All other modes lead to the viewer being opened in read-only
        mode.

    Returns
    -------
    string
        A list of captions of the scenes of the edition,
        with one caption replaced by a 3D viewer showing the scene.
        The list is wrapped in a HTML string.
    &#34;&#34;&#34;
    Mongo = self.Mongo
    Auth = self.Auth
    Viewers = self.Viewers

    projectInfo = Mongo.getRecord(&#34;projects&#34;, _id=projectId)
    projectName = projectInfo.name
    editionInfo = Mongo.getRecord(&#34;editions&#34;, _id=editionId)
    editionName = editionInfo.name

    wrapped = []

    permitted = Auth.authorise(&#34;view&#34;, project=projectId, edition=editionId)
    if not permitted:
        return []

    action = Auth.checkModifiable(projectId, editionId, action)
    actions = [&#34;view&#34;]
    if Auth.isModifiable(projectId, editionId):
        actions.append(&#34;edit&#34;)

    (viewer, version) = Viewers.check(viewer, version)

    wrapped = []

    for row in Mongo.execute(&#34;scenes&#34;, &#34;find&#34;, dict(editionId=editionId)):
        row = AttrDict(row)

        isSceneActive = sceneId is None and row.default or row._id == sceneId
        (frame, buttons) = Viewers.getButtons(
            row._id, actions, isSceneActive, viewer, version, action
        )

        sceneUrl = f&#34;/scenes/{row._id}&#34;
        iconUrlBase = f&#34;/data/projects/{projectName}/editions/{editionName}/candy&#34;
        caption = self.getCaption(
            row.name,
            row.candy,
            sceneUrl,
            iconUrlBase,
            active=isSceneActive,
            frame=frame,
            buttons=buttons,
        )
        wrapped.append(caption)

    return &#34;\n&#34;.join(wrapped)</code></pre>
</details>
</dd>
<dt id="control.content.Content.getSurprise"><code class="name flex">
<span>def <span class="ident">getSurprise</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the data that belongs to the surprise-me functionality.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/5948f0757efdfdd0b019d9d5582f265e8b31e9f2/src/pure3d/control/content.py#L107-L109" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getSurprise(self):
    &#34;&#34;&#34;Get the data that belongs to the surprise-me functionality.&#34;&#34;&#34;
    return &#34;&lt;h2&gt;You will be surprised!&lt;/h2&gt;&#34;</code></pre>
</details>
</dd>
<dt id="control.content.Content.getViewerFile"><code class="name flex">
<span>def <span class="ident">getViewerFile</span></span>(<span>self, path)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets a viewer-related file from the file system.</p>
<p>This is about files that are part of the viewer software.</p>
<p>The viewer software is located in a specific directory on the server.
This is the viewer base.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>string</code></dt>
<dd>The path of the viewer file within viewer base.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>string</code></dt>
<dd>The contents of the viewer file, if it exists.
Otherwise, we raise an error that will lead to a 404 response.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/5948f0757efdfdd0b019d9d5582f265e8b31e9f2/src/pure3d/control/content.py#L378-L415" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getViewerFile(self, path):
    &#34;&#34;&#34;Gets a viewer-related file from the file system.

    This is about files that are part of the viewer software.

    The viewer software is located in a specific directory on the server.
    This is the viewer base.

    Parameters
    ----------
    path: string
        The path of the viewer file within viewer base.

    Returns
    -------
    string
        The contents of the viewer file, if it exists.
        Otherwise, we raise an error that will lead to a 404 response.
    &#34;&#34;&#34;
    Settings = self.Settings
    Messages = self.Messages

    dataDir = Settings.dataDir

    dataPath = f&#34;{dataDir}/viewers/{path}&#34;

    if not fileExists(dataPath):
        logmsg = f&#34;Accessing {dataPath}: &#34;
        logmsg += &#34;does not exist. &#34;
        Messages.error(
            msg=&#34;Accessing a file&#34;,
            logmsg=logmsg,
        )

    with open(dataPath, &#34;rb&#34;) as fh:
        textData = fh.read()

    return textData</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<p><a href="https://github.com/CLARIAH/pure3dx" title="GitHub repo">GitHub</a></p>
<form>
<input id="lunr-search" name="q" placeholder=" Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="control" href="index.html">control</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="control.content.Content" href="#control.content.Content">Content</a></code></h4>
<ul class="two-column">
<li><code><a title="control.content.Content.addAuth" href="#control.content.Content.addAuth">addAuth</a></code></li>
<li><code><a title="control.content.Content.getCaption" href="#control.content.Content.getCaption">getCaption</a></code></li>
<li><code><a title="control.content.Content.getData" href="#control.content.Content.getData">getData</a></code></li>
<li><code><a title="control.content.Content.getEditions" href="#control.content.Content.getEditions">getEditions</a></code></li>
<li><code><a title="control.content.Content.getIcon" href="#control.content.Content.getIcon">getIcon</a></code></li>
<li><code><a title="control.content.Content.getMeta" href="#control.content.Content.getMeta">getMeta</a></code></li>
<li><code><a title="control.content.Content.getProjects" href="#control.content.Content.getProjects">getProjects</a></code></li>
<li><code><a title="control.content.Content.getRecord" href="#control.content.Content.getRecord">getRecord</a></code></li>
<li><code><a title="control.content.Content.getScenes" href="#control.content.Content.getScenes">getScenes</a></code></li>
<li><code><a title="control.content.Content.getSurprise" href="#control.content.Content.getSurprise">getSurprise</a></code></li>
<li><code><a title="control.content.Content.getViewerFile" href="#control.content.Content.getViewerFile">getViewerFile</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<a href="https://pure.knaw.nl/portal/en/persons/dirk-roorda">Dirk Roorda</a>
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>