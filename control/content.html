<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>control.content API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>control.content</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/23c61c878149a0c80bf432c2e0e320f5e806d778/src/control/content.py#L1-L1883" class="git-link">Browse git</a>
</summary>
<pre><code class="python">from io import BytesIO
import os
import json
import yaml
import magic
from tempfile import mkdtemp
from flask import jsonify
from zipfile import ZipFile, ZIP_DEFLATED
from traceback import format_exception

from control.generic import AttrDict
from control.files import (
    fileExists,
    fileRemove,
    dirExists,
    dirMake,
    dirCopy,
    dirRemove,
    extNm,
    readYaml,
)
from control.datamodel import Datamodel
from control.flask import requestData, getReferrer, redirectStatus
from control.admin import Admin
from control.checkgltf import check


class Content(Datamodel):
    def __init__(self, Settings, Messages, Viewers, Mongo, Wrap):
        &#34;&#34;&#34;Retrieving content from database and file system.

        This class has methods to retrieve various pieces of content
        from the data sources, and hand it over to the `control.pages.Pages`
        class that will compose a response out of it.

        It is instantiated by a singleton object.

        Parameters
        ----------
        Settings: AttrDict
            App-wide configuration data obtained from
            `control.config.Config.Settings`.
        Viewers: object
            Singleton instance of `control.viewers.Viewers`.
        Messages: object
            Singleton instance of `control.messages.Messages`.
        Mongo: object
            Singleton instance of `control.mongo.Mongo`.
        Wrap: object
            Singleton instance of `control.wrap.Wrap`.
        &#34;&#34;&#34;
        super().__init__(Settings, Messages, Mongo)
        self.Viewers = Viewers
        self.Wrap = Wrap

    def addAuth(self, Auth):
        &#34;&#34;&#34;Give this object a handle to the Auth object.

        Because of cyclic dependencies some objects require to be given
        a handle to Auth after their initialization.
        &#34;&#34;&#34;
        self.Auth = Auth

    def addPublish(self, Publish):
        &#34;&#34;&#34;Give this object a handle to the Publish object.

        Because of cyclic dependencies some objects require to be given
        a handle to Publish after their initialization.
        &#34;&#34;&#34;
        self.Publish = Publish

    def getSurprise(self):
        &#34;&#34;&#34;Get the data that belongs to the surprise-me functionality.&#34;&#34;&#34;
        Settings = self.Settings
        H = Settings.H
        return H.h(2, &#34;You will be surprised!&#34;)

    def getProjects(self):
        &#34;&#34;&#34;Get the list of all projects.

        Well, the list of all projects visible to the current user.
        Unpublished projects are only visible to users that belong to that project.

        Visible projects are each displayed by means of an icon and a title.
        Both link to a landing page for the project.

        Returns
        -------
        string
            A list of captions of the projects,
            wrapped in a HTML string.
        &#34;&#34;&#34;
        Mongo = self.Mongo
        Wrap = self.Wrap

        (siteTable, siteId, site) = self.relevant()
        if siteId is None:
            return &#34;&#34;

        return Wrap.projectsMain(site, Mongo.getList(&#34;project&#34;, sort=&#34;title&#34;))

    def getEditions(self, project):
        &#34;&#34;&#34;Get the list of the editions of a project.

        Well, only if the project is visible to the current user.
        See `Content.getProjects()`.

        Editions are each displayed by means of an icon and a title.
        Both link to a landing page for the edition.

        Parameters
        ----------
        project: string | ObjectId | AttrDict
            The project in question.

        Returns
        -------
        string
            A list of captions of the editions of the project,
            wrapped in a HTML string.
        &#34;&#34;&#34;
        Mongo = self.Mongo
        Wrap = self.Wrap

        (projectId, project) = Mongo.get(&#34;project&#34;, project)
        if projectId is None:
            return &#34;&#34;

        return Wrap.editionsMain(
            project, Mongo.getList(&#34;edition&#34;, sort=&#34;title&#34;, projectId=projectId)
        )

    def getScene(self, projectId, edition, version=None, action=None):
        &#34;&#34;&#34;Get the scene of an edition of a project.

        Well, only if the current user is authorised.

        A scene is displayed by means of an icon and a row of buttons.

        There are also buttons to upload model files and the scene file.

        If action is not None, the scene is loaded in a specific version of the
        viewer in a specific mode (`read` or `edit`).
        The edition knows which viewer to choose.

        Which version and which mode are used is determined by the parameters.
        If the parameters do not specify values, sensible defaults are chosen.

        Parameters
        ----------
        projectId: ObjectId
            The id of the project to which the edition belongs.
        edition: string | ObjectId | AttrDict
            The edition in question.
        version: string, optional None
            The version of the chosen viewer that will be used.
            If no version or a non-existing version are specified,
            the latest existing version for that viewer will be chosen.
        action: string, optional read
            The mode in which the viewer should be opened.
            If the mode is `update`, the viewer is opened in edit mode, if the
            scene file exists, otherwise in create mode,  which, in case
            of the Voyager viewer, means `dragdrop` mode, in older versions
            `standalone`.
            All other modes lead to the viewer being opened in read-only
            mode.
            If the mode is read-only, but the scene file is missing, no viewer
            will be opened.

        Returns
        -------
        string
            A caption of the scene of the edition,
            with possibly a frame with the 3D viewer showing the scene.
            The result is wrapped in a HTML string.
        &#34;&#34;&#34;
        Settings = self.Settings
        H = Settings.H
        workingDir = Settings.workingDir
        modelzFile = Settings.modelzFile
        Mongo = self.Mongo
        Viewers = self.Viewers
        Wrap = self.Wrap

        (editionId, edition) = Mongo.get(&#34;edition&#34;, edition)
        if editionId is None:
            return &#34;&#34;

        (viewer, sceneFile) = Viewers.getViewInfo(edition)
        version = Viewers.check(viewer, version)

        if sceneFile is None:
            sceneExists = False
            baseResult = &#34;&#34;
        else:
            scenePath = (
                f&#34;{workingDir}/project/{projectId}/edition/{editionId}/{sceneFile}&#34;
            )
            sceneExists = fileExists(scenePath)
            baseResult = Wrap.sceneMain(
                projectId, edition, sceneFile, viewer, version, action, sceneExists
            )

        if action is None:
            action = &#34;read&#34;

        zipUpload = (
            &#34;&#34;
            if sceneExists or sceneFile is None
            else (
                H.h(4, &#34;Scene plus model files, zipped&#34;)
                + H.div(self.getUpload(edition, &#34;modelz&#34;, fileName=modelzFile))
            )
        )
        sceneUpload = (
            &#34;&#34;
            if sceneFile is None
            else H.div(self.getUpload(edition, &#34;scene&#34;, fileName=sceneFile))
        )

        return (
            baseResult
            + H.h(4, &#34;Scene&#34; if sceneExists else &#34;No scene yet&#34;)
            + sceneUpload
            + H.h(4, &#34;Model files&#34;)
            + H.div(self.getUpload(edition, &#34;model&#34;))
            + zipUpload
        )

    def getAdmin(self):
        &#34;&#34;&#34;Get the list of relevant projects, editions and users.

        Admin users get the list of all users.

        Normal users get the list of users associated with

        * the project of which they are organiser
        * the editions of which they are editor or reviewer

        Guests and not-logged-in users cannot see any user.

        If the user has rights to modify the association
        between users and projects/editions, he will get
        the controls to do so.

        Returns
        -------
        string
        &#34;&#34;&#34;
        return Admin(self).wrap()

    def createProject(self, site):
        &#34;&#34;&#34;Creates a new project.

        Parameters
        ----------
        site: AttrDict | string
            record that represents the site, or its id.
            It acts as a master record for all projects.

        Returns
        -------
        ObjectId
            The id of the new project.
        &#34;&#34;&#34;
        Settings = self.Settings
        Messages = self.Messages
        Mongo = self.Mongo
        Auth = self.Auth
        workingDir = Settings.workingDir

        (siteId, site) = Mongo.get(&#34;site&#34;, site)
        if siteId is None:
            return None

        permitted = Auth.authorise(&#34;site&#34;, site, action=&#34;create&#34;, insertTable=&#34;project&#34;)
        if not permitted:
            return None

        User = Auth.myDetails()
        user = User.user
        name = User.nickname

        title = &#34;Project without title&#34;

        dcMeta = dict(
            title=title,
            description=dict(abstract=&#34;No intro&#34;, description=&#34;No description&#34;),
            creator=name,
        )
        projectId = Mongo.insertRecord(
            &#34;project&#34;, title=title, meta=dict(dc=dcMeta), isVisible=False
        )
        Mongo.insertRecord(
            &#34;projectUser&#34;, projectId=projectId, user=user, role=&#34;organiser&#34;
        )
        projectDir = f&#34;{workingDir}/project/{projectId}&#34;
        if dirExists(projectDir):
            Messages.warning(
                msg=&#34;The new project already exists on the file system&#34;,
                logmsg=f&#34;New project {projectId} already exists on the filesystem.&#34;,
            )
        else:
            dirMake(projectDir)

        return projectId

    def deleteItem(self, table, record):
        &#34;&#34;&#34;Deletes an item, project or edition.

        Parameters
        ----------
        table: string
            The kind of item: `project` or `edition`.
        record: string | ObjectId | AttrDict
            The item in question.

        Returns
        -------
        boolean
            Whether the deletion was successful.
        &#34;&#34;&#34;
        Settings = self.Settings
        Messages = self.Messages
        Mongo = self.Mongo
        Auth = self.Auth
        workingDir = Settings.workingDir

        (recordId, record) = Mongo.get(table, record)
        if recordId is None:
            Messages.warning(
                msg=f&#34;Delete {table}: no such {table}&#34;,
                logmsg=f&#34;Delete {table}: no {table} {recordId}&#34;,
            )
            return None

        permitted = Auth.authorise(table, record, action=&#34;delete&#34;)
        if not permitted:
            return None

        details = self.getDetailRecords(table, record)
        nDetails = len(details)
        if nDetails:
            Messages.warning(
                msg=f&#34;Cannot delete {table} because it has {nDetails} detail records&#34;,
                logmsg=f&#34;Delete {table} {recordId} prevented: {nDetails} details&#34;,
            )
            return None

        good = True

        links = self.getLinkedCrit(table, record)

        if links:
            for linkTable, linkCriteria in links.items():
                (thisGood, count) = Mongo.deleteRecords(
                    linkTable, stop=False, **linkCriteria
                )
                if not thisGood:
                    good = False
                    Messages.error(
                        stop=False,
                        msg=f&#34;Error during removing link records from {linkTable}&#34;,
                        logmsg=(
                            &#34;Cannot delete records from &#34;
                            f&#34;{linkTable} by {linkCriteria}&#34;
                        ),
                    )
                    break

                Messages.info(
                    msg=f&#34;Deleted {count} link records from {linkTable}&#34;,
                    logmsg=f&#34;Deleted {count} link records from {linkTable}&#34;,
                )

        if not good:
            return False

        good = Mongo.deleteRecord(table, _id=recordId)

        if not good:
            return False

        itemDirHead = workingDir
        itemDirTail = f&#34;{table}/{recordId}&#34;
        if table == &#34;edition&#34;:
            projectId = record.projectId
            itemDirHead += f&#34;/project/{projectId}&#34;
        itemDir = f&#34;{itemDirHead}/{itemDirTail}&#34;

        if dirExists(itemDir):
            dirRemove(itemDir)
            Messages.info(
                msg=f&#34;The {table} directory is removed&#34;,
                logmsg=f&#34;The {table} dir {itemDir} is removed&#34;,
            )
        else:
            Messages.warning(
                msg=f&#34;The {table} directory on file system did not exist&#34;,
                logmsg=f&#34;The {table} dir {itemDir} did not exist&#34;,
            )

        return True

    def createEdition(self, project):
        &#34;&#34;&#34;Creates a new edition.

        Parameters
        ----------
        project: AttrDict | string
            record that represents the maste project, or its id.

        Returns
        -------
        ObjectId
            The id of the new edition.
        &#34;&#34;&#34;
        Mongo = self.Mongo
        Messages = self.Messages
        Auth = self.Auth
        Settings = self.Settings
        workingDir = Settings.workingDir

        def fillin(template, values):
            typ = type(template)
            if typ is str:
                for k, v in values.items():
                    template = template.replace(f&#34;«{k}»&#34;, v)
                return template
            if typ in {list, tuple}:
                return [fillin(e, values) for e in template]
            if typ in {dict, AttrDict}:
                return {k: fillin(v, values) for (k, v) in template.items()}
            return template

        editionSettingsTemplate = Settings.editionSettingsTemplate
        viewerDefault = Settings.viewerDefault
        viewerInfo = Settings.viewers[viewerDefault] or AttrDict()
        versionDefault = viewerInfo.defaultVersion
        sceneFile = viewerInfo.sceneFile

        values = dict(viewer=viewerDefault, version=versionDefault, scene=sceneFile)
        editionSettings = fillin(editionSettingsTemplate, values)

        (projectId, project) = Mongo.get(&#34;project&#34;, project)
        if projectId is None:
            return None

        permitted = Auth.authorise(
            &#34;project&#34;, project, action=&#34;create&#34;, insertTable=&#34;edition&#34;
        )
        if not permitted:
            return None

        User = Auth.myDetails()
        user = User.user
        name = User.nickname

        title = &#34;Edition without title&#34;

        dcMeta = dict(
            title=title,
            description=dict(
                abstract=&#34;No intro&#34;,
                description=&#34;No description&#34;,
                provenance=&#34;No sources&#34;,
            ),
            creator=name,
        )
        editionId = Mongo.insertRecord(
            &#34;edition&#34;,
            title=title,
            projectId=projectId,
            meta=dict(dc=dcMeta),
            settings=editionSettings,
            isPublished=False,
        )
        Mongo.insertRecord(&#34;editionUser&#34;, editionId=editionId, user=user, role=&#34;editor&#34;)

        editionDir = f&#34;{workingDir}/project/{projectId}/edition/{editionId}&#34;
        if dirExists(editionDir):
            Messages.warning(
                msg=&#34;The new edition already exists on the file system&#34;,
                logmsg=f&#34;New edition {editionId} already exists on the filesystem.&#34;,
            )
        else:
            dirMake(editionDir)

        return editionId

    def saveValue(self, table, record, key):
        &#34;&#34;&#34;Saves a value of into a record.

        A record is a document, which is a (nested) dict.
        A value is inserted somewhere (deep) in that dict.

        The value is given by the request.

        Where exactly is given by a path that is stored in the field information,
        which is accessible by the key.

        Parameters
        ----------
        table: string
            The relevant table.
        record: string | ObjectId | AttrDict | void
            The relevant record.

        key: string
            an identifier for the meta data field.

        Returns
        -------
        dict
            Contains the following keys:

            * `status`: whether the save action was successful
            * `messages`: messages issued during the process
            * `readonly`: the html of the updated formatted value,
              this will replace the currently displayed value.
        &#34;&#34;&#34;
        Auth = self.Auth
        Mongo = self.Mongo

        value = json.loads(requestData())
        permitted = Auth.authorise(table, record, action=&#34;update&#34;)

        if not permitted:
            return dict(stat=False, messages=[[&#34;error&#34;, &#34;update not allowed&#34;]])

        F = self.makeField(key)

        nameSpace = F.nameSpace
        fieldPath = F.fieldPath
        tp = F.tp

        (recordId, record) = Mongo.get(table, record)
        if recordId is None:
            return dict(
                stat=False,
                messages=[[&#34;error&#34;, &#34;record does not exist&#34;]],
            )

        sValue = value if tp == &#34;text&#34; else readYaml(value, plain=True, ignore=True)
        nameSpaceRep = &#34;&#34; if not nameSpace else f&#34;{nameSpace}.&#34;
        update = {f&#34;{nameSpaceRep}{fieldPath}&#34;: sValue}
        if key == &#34;title&#34;:
            update[key] = sValue

        if Mongo.updateRecord(table, update, stop=False, _id=recordId) is None:
            return dict(
                stat=False,
                messages=[[&#34;error&#34;, &#34;could not update the record in the database&#34;]],
            )
        else:
            (recordId, record) = Mongo.get(table, recordId)

        return dict(
            stat=True,
            messages=[],
            readonly=F.formatted(table, record, editable=False, level=None),
        )

    def saveRole(self, user, table, recordId):
        &#34;&#34;&#34;Saves a role into a user or cross table record.

        The role is given by the request.

        Parameters
        ----------
        user: string
            The eppn of the user.
        table: string | void
            The relevant table. If not None, it indicates whether we are updating
            site-wide roles, otherwise project/edition roles.
        recordId: string | void
            The id of the relevant record. If not None, it is a project/edition
            record Id, which can be used to locate the cross record between the
            user table and the project/edition record where the user&#39;s
            role is stored.
            If None, the user&#39;s role is inside the user record.

        Returns
        -------
        dict
            Contains the following keys:

            * `status`: whether the save action was successful
            * `messages`: messages issued during the process
            * `updated`: if the action was successful, all user management info
              will be passed back and will replace the currently displayed
              material.
        &#34;&#34;&#34;
        newRole = json.loads(requestData())
        return Admin(self).saveRole(user, newRole, table, recordId)

    def createUser(self, user):
        &#34;&#34;&#34;Creates a new user with a given user name.

        Parameters
        ----------
        user: string
            The user name of the user.
            This should be different from the user names of existing users.

        Returns
        -------
        dict
            Contains the following keys:

            * `status`: whether the create action was successful
            * `messages`: messages issued during the process
            * `name`: the name under which the new user has been saved
        &#34;&#34;&#34;
        return Admin(self).createUser(user)

    def deleteUser(self, user):
        &#34;&#34;&#34;Deletes a test user with a given user name.

        Parameters
        ----------
        user: string
            The user name of the user.
            This should be a test user, not linked to any project or edition.

        Returns
        -------
        dict
            Contains the following keys:

            * `status`: whether the create action was successful
            * `messages`: messages issued during the process
        &#34;&#34;&#34;
        return Admin(self).deleteUser(user)

    def linkUser(self, table, recordId):
        &#34;&#34;&#34;Links a user in certain role to a project/edition record.

        The user and role are given by the request.

        Parameters
        ----------
        table: string
            The relevant table.
        recordId: string
            The id of the relevant record,
            which can be used to locate the cross record between the
            user table and the project/edition record where the user&#39;s
            role is stored.

        Returns
        -------
        dict
            Contains the following keys:

            * `status`: whether the save action was successful
            * `messages`: messages issued during the process
            * `updated`: if the action was successful, all user management info
              will be passed back and will replace the currently displayed
              material.
        &#34;&#34;&#34;
        (newRole, newUser) = json.loads(requestData())
        return Admin(self).linkUser(newUser, newRole, table, recordId)

    def getValue(self, table, record, key, level=None, manner=&#34;formatted&#34;):
        &#34;&#34;&#34;Retrieve a metadata value.

        Metadata sits in a big, potentially deeply nested dictionary of keys
        and values.
        These locations are known to the system (based on `fields.yml`).
        This function retrieves the information from those known locations.

        If a value is in fact composed of multiple values, it will be
        handled accordingly.

        If the user may edit the value, an edit button is added.

        Parameters
        ----------
        key: string
            an identifier for the meta data field.
        table: string
            The relevant table.
        record: string | ObjectId | AttrDict | void
            The relevant record.
        level: string, optional None
            The heading level with which the value should be formatted.

            * `0`: No heading level
            * `None`: no formatting at all

        manner: string, optional wrapped
            If it is &#34;formatted&#34;, the value is represented fully wrapped in HTML,
            possibly with edit/save controls.
            If it is &#34;bare&#34;, the value is represented as a simple string.
            If it is &#34;logical&#34;, the logical value is returned.

        Returns
        -------
        string
            It is assumed that the metadata value that is addressed exists.
            If not, we return the empty string.
        &#34;&#34;&#34;
        Auth = self.Auth

        actions = Auth.authorise(table, record)

        if &#34;read&#34; not in actions:
            return None

        F = self.makeField(key)

        isBare = manner == &#34;bare&#34;
        isLogical = manner == &#34;logical&#34;

        if isBare or isLogical:
            return (F.bare if isBare else F.logical)(record)

        editable = Auth.authorise(table, record, action=&#34;update&#34;)
        return F.formatted(table, record, editable=editable, level=level)

    def getValues(self, table, record, fieldSpecs):
        &#34;&#34;&#34;Puts several pieces of metadata on the web page.

        Parameters
        ----------
        fieldSpecs: string
            `,`-separated list of fieldSpecs
        table: string
            The relevant table
        record: string | ObjectId | AttrDict | void
            The relevant record

        Returns
        -------
        string
            The join of the individual results of retrieving metadata value.
        &#34;&#34;&#34;
        Settings = self.Settings
        H = Settings.H

        return H.content(
            self.getValue(table, record, key, level=level) or &#34;&#34;
            for (key, level) in (
                fieldSpec.strip().split(&#34;@&#34;, 1) for fieldSpec in fieldSpecs.split(&#34;+&#34;)
            )
        )

    def getUpload(self, record, key, fileName=None, bust=None, wrapped=True):
        &#34;&#34;&#34;Display the name and/or upload controls of an uploaded file.

        The user may upload model files and a scene file to an edition,
        and various png files as icons for projects, edtions, and scenes.
        Here we produce the control to do so.

        Only if the user has `update` authorisation, an upload/delete widget
        will be returned.

        Parameters
        ----------
        record: string | ObjectId | AttrDict | void
            The relevant record.
        key: string
            an identifier for the upload field.
        fileName: string, optional None
            If present, it indicates that the uploaded file will have this prescribed
            name.
            A file name for an upload object may also have been specified in
            the datamodel configuration.
        bust: string, optional None
            If not None, the image url of the file whose name is passed in
            `bust` is made unique by adding the current time to it. That will
            bust the cache for the image, so that uploaded images replace the
            existing images.

            This is useful when this function is called to provide udated
            content for an file upload widget after it has been used to
            successfully upload a file. The file name of the uploaded
            file is known, and that is the one that gets a cache buster appended.
        wrapped: boolean, optional True
            Whether the content should be wrapped in a container element.
            See `control.html.HtmlElements.finput()`.

        Returns
        -------
        string
            The name of the file that is currently present, or the indication
            that no file is present.

            If the user has edit permission for the edition, we display
            widgets to upload a new file or to delete the existing file.
        &#34;&#34;&#34;
        Auth = self.Auth

        uploadConfig = self.getUploadConfig(key)
        table = uploadConfig.table

        actions = Auth.authorise(table, record)

        if &#34;read&#34; not in actions:
            return None

        F = self.makeUpload(key, fileName=fileName)

        return F.formatted(record, &#34;update&#34; in actions, bust=bust, wrapped=wrapped)

    def getDownload(self, table, record):
        &#34;&#34;&#34;Display the name and/or upload controls of an uploaded file.

        The user may upload model files and a scene file to an edition,
        and various png files as icons for projects, edtions, and scenes.
        Here we produce the control to do so.

        Only if the user has `update` authorisation, an upload/delete widget
        will be returned.

        Parameters
        ----------
        table: string
            The table in which the relevant record sits
        record: string | ObjectId | AttrDict
            The relevant record.

        Returns
        -------
        string
            The name of the file that is currently present, or the indication
            that no file is present.

            If the user has edit permission for the edition, we display
            widgets to upload a new file or to delete the existing file.
        &#34;&#34;&#34;
        Settings = self.Settings
        H = Settings.H
        Mongo = self.Mongo
        Auth = self.Auth

        (recordId, record) = Mongo.get(table, record)
        if recordId is None:
            return &#34;&#34;

        actions = Auth.authorise(table, record)

        if &#34;read&#34; not in actions:
            return &#34;&#34;

        return H.iconx(
            &#34;download&#34;, text=&#34;download&#34;, href=f&#34;/download/{table}/{recordId}&#34;
        )

    def getPublishInfo(self, table, record):
        &#34;&#34;&#34;Display the number under which a project/edition is published.

        Editions of a project may have been published. If that is the case,
        the project has been assigned a sequence number, under which it can be
        found on the static site with published material.

        Here we collect that number, and, for editions, we may put a publish
        button here.

        Parameters
        ----------
        table: string
            The table in which the relevant record sits
        record: string | ObjectId | AttrDict
            The relevant record.

        Returns
        -------
        string
            In case of a project: the number of the project on the static site.
            In case of an edition: the number of the project and the number of the
            edition on the static site. If the edition is not yet published, and
            the user is allowed to publish the edition, then a publish button is
            also added.
        &#34;&#34;&#34;
        Settings = self.Settings

        H = Settings.H
        Mongo = self.Mongo
        Auth = self.Auth

        pubUrl = Settings.pubUrl
        published = Settings.published

        (recordId, record) = Mongo.get(table, record)
        if recordId is None:
            return &#34;&#34;

        actions = Auth.authorise(table, record)

        if &#34;read&#34; not in actions or table not in {&#34;project&#34;, &#34;edition&#34;}:
            return &#34;&#34;

        (site, siteId, projectId, project, editionId, edition) = self.context(
            table, record
        )

        pPubNum = project.pubNum

        projectPubStr = (
            H.i(&#34;No published editions&#34;)
            if pPubNum is None
            else H.span(&#34;Published: &#34;)
            + H.a(
                f&#34;{pPubNum} ⌲&#34;,
                f&#34;{pubUrl}/project/{pPubNum}/index.html&#34;,
                target=published,
                cls=&#34;button large&#34;,
            )
        )

        if table == &#34;project&#34;:
            return H.p(projectPubStr)

        ePubNum = edition.pubNum

        editionPubRow = (
            (
                H.i(&#34;Not published&#34;)
                if ePubNum is None or pPubNum is None
                else H.span(&#34;Published: &#34;)
            ),
            H.a(
                f&#34;{pPubNum}/{ePubNum} ⌲&#34;,
                f&#34;{pubUrl}/project/{pPubNum}/edition/{ePubNum}/index.html&#34;,
                target=published,
                cls=&#34;button large&#34;,
            ),
        )

        can = dict(
            precheck=True,
            publish=ePubNum is None,
            unpublish=pPubNum is not None and ePubNum is not None,
            republish=pPubNum is not None and ePubNum is not None,
        )

        rows = []

        for kind, kindRep, tbRecRoles in (
            (
                &#34;precheck&#34;,
                &#34;check articles&#34;,
                (
                    (&#34;edition&#34;, edition, &#34;editor&#34;),
                    (&#34;project&#34;, project, &#34;organiser&#34;),
                    (&#34;site&#34;, site, &#34;admin&#34;),
                    (&#34;site&#34;, site, &#34;root&#34;),
                ),
            ),
            (&#34;publish&#34;, &#34;publish&#34;, ((&#34;project&#34;, project, &#34;organiser&#34;),)),
            (
                (&#34;publishf&#34;, &#34;publish&#34;),
                &#34;force-publish&#34;,
                ((&#34;project&#34;, project, &#34;organiser&#34;),),
            ),
            (
                &#34;republish&#34;,
                &#34;re-publish&#34;,
                ((&#34;site&#34;, site, &#34;admin&#34;), (&#34;site&#34;, site, &#34;root&#34;)),
            ),
            (
                (&#34;republishf&#34;, &#34;republish&#34;),
                &#34;force-re-publish&#34;,
                ((&#34;site&#34;, site, &#34;admin&#34;), (&#34;site&#34;, site, &#34;root&#34;)),
            ),
            (
                &#34;unpublish&#34;,
                &#34;un-publish&#34;,
                ((&#34;site&#34;, site, &#34;admin&#34;), (&#34;site&#34;, site, &#34;root&#34;)),
            ),
        ):
            asKind = kind

            if type(kind) is tuple:
                (kind, asKind) = kind

            if can[asKind]:
                rows.append(
                    (
                        H.span(f&#34;You may {kindRep}:&#34;),
                        H.iconx(
                            kind,
                            href=f&#34;/{kind}/{recordId}&#34;,
                            cls=&#34;button large&#34;,
                        ),
                    )
                    if asKind in actions
                    else (
                        H.span(f&#34;You may not {kindRep}&#34;),
                        Auth.getInvolvedUsers(tbRecRoles, asString=True),
                    )
                )

        return H.table(
            [([(cell, {}) for cell in editionPubRow], {})],
            [([(cell, {}) for cell in row], {}) for row in rows],
        )

    def getViewerFile(self, path):
        &#34;&#34;&#34;Gets a viewer-related file from the file system.

        This is about files that are part of the viewer software.

        The viewer software is located in a specific directory on the server.
        This is the viewer base.

        Parameters
        ----------
        path: string
            The path of the viewer file within viewer base.

        Returns
        -------
        string
            The full path to the viewer file, if it exists.
            Otherwise, we raise an error that will lead to a 404 response.
        &#34;&#34;&#34;
        Settings = self.Settings
        Messages = self.Messages

        viewerDir = Settings.viewerDir

        viewerPath = f&#34;{viewerDir}/{path}&#34;

        if not fileExists(viewerPath):
            logmsg = f&#34;Accessing {viewerPath}: &#34;
            logmsg += &#34;does not exist. &#34;
            Messages.error(
                msg=&#34;Accessing a file&#34;,
                logmsg=logmsg,
            )

        return viewerPath

    def getDataFile(self, table, record, path, content=False, lenient=False):
        &#34;&#34;&#34;Gets a data file from the file system.

        All data files are located under a specific directory on the server.
        This is the data directory.
        Below that the files are organized by projects and editions.
        Projects and editions corresponds to records in tables in MongoDB.

        Parameters
        ----------
        path: string
            The path of the data file within site/project/edition directory
            within the data directory.
        project: string | ObjectId | AttrDict
            The id of the project in question.
        edition: string | ObjectId | AttrDict
            The id of the edition in question.
        content: boolean, optional False
            If True, delivers the content of the file, instead of the path
        lenient: boolean, optional False
            If True, do not complain if the file does not exist.

        Returns
        -------
        string
            The full path of the data file, if it exists.
            But if the `content` parameter is True, we deliver the content of the file.

            Otherwise, we raise an error that will lead to a 404 response, except
            when `lenient` is True.

        &#34;&#34;&#34;
        Settings = self.Settings
        H = Settings.H
        Messages = self.Messages
        Auth = self.Auth

        workingDir = Settings.workingDir

        (site, siteId, projectId, project, editionId, edition) = self.context(
            table, record
        )

        urlBase = (
            &#34;&#34;
            if project is None
            else f&#34;project/{projectId}&#34;
            if edition is None
            else f&#34;project/{projectId}/edition/{editionId}&#34;
        )
        sep = &#34;/&#34; if urlBase else &#34;&#34;
        base = f&#34;{workingDir}{sep}{urlBase}&#34;

        dataPath = base if path is None else f&#34;{base}/{path}&#34;

        (table, recordId, record) = self.relevant(project=project, edition=edition)
        if recordId is None:
            Messages.error(msg=&#34;record does not exist&#34;)
            return &#34;&#34;

        permitted = Auth.authorise(table, record, action=&#34;read&#34;)

        fexists = fileExists(dataPath)

        if permitted and fexists:
            if content:
                with open(dataPath) as fh:
                    result = fh.read()
            else:
                result = dataPath
        else:
            result = (
                &#34;&#34;
                if content
                else dataPath
                if lenient
                else H.span(dataPath, cls=&#34;error&#34;)
            )

            if not lenient:
                logmsg = f&#34;Accessing {dataPath}: &#34;

                if not permitted:
                    logmsg += &#34;not allowed. &#34;
                if not fexists:
                    logmsg += &#34;does not exist. &#34;

                Messages.error(
                    msg=f&#34;Accessing file {path}&#34;,
                    logmsg=logmsg,
                )
                result = &#34;&#34; if content else dataPath

        return result

    def breadCrumb(self, project):
        &#34;&#34;&#34;Makes a link to the landing page of a project.

        Parameters
        ----------
        project: string | ObjectId | AttrDict
            The project in question.
        &#34;&#34;&#34;
        Settings = self.Settings
        H = Settings.H
        Mongo = self.Mongo

        (projectId, project) = Mongo.get(&#34;project&#34;, project)
        if not project:
            return &#34;&#34;

        projectUrl = f&#34;/project/{projectId}&#34;
        text = self.getValue(&#34;project&#34;, project, &#34;title&#34;, manner=&#34;bare&#34;)
        if not text:
            text = H.i(&#34;no title&#34;)

        return H.p(
            [
                &#34;Project: &#34;,
                H.a(
                    text,
                    projectUrl,
                    cls=&#34;button&#34;,
                    title=&#34;back to the project page&#34;,
                ),
            ]
        )

    def precheck(self, record):
        &#34;&#34;&#34;Check the articles of an edition prior to publishing.

        Parameters
        ----------
        record: string
            The record of the edition to be checked.

        Return
        ------
        response
            A status response.

            It will also generate a a bunch of toc files in the edition.
        &#34;&#34;&#34;
        Messages = self.Messages
        Mongo = self.Mongo
        Auth = self.Auth
        Publish = self.Publish

        (recordId, record) = Mongo.get(&#34;edition&#34;, record)
        if recordId is None:
            Messages.error(
                msg=&#34;record does not exist&#34;, logmsg=f&#34;edition {recordId} does not exist&#34;
            )
            return False

        permitted = Auth.authorise(&#34;edition&#34;, record, action=&#34;precheck&#34;)

        if not permitted:
            logmsg = f&#34;Checking articles not permitted: edition: {recordId}&#34;
            msg = &#34;Checking articles of edition not permitted&#34;
            Messages.warning(msg=msg, logmsg=logmsg)
            return False

        (siteId, site, projectId, project, editionId, edition) = self.context(
            &#34;edition&#34;, record
        )

        return Publish.Precheck.checkEdition(project, editionId, edition)

    def publish(self, record, force):
        &#34;&#34;&#34;Publish an edition.

        Parameters
        ----------
        record: string
            The record of the item to be published.
        force: boolean
            If True, ignore when some checks fail

        Return
        ------
        response
            A publish status response.
        &#34;&#34;&#34;
        Messages = self.Messages
        Mongo = self.Mongo
        Auth = self.Auth
        Publish = self.Publish

        (recordId, record) = Mongo.get(&#34;edition&#34;, record)
        if recordId is None:
            Messages.error(
                msg=&#34;record does not exist&#34;, logmsg=f&#34;edition {recordId} does not exist&#34;
            )
            return False

        permitted = Auth.authorise(&#34;edition&#34;, record, action=&#34;publish&#34;)

        if not permitted:
            logmsg = f&#34;Publish not permitted: edition: {recordId}&#34;
            msg = &#34;Publishing of edition not permitted&#34;
            Messages.warning(msg=msg, logmsg=logmsg)
            return False

        (siteId, site, projectId, project, editionId, edition) = self.context(
            &#34;edition&#34;, record
        )

        return Publish.updateEdition(site, project, edition, &#34;add&#34;, force=force)

    def republish(self, record, force):
        &#34;&#34;&#34;Re-ublish an edition.

        Parameters
        ----------
        record: string
            The record of the item to be re-published.
        force: boolean
            If True, ignore when some checks fail

        Return
        ------
        response
            A re-publish status response.
        &#34;&#34;&#34;
        Messages = self.Messages
        Mongo = self.Mongo
        Auth = self.Auth
        Publish = self.Publish

        (recordId, record) = Mongo.get(&#34;edition&#34;, record)
        if recordId is None:
            Messages.error(
                msg=&#34;record does not exist&#34;, logmsg=f&#34;edition {recordId} does not exist&#34;
            )
            return False

        permitted = Auth.authorise(&#34;edition&#34;, record, action=&#34;republish&#34;)

        if not permitted:
            logmsg = f&#34;Re-publish not permitted: edition: {recordId}&#34;
            msg = &#34;Re-publishing of edition not permitted&#34;
            Messages.warning(msg=msg, logmsg=logmsg)
            return False

        (siteId, site, projectId, project, editionId, edition) = self.context(
            &#34;edition&#34;, record
        )

        return Publish.updateEdition(
            site, project, edition, &#34;add&#34;, force=force, again=True
        )

    def unpublish(self, record):
        &#34;&#34;&#34;Unpublish an edition.

        Parameters
        ----------
        record: string
            The record of the item to be unpublished.

        Return
        ------
        response
            An unpublish status response.
        &#34;&#34;&#34;
        Messages = self.Messages
        Mongo = self.Mongo
        Auth = self.Auth
        Publish = self.Publish

        (recordId, record) = Mongo.get(&#34;edition&#34;, record)
        if recordId is None:
            Messages.error(
                msg=&#34;record does not exist&#34;, logmsg=f&#34;edition {recordId} does not exist&#34;
            )
            return False

        permitted = Auth.authorise(&#34;edition&#34;, record, action=&#34;unpublish&#34;)

        if not permitted:
            logmsg = f&#34;Unpublish not permitted: edition: {recordId}&#34;
            msg = &#34;Unpublishing of edition not permitted&#34;
            Messages.warning(msg=msg, logmsg=logmsg)
            return False

        (siteId, site, projectId, project, editionId, edition) = self.context(
            &#34;edition&#34;, record
        )

        return Publish.updateEdition(site, project, edition, &#34;remove&#34;)

    def generate(self):
        &#34;&#34;&#34;Regenerate the HTML for the published site.

        Return
        ------
        response
            A publish status response.
        &#34;&#34;&#34;
        Messages = self.Messages
        Auth = self.Auth
        Publish = self.Publish

        site = self.relevant()[-1]
        permitted = Auth.authorise(&#34;site&#34;, site, action=&#34;republish&#34;)

        if not permitted:
            logmsg = &#34;Generate pages is not permitted&#34;
            msg = &#34;Generate pages is not permitted&#34;
            Messages.warning(msg=msg, logmsg=logmsg)
            return False

        return Publish.generatePages(None, None)

    def download(self, table, record):
        &#34;&#34;&#34;Responds with a download of a project or edition.

        Parameters
        ----------
        table: string
            The table where the item to be downloaded sits.
        record: string
            The record of the item to be downloaded.

        Return
        ------
        response
            A download response.
        &#34;&#34;&#34;
        Settings = self.Settings
        Messages = self.Messages
        Mongo = self.Mongo
        Auth = self.Auth
        dataDir = Settings.dataDir
        workingDir = Settings.workingDir
        runMode = Settings.runMode

        (recordId, record) = Mongo.get(table, record)
        if recordId is None:
            return jsonify(status=False, msgs=[[&#34;warning&#34;, &#34;record does not exist&#34;]])

        permitted = Auth.authorise(table, record, action=&#34;read&#34;)

        if not permitted:
            logmsg = f&#34;Download not permitted: {table}: {recordId}&#34;
            msg = f&#34;Download of {table} not permitted&#34;
            Messages.warning(logmsg=logmsg)
            return jsonify(status=False, msgs=[[&#34;warning&#34;, msg]])

        (siteId, site, projectId, project, editionId, edition) = self.context(
            table, record
        )

        src = f&#34;{workingDir}/project/{projectId}&#34;

        if edition is not None:
            src += f&#34;/edition/{editionId}&#34;

        sep = &#34;/&#34; if dataDir else &#34;&#34;
        tempBase = f&#34;{dataDir}{sep}temp/{runMode}&#34;
        dirMake(tempBase)
        dst = mkdtemp(dir=tempBase)
        Messages.info(logmsg=f&#34;CREATED TEMP DIR {dst}&#34;)

        good = True

        try:
            landing = f&#34;{dst}/{recordId}&#34;
            fileName = f&#34;{table}-{recordId}.zip&#34;

            if edition is None:
                yamlDest = f&#34;{landing}/project.yaml&#34;
            else:
                yamlDest = f&#34;{landing}/edition.yaml&#34;

            dirCopy(src, landing)

            with open(yamlDest, &#34;w&#34;) as yh:
                yaml.dump(Mongo.consolidate(project), yh, allow_unicode=True)

            if edition is None:
                editions = Mongo.getList(&#34;edition&#34;, sort=&#34;title&#34;, projectId=projectId)

                for ed in editions:
                    edId = ed._id
                    yamlDest = f&#34;{landing}/edition/{edId}/edition.yaml&#34;

                    with open(yamlDest, &#34;w&#34;) as yh:
                        yaml.dump(Mongo.consolidate(ed), yh, allow_unicode=True)

            zipBuffer = BytesIO()

            with ZipFile(zipBuffer, &#34;w&#34;, compression=ZIP_DEFLATED) as zipFile:

                def compress(path):
                    sep = &#34;/&#34; if path else &#34;&#34;
                    with os.scandir(f&#34;{landing}{sep}{path}&#34;) as dh:
                        for entry in dh:
                            name = entry.name
                            if entry.is_file():
                                arcFile = f&#34;{path}{sep}{name}&#34;
                                srcFile = f&#34;{landing}/{arcFile}&#34;
                                zipFile.write(srcFile, arcFile)
                            elif entry.is_dir():
                                compress(f&#34;{path}/{name}&#34;)

                compress(&#34;&#34;)

            zipData = zipBuffer.getvalue()
            Messages.info(msg=f&#34;{table} downloaded&#34;)

        except Exception as e:
            msg = &#34;Could not assemble the data for download&#34;
            Messages.error(msg=msg, logmsg=msg)
            Messages.error(logmsg=&#34;&#34;.join(format_exception(e)), stop=False)
            good = False

        dirRemove(dst)
        Messages.info(logmsg=f&#34;DELETED TEMP DIR {dst}&#34;)

        if good:
            headers = {
                &#34;Expires&#34;: &#34;0&#34;,
                &#34;Cache-Control&#34;: &#34;no-cache, no-store, must-revalidate&#34;,
                &#34;Content-Type&#34;: &#34;application/zip&#34;,
                &#34;Content-Disposition&#34;: f&#39;attachment; filename=&#34;{fileName}&#34;&#39;,
                &#34;Content-Encoding&#34;: &#34;identity&#34;,
            }

            return (zipData, headers)

        else:
            ref = getReferrer().removeprefix(&#34;/&#34;)
            return redirectStatus(f&#34;/{ref}&#34;, False)

    def saveFile(self, record, key, path, fileName, targetFileName=None):
        &#34;&#34;&#34;Saves a file in the context given by a record.

        The parameter `key` refers to a configuration section in the datamodel.
        This determines what file type to expect.
        We only accept files whose name has an extension that matches the expected
        file type.

        The key `modelz` expects a zip file with the files of an edition, in particular
        a scene file and model files. We make sure that these files have the
        proper type, and we also perform checks on the other parts of the zip file,
        namely whether they have decent paths.

        Parameters
        ----------
        record: string | ObjectId | AttrDict | void
            The relevant record.
        key: string
            The upload key
        path: string
            The path from the context directory to the file
        fileName: string
            Name  of the file to be saved as mentioned in the request.
        targetFileName: string, optional None
            The name of the file as which the uploaded file will be saved;
            if None, the file will be saved with the name from the request.

        Return
        ------
        response
            A json response with the status of the save operation:

            * a boolean: whether the save succeeded
            * a list of messages to display
            * content: new content for an upload control (only if successful)
        &#34;&#34;&#34;
        fileContent = requestData()  # essential to have this early on in the body
        # if not, the error responses might go wrong in some browsers

        Settings = self.Settings
        H = Settings.H
        Messages = self.Messages
        Mongo = self.Mongo
        Auth = self.Auth
        workingDir = Settings.workingDir

        uploadConfig = self.getUploadConfig(key)
        table = uploadConfig.table

        (recordId, record) = Mongo.get(table, record)
        if recordId is None:
            return jsonify(status=False, msgs=[[&#34;warning&#34;, &#34;record does not exist&#34;]])

        permitted = Auth.authorise(table, record, action=&#34;update&#34;)

        saveName = fileName

        if targetFileName is not None:
            saveName = targetFileName

        filePath = f&#34;{path}{saveName}&#34;
        fileFullPath = f&#34;{workingDir}/{filePath}&#34;

        if not permitted:
            logmsg = f&#34;Upload not permitted: {key}: {fileFullPath}&#34;
            msg = f&#34;Upload not permitted: {fileName}&#34;
            Messages.warning(logmsg=logmsg)
            return jsonify(status=False, msgs=[[&#34;warning&#34;, msg]])

        (good, msgs) = self.checkFileContent(key, targetFileName, fileName, fileContent)

        if not good:
            return jsonify(status=False, msgs=msgs)

        if key == &#34;modelz&#34;:
            destDir = f&#34;{workingDir}/{path}&#34;
            (good, msgs) = self.processModelZip(fileContent, destDir)
            if good:
                return jsonify(
                    status=True,
                    msgs=msgs,
                    content=H.b(&#34;Please refresh the page&#34;, cls=&#34;good&#34;),
                )
            return jsonify(status=False, msgs=msgs)

        try:
            with open(fileFullPath, &#34;wb&#34;) as fh:
                fh.write(fileContent)
        except Exception:
            logmsg = f&#34;Could not save uploaded file: {key}: {fileFullPath}&#34;
            msg = f&#34;Uploaded file not saved: {fileName}&#34;
            Messages.warning(logmsg=logmsg)
            return jsonify(status=False, msgs=[[&#34;warning&#34;, msg]])

        content = self.getUpload(
            record, key, fileName=targetFileName, bust=fileName, wrapped=False
        )

        return jsonify(status=True, msgs=[[&#34;good&#34;, &#34;Done&#34;]], content=content)

    def checkFileContent(self, key, targetFileName, fileName, fileContent):
        &#34;&#34;&#34;Performs checks on the name and content of an uploaded file before saving it.

        Parameters
        ----------
        key: string
            The key of the upload. This key determines what kind of file we expect.
            If None, we do not expect a particular mime type
        targetFileName: string
            The prescribed name to save the file under, if None, it will be saved under
            the name mentioned in the request.
        fileName: string
            The name of the file as mentioned in the request.
        fileContent: bytes
            The content of the file as bytes

        Returns
        -------
        tuple
            A boolean that tells whether the file content looks OK plus a sequences of
            messages indicating what is wrong with the content.
        &#34;&#34;&#34;
        Settings = self.Settings
        datamodel = Settings.datamodel
        mimeTypes = datamodel.mimeTypes
        uploadConfig = self.getUploadConfig(key) or AttrDict()
        acceptStr = uploadConfig.accept
        accept = (
            None
            if acceptStr is None
            else {acc[1:].strip() for acc in acceptStr.split(&#34;,&#34;)}
        )

        good = True
        msgs = []

        fileExt = extNm(fileName)

        if targetFileName is not None:
            targetExt = extNm(targetFileName)

            if targetExt != fileExt:
                good = False
                msgs.append(
                    [
                        &#34;error&#34;,
                        (
                            f&#34;the uploaded file name {fileName} has an extension &#34;
                            &#34;different from that of the target &#34;
                            f&#34;file name {targetFileName}&#34;
                        ),
                    ]
                )

            if accept is not None and targetExt not in accept:
                good = False
                msgs.append(
                    [
                        &#34;error&#34;,
                        (
                            &#34;Programming error: the prescribed file name &#34;
                            f&#34;{targetFileName} has an extension not in {acceptStr}&#34;
                        ),
                    ]
                )
                return (good, msgs)

            fileName = targetFileName
            fileExt = extNm(fileName)

        if accept is not None and fileExt not in accept:
            good = False
            msgs.append(
                (
                    &#34;error&#34;,
                    (
                        f&#34;the uploaded file name {fileName} has an extension &#34;
                        f&#34;not in {acceptStr}&#34;
                    ),
                )
            )
            return (good, msgs)

        if fileExt == &#34;gltf&#34;:
            (thisGood, messages) = check(fileContent)
            if thisGood:
                mimeType = &#34;model/gltf+json&#34;
            else:
                good = False
                msgs.extend([(&#34;error&#34;, msg) for msg in messages])
                mimeType = None
        else:
            mimeType = magic.from_buffer(fileContent, mime=True)
            if mimeType is None:
                good = False
                msgs.append(
                    (
                        &#34;error&#34;,
                        (
                            f&#34;could not determined the mime type of {fileName} &#34;
                            &#34;based on its uploaded content&#34;
                        ),
                    )
                )

        if mimeType is not None:
            if (
                fileExt not in mimeTypes.get(mimeType, [])
                and mimeType.split(&#34;/&#34;, 1)[-1].split(&#34;+&#34;, 1)[0].lower()
                != fileExt.lower()
            ):
                good = False
                msgs.append(
                    (
                        &#34;error&#34;,
                        (
                            f&#34;the uploaded file content of {mimeType} file &#34;
                            f&#34;{fileName} does not fit its extension {fileExt}&#34;
                        ),
                    )
                )

        return (good, msgs)

    def processModelZip(self, zf, destDir):
        &#34;&#34;&#34;Processes zip data with a scene and model files.

        All files in the zip file will be examined, and those with
        extension svx.json will be saved as scene.svx.json at top level
        and those with extensions glb of gltf will be saved under their
        own names, also at top level.

        All other files will be saved as is, unless they have extension .svx.json,
        or .gltf or .glb.

        These files can end up in subdirectories.

        We do not check the file types of the member files other than the svx.json files
        and the model files (glb, gltf).
        If the file type for these files does not match their extensions, they will be
        ignored.

        The user is held responsible to submit a suitable file.

        Parameters
        ----------
        zf: bytes
            The raw zip data
        &#34;&#34;&#34;
        Messages = self.Messages

        msgs = []
        good = True

        try:
            zf = BytesIO(zf)
            z = ZipFile(zf)

            allFiles = 0
            sceneFiles = set()
            modelFiles = set()
            otherFiles = set()

            goodFiles = []

            for zInfo in z.infolist():
                if zInfo.filename[-1] == &#34;/&#34;:
                    continue
                if zInfo.filename.startswith(&#34;__MACOS&#34;):
                    continue

                allFiles += 1

                zName = zInfo.filename
                zPath = zName.split(&#34;/&#34;)

                if len(zPath) == 1:
                    zDir, zFile = &#34;&#34;, zPath[0]
                else:
                    zDir = &#34;/&#34;.join(zPath[0:-1])
                    zFile = zPath[-1]

                zTest = zFile.lower()
                doFileTypeCheck = False

                if zTest.endswith(&#34;.svx.json&#34;):
                    if zDir == &#34;&#34;:
                        sceneFiles.add(zName)
                        doFileTypeCheck = True
                    else:
                        msgs.append(
                            (&#34;warning&#34;, f&#34;ignoring non-toplevel scene file {zName}&#34;)
                        )
                        continue
                elif zTest.endswith(&#34;.glb&#34;) or zTest.endswith(&#34;.gltf&#34;):
                    if zDir == &#34;&#34;:
                        modelFiles.add(zName)
                        doFileTypeCheck = True
                    else:
                        msgs.append(
                            (&#34;warning&#34;, f&#34;ignoring non-toplevel model file {zName}&#34;)
                        )
                        continue
                else:
                    otherFiles.add(zName)

                if doFileTypeCheck:
                    fileContent = z.read(zInfo)
                    (thisGood, theseMsgs) = self.checkFileContent(
                        None, None, zFile, fileContent
                    )
                    if thisGood:
                        goodFiles.append((zName, fileContent))
                    else:
                        good = False
                        msgs.extend(theseMsgs)
                else:
                    goodFiles.append((zInfo, None))

            if good:
                for zName, fileContent in goodFiles:
                    if fileContent is None:
                        z.extract(zName, path=destDir)
                    else:
                        with open(f&#34;{destDir}/{zName}&#34;, mode=&#34;wb&#34;) as fh:
                            fh.write(fileContent)

            nScenes = len(sceneFiles)
            sLabel = &#34;info&#34; if nScenes == 1 else &#34;warning&#34;
            msgs.append((&#34;info&#34;, f&#34;All files in zip: {allFiles:&gt;3}&#34;))
            msgs.append((sLabel, f&#34;Scene files: {nScenes:&gt;3} x&#34;))
            msgs.append((&#34;info&#34;, f&#34;Model files: {len(modelFiles):&gt;3} x&#34;))
            msgs.append((&#34;info&#34;, f&#34;Other files: {len(otherFiles):&gt;3} x&#34;))

        except Exception as e:
            good = False
            msgs.append((&#34;error&#34;, &#34;Something went wrong&#34;))
            Messages.warning(logmsg=str(e))

        return (good, msgs)

    def deleteFile(self, record, key, path, fileName, targetFileName=None):
        &#34;&#34;&#34;Deletes a file in the context given by a record.

        Parameters
        ----------
        record: string | ObjectId | AttrDict | void
            The relevant record.
        key: string
            The upload key
        path: string
            The path from the context directory to the file
        fileName: string
            Name  of the file to be saved as mentioned in the request.
        targetFileName: string, optional None
            The name of the file as which the uploaded file will be saved;
            if None, the file will be saved with the name from the request.

        Return
        ------
        response
            A json response with the status of the save operation:

            * a boolean: whether the save succeeded
            * a message: messages to display
            * content: new content for an upload control (only if successful)
        &#34;&#34;&#34;
        Settings = self.Settings
        Messages = self.Messages
        Mongo = self.Mongo
        Auth = self.Auth
        workingDir = Settings.workingDir

        uploadConfig = self.getUploadConfig(key)
        table = uploadConfig.table

        (recordId, record) = Mongo.get(table, record)
        if recordId is None:
            return jsonify(status=False, msgs=[[&#34;warning&#34;, &#34;record does not exist&#34;]])

        permitted = Auth.authorise(table, record, action=&#34;update&#34;)

        sep = &#34;/&#34; if path else &#34;&#34;
        filePath = f&#34;{path}{sep}{fileName}&#34;
        fileFullPath = f&#34;{workingDir}/{filePath}&#34;

        if not permitted:
            logmsg = f&#34;Delete file not permitted: {key}: {fileFullPath}&#34;
            msg = f&#34;Delete not permitted: {fileName}&#34;
            Messages.warning(logmsg=logmsg)
            return jsonify(status=False, msgs=[[&#34;warning&#34;, msg]])

        if not fileExists(fileFullPath):
            logmsg = f&#34;File does not exist: {key}: {fileFullPath}&#34;
            msg = f&#34;File does not exist: {fileName}&#34;
            Messages.warning(logmsg=logmsg)
            return jsonify(status=False, msgs=[[&#34;warning&#34;, msg]])

        try:
            fileRemove(fileFullPath)
        except Exception:
            logmsg = f&#34;Could not delete file: {key}: {fileFullPath}&#34;
            msg = f&#34;File not deleted: {fileName}&#34;
            Messages.warning(logmsg=logmsg)
            return jsonify(status=False, msgs=[[&#34;error&#34;, msg]])

        content = self.getUpload(
            record, key, fileName=targetFileName, bust=fileName, wrapped=False
        )

        return jsonify(status=True, msgs=[[&#34;good&#34;, &#34;Done&#34;]], content=content)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="control.content.Content"><code class="flex name class">
<span>class <span class="ident">Content</span></span>
<span>(</span><span>Settings, Messages, Viewers, Mongo, Wrap)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieving content from database and file system.</p>
<p>This class has methods to retrieve various pieces of content
from the data sources, and hand it over to the <code><a title="control.pages.Pages" href="pages.html#control.pages.Pages">Pages</a></code>
class that will compose a response out of it.</p>
<p>It is instantiated by a singleton object.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>Settings</code></strong> :&ensp;<code>AttrDict</code></dt>
<dd>App-wide configuration data obtained from
<code><a title="control.config.Config.Settings" href="config.html#control.config.Config.Settings">Config.Settings</a></code>.</dd>
<dt><strong><code>Viewers</code></strong> :&ensp;<code>object</code></dt>
<dd>Singleton instance of <code><a title="control.viewers.Viewers" href="viewers.html#control.viewers.Viewers">Viewers</a></code>.</dd>
<dt><strong><code>Messages</code></strong> :&ensp;<code>object</code></dt>
<dd>Singleton instance of <code><a title="control.messages.Messages" href="messages.html#control.messages.Messages">Messages</a></code>.</dd>
<dt><strong><code>Mongo</code></strong> :&ensp;<code>object</code></dt>
<dd>Singleton instance of <code><a title="control.mongo.Mongo" href="mongo.html#control.mongo.Mongo">Mongo</a></code>.</dd>
<dt><strong><code>Wrap</code></strong> :&ensp;<code>object</code></dt>
<dd>Singleton instance of <code><a title="control.wrap.Wrap" href="wrap.html#control.wrap.Wrap">Wrap</a></code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/23c61c878149a0c80bf432c2e0e320f5e806d778/src/control/content.py#L28-L1883" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Content(Datamodel):
    def __init__(self, Settings, Messages, Viewers, Mongo, Wrap):
        &#34;&#34;&#34;Retrieving content from database and file system.

        This class has methods to retrieve various pieces of content
        from the data sources, and hand it over to the `control.pages.Pages`
        class that will compose a response out of it.

        It is instantiated by a singleton object.

        Parameters
        ----------
        Settings: AttrDict
            App-wide configuration data obtained from
            `control.config.Config.Settings`.
        Viewers: object
            Singleton instance of `control.viewers.Viewers`.
        Messages: object
            Singleton instance of `control.messages.Messages`.
        Mongo: object
            Singleton instance of `control.mongo.Mongo`.
        Wrap: object
            Singleton instance of `control.wrap.Wrap`.
        &#34;&#34;&#34;
        super().__init__(Settings, Messages, Mongo)
        self.Viewers = Viewers
        self.Wrap = Wrap

    def addAuth(self, Auth):
        &#34;&#34;&#34;Give this object a handle to the Auth object.

        Because of cyclic dependencies some objects require to be given
        a handle to Auth after their initialization.
        &#34;&#34;&#34;
        self.Auth = Auth

    def addPublish(self, Publish):
        &#34;&#34;&#34;Give this object a handle to the Publish object.

        Because of cyclic dependencies some objects require to be given
        a handle to Publish after their initialization.
        &#34;&#34;&#34;
        self.Publish = Publish

    def getSurprise(self):
        &#34;&#34;&#34;Get the data that belongs to the surprise-me functionality.&#34;&#34;&#34;
        Settings = self.Settings
        H = Settings.H
        return H.h(2, &#34;You will be surprised!&#34;)

    def getProjects(self):
        &#34;&#34;&#34;Get the list of all projects.

        Well, the list of all projects visible to the current user.
        Unpublished projects are only visible to users that belong to that project.

        Visible projects are each displayed by means of an icon and a title.
        Both link to a landing page for the project.

        Returns
        -------
        string
            A list of captions of the projects,
            wrapped in a HTML string.
        &#34;&#34;&#34;
        Mongo = self.Mongo
        Wrap = self.Wrap

        (siteTable, siteId, site) = self.relevant()
        if siteId is None:
            return &#34;&#34;

        return Wrap.projectsMain(site, Mongo.getList(&#34;project&#34;, sort=&#34;title&#34;))

    def getEditions(self, project):
        &#34;&#34;&#34;Get the list of the editions of a project.

        Well, only if the project is visible to the current user.
        See `Content.getProjects()`.

        Editions are each displayed by means of an icon and a title.
        Both link to a landing page for the edition.

        Parameters
        ----------
        project: string | ObjectId | AttrDict
            The project in question.

        Returns
        -------
        string
            A list of captions of the editions of the project,
            wrapped in a HTML string.
        &#34;&#34;&#34;
        Mongo = self.Mongo
        Wrap = self.Wrap

        (projectId, project) = Mongo.get(&#34;project&#34;, project)
        if projectId is None:
            return &#34;&#34;

        return Wrap.editionsMain(
            project, Mongo.getList(&#34;edition&#34;, sort=&#34;title&#34;, projectId=projectId)
        )

    def getScene(self, projectId, edition, version=None, action=None):
        &#34;&#34;&#34;Get the scene of an edition of a project.

        Well, only if the current user is authorised.

        A scene is displayed by means of an icon and a row of buttons.

        There are also buttons to upload model files and the scene file.

        If action is not None, the scene is loaded in a specific version of the
        viewer in a specific mode (`read` or `edit`).
        The edition knows which viewer to choose.

        Which version and which mode are used is determined by the parameters.
        If the parameters do not specify values, sensible defaults are chosen.

        Parameters
        ----------
        projectId: ObjectId
            The id of the project to which the edition belongs.
        edition: string | ObjectId | AttrDict
            The edition in question.
        version: string, optional None
            The version of the chosen viewer that will be used.
            If no version or a non-existing version are specified,
            the latest existing version for that viewer will be chosen.
        action: string, optional read
            The mode in which the viewer should be opened.
            If the mode is `update`, the viewer is opened in edit mode, if the
            scene file exists, otherwise in create mode,  which, in case
            of the Voyager viewer, means `dragdrop` mode, in older versions
            `standalone`.
            All other modes lead to the viewer being opened in read-only
            mode.
            If the mode is read-only, but the scene file is missing, no viewer
            will be opened.

        Returns
        -------
        string
            A caption of the scene of the edition,
            with possibly a frame with the 3D viewer showing the scene.
            The result is wrapped in a HTML string.
        &#34;&#34;&#34;
        Settings = self.Settings
        H = Settings.H
        workingDir = Settings.workingDir
        modelzFile = Settings.modelzFile
        Mongo = self.Mongo
        Viewers = self.Viewers
        Wrap = self.Wrap

        (editionId, edition) = Mongo.get(&#34;edition&#34;, edition)
        if editionId is None:
            return &#34;&#34;

        (viewer, sceneFile) = Viewers.getViewInfo(edition)
        version = Viewers.check(viewer, version)

        if sceneFile is None:
            sceneExists = False
            baseResult = &#34;&#34;
        else:
            scenePath = (
                f&#34;{workingDir}/project/{projectId}/edition/{editionId}/{sceneFile}&#34;
            )
            sceneExists = fileExists(scenePath)
            baseResult = Wrap.sceneMain(
                projectId, edition, sceneFile, viewer, version, action, sceneExists
            )

        if action is None:
            action = &#34;read&#34;

        zipUpload = (
            &#34;&#34;
            if sceneExists or sceneFile is None
            else (
                H.h(4, &#34;Scene plus model files, zipped&#34;)
                + H.div(self.getUpload(edition, &#34;modelz&#34;, fileName=modelzFile))
            )
        )
        sceneUpload = (
            &#34;&#34;
            if sceneFile is None
            else H.div(self.getUpload(edition, &#34;scene&#34;, fileName=sceneFile))
        )

        return (
            baseResult
            + H.h(4, &#34;Scene&#34; if sceneExists else &#34;No scene yet&#34;)
            + sceneUpload
            + H.h(4, &#34;Model files&#34;)
            + H.div(self.getUpload(edition, &#34;model&#34;))
            + zipUpload
        )

    def getAdmin(self):
        &#34;&#34;&#34;Get the list of relevant projects, editions and users.

        Admin users get the list of all users.

        Normal users get the list of users associated with

        * the project of which they are organiser
        * the editions of which they are editor or reviewer

        Guests and not-logged-in users cannot see any user.

        If the user has rights to modify the association
        between users and projects/editions, he will get
        the controls to do so.

        Returns
        -------
        string
        &#34;&#34;&#34;
        return Admin(self).wrap()

    def createProject(self, site):
        &#34;&#34;&#34;Creates a new project.

        Parameters
        ----------
        site: AttrDict | string
            record that represents the site, or its id.
            It acts as a master record for all projects.

        Returns
        -------
        ObjectId
            The id of the new project.
        &#34;&#34;&#34;
        Settings = self.Settings
        Messages = self.Messages
        Mongo = self.Mongo
        Auth = self.Auth
        workingDir = Settings.workingDir

        (siteId, site) = Mongo.get(&#34;site&#34;, site)
        if siteId is None:
            return None

        permitted = Auth.authorise(&#34;site&#34;, site, action=&#34;create&#34;, insertTable=&#34;project&#34;)
        if not permitted:
            return None

        User = Auth.myDetails()
        user = User.user
        name = User.nickname

        title = &#34;Project without title&#34;

        dcMeta = dict(
            title=title,
            description=dict(abstract=&#34;No intro&#34;, description=&#34;No description&#34;),
            creator=name,
        )
        projectId = Mongo.insertRecord(
            &#34;project&#34;, title=title, meta=dict(dc=dcMeta), isVisible=False
        )
        Mongo.insertRecord(
            &#34;projectUser&#34;, projectId=projectId, user=user, role=&#34;organiser&#34;
        )
        projectDir = f&#34;{workingDir}/project/{projectId}&#34;
        if dirExists(projectDir):
            Messages.warning(
                msg=&#34;The new project already exists on the file system&#34;,
                logmsg=f&#34;New project {projectId} already exists on the filesystem.&#34;,
            )
        else:
            dirMake(projectDir)

        return projectId

    def deleteItem(self, table, record):
        &#34;&#34;&#34;Deletes an item, project or edition.

        Parameters
        ----------
        table: string
            The kind of item: `project` or `edition`.
        record: string | ObjectId | AttrDict
            The item in question.

        Returns
        -------
        boolean
            Whether the deletion was successful.
        &#34;&#34;&#34;
        Settings = self.Settings
        Messages = self.Messages
        Mongo = self.Mongo
        Auth = self.Auth
        workingDir = Settings.workingDir

        (recordId, record) = Mongo.get(table, record)
        if recordId is None:
            Messages.warning(
                msg=f&#34;Delete {table}: no such {table}&#34;,
                logmsg=f&#34;Delete {table}: no {table} {recordId}&#34;,
            )
            return None

        permitted = Auth.authorise(table, record, action=&#34;delete&#34;)
        if not permitted:
            return None

        details = self.getDetailRecords(table, record)
        nDetails = len(details)
        if nDetails:
            Messages.warning(
                msg=f&#34;Cannot delete {table} because it has {nDetails} detail records&#34;,
                logmsg=f&#34;Delete {table} {recordId} prevented: {nDetails} details&#34;,
            )
            return None

        good = True

        links = self.getLinkedCrit(table, record)

        if links:
            for linkTable, linkCriteria in links.items():
                (thisGood, count) = Mongo.deleteRecords(
                    linkTable, stop=False, **linkCriteria
                )
                if not thisGood:
                    good = False
                    Messages.error(
                        stop=False,
                        msg=f&#34;Error during removing link records from {linkTable}&#34;,
                        logmsg=(
                            &#34;Cannot delete records from &#34;
                            f&#34;{linkTable} by {linkCriteria}&#34;
                        ),
                    )
                    break

                Messages.info(
                    msg=f&#34;Deleted {count} link records from {linkTable}&#34;,
                    logmsg=f&#34;Deleted {count} link records from {linkTable}&#34;,
                )

        if not good:
            return False

        good = Mongo.deleteRecord(table, _id=recordId)

        if not good:
            return False

        itemDirHead = workingDir
        itemDirTail = f&#34;{table}/{recordId}&#34;
        if table == &#34;edition&#34;:
            projectId = record.projectId
            itemDirHead += f&#34;/project/{projectId}&#34;
        itemDir = f&#34;{itemDirHead}/{itemDirTail}&#34;

        if dirExists(itemDir):
            dirRemove(itemDir)
            Messages.info(
                msg=f&#34;The {table} directory is removed&#34;,
                logmsg=f&#34;The {table} dir {itemDir} is removed&#34;,
            )
        else:
            Messages.warning(
                msg=f&#34;The {table} directory on file system did not exist&#34;,
                logmsg=f&#34;The {table} dir {itemDir} did not exist&#34;,
            )

        return True

    def createEdition(self, project):
        &#34;&#34;&#34;Creates a new edition.

        Parameters
        ----------
        project: AttrDict | string
            record that represents the maste project, or its id.

        Returns
        -------
        ObjectId
            The id of the new edition.
        &#34;&#34;&#34;
        Mongo = self.Mongo
        Messages = self.Messages
        Auth = self.Auth
        Settings = self.Settings
        workingDir = Settings.workingDir

        def fillin(template, values):
            typ = type(template)
            if typ is str:
                for k, v in values.items():
                    template = template.replace(f&#34;«{k}»&#34;, v)
                return template
            if typ in {list, tuple}:
                return [fillin(e, values) for e in template]
            if typ in {dict, AttrDict}:
                return {k: fillin(v, values) for (k, v) in template.items()}
            return template

        editionSettingsTemplate = Settings.editionSettingsTemplate
        viewerDefault = Settings.viewerDefault
        viewerInfo = Settings.viewers[viewerDefault] or AttrDict()
        versionDefault = viewerInfo.defaultVersion
        sceneFile = viewerInfo.sceneFile

        values = dict(viewer=viewerDefault, version=versionDefault, scene=sceneFile)
        editionSettings = fillin(editionSettingsTemplate, values)

        (projectId, project) = Mongo.get(&#34;project&#34;, project)
        if projectId is None:
            return None

        permitted = Auth.authorise(
            &#34;project&#34;, project, action=&#34;create&#34;, insertTable=&#34;edition&#34;
        )
        if not permitted:
            return None

        User = Auth.myDetails()
        user = User.user
        name = User.nickname

        title = &#34;Edition without title&#34;

        dcMeta = dict(
            title=title,
            description=dict(
                abstract=&#34;No intro&#34;,
                description=&#34;No description&#34;,
                provenance=&#34;No sources&#34;,
            ),
            creator=name,
        )
        editionId = Mongo.insertRecord(
            &#34;edition&#34;,
            title=title,
            projectId=projectId,
            meta=dict(dc=dcMeta),
            settings=editionSettings,
            isPublished=False,
        )
        Mongo.insertRecord(&#34;editionUser&#34;, editionId=editionId, user=user, role=&#34;editor&#34;)

        editionDir = f&#34;{workingDir}/project/{projectId}/edition/{editionId}&#34;
        if dirExists(editionDir):
            Messages.warning(
                msg=&#34;The new edition already exists on the file system&#34;,
                logmsg=f&#34;New edition {editionId} already exists on the filesystem.&#34;,
            )
        else:
            dirMake(editionDir)

        return editionId

    def saveValue(self, table, record, key):
        &#34;&#34;&#34;Saves a value of into a record.

        A record is a document, which is a (nested) dict.
        A value is inserted somewhere (deep) in that dict.

        The value is given by the request.

        Where exactly is given by a path that is stored in the field information,
        which is accessible by the key.

        Parameters
        ----------
        table: string
            The relevant table.
        record: string | ObjectId | AttrDict | void
            The relevant record.

        key: string
            an identifier for the meta data field.

        Returns
        -------
        dict
            Contains the following keys:

            * `status`: whether the save action was successful
            * `messages`: messages issued during the process
            * `readonly`: the html of the updated formatted value,
              this will replace the currently displayed value.
        &#34;&#34;&#34;
        Auth = self.Auth
        Mongo = self.Mongo

        value = json.loads(requestData())
        permitted = Auth.authorise(table, record, action=&#34;update&#34;)

        if not permitted:
            return dict(stat=False, messages=[[&#34;error&#34;, &#34;update not allowed&#34;]])

        F = self.makeField(key)

        nameSpace = F.nameSpace
        fieldPath = F.fieldPath
        tp = F.tp

        (recordId, record) = Mongo.get(table, record)
        if recordId is None:
            return dict(
                stat=False,
                messages=[[&#34;error&#34;, &#34;record does not exist&#34;]],
            )

        sValue = value if tp == &#34;text&#34; else readYaml(value, plain=True, ignore=True)
        nameSpaceRep = &#34;&#34; if not nameSpace else f&#34;{nameSpace}.&#34;
        update = {f&#34;{nameSpaceRep}{fieldPath}&#34;: sValue}
        if key == &#34;title&#34;:
            update[key] = sValue

        if Mongo.updateRecord(table, update, stop=False, _id=recordId) is None:
            return dict(
                stat=False,
                messages=[[&#34;error&#34;, &#34;could not update the record in the database&#34;]],
            )
        else:
            (recordId, record) = Mongo.get(table, recordId)

        return dict(
            stat=True,
            messages=[],
            readonly=F.formatted(table, record, editable=False, level=None),
        )

    def saveRole(self, user, table, recordId):
        &#34;&#34;&#34;Saves a role into a user or cross table record.

        The role is given by the request.

        Parameters
        ----------
        user: string
            The eppn of the user.
        table: string | void
            The relevant table. If not None, it indicates whether we are updating
            site-wide roles, otherwise project/edition roles.
        recordId: string | void
            The id of the relevant record. If not None, it is a project/edition
            record Id, which can be used to locate the cross record between the
            user table and the project/edition record where the user&#39;s
            role is stored.
            If None, the user&#39;s role is inside the user record.

        Returns
        -------
        dict
            Contains the following keys:

            * `status`: whether the save action was successful
            * `messages`: messages issued during the process
            * `updated`: if the action was successful, all user management info
              will be passed back and will replace the currently displayed
              material.
        &#34;&#34;&#34;
        newRole = json.loads(requestData())
        return Admin(self).saveRole(user, newRole, table, recordId)

    def createUser(self, user):
        &#34;&#34;&#34;Creates a new user with a given user name.

        Parameters
        ----------
        user: string
            The user name of the user.
            This should be different from the user names of existing users.

        Returns
        -------
        dict
            Contains the following keys:

            * `status`: whether the create action was successful
            * `messages`: messages issued during the process
            * `name`: the name under which the new user has been saved
        &#34;&#34;&#34;
        return Admin(self).createUser(user)

    def deleteUser(self, user):
        &#34;&#34;&#34;Deletes a test user with a given user name.

        Parameters
        ----------
        user: string
            The user name of the user.
            This should be a test user, not linked to any project or edition.

        Returns
        -------
        dict
            Contains the following keys:

            * `status`: whether the create action was successful
            * `messages`: messages issued during the process
        &#34;&#34;&#34;
        return Admin(self).deleteUser(user)

    def linkUser(self, table, recordId):
        &#34;&#34;&#34;Links a user in certain role to a project/edition record.

        The user and role are given by the request.

        Parameters
        ----------
        table: string
            The relevant table.
        recordId: string
            The id of the relevant record,
            which can be used to locate the cross record between the
            user table and the project/edition record where the user&#39;s
            role is stored.

        Returns
        -------
        dict
            Contains the following keys:

            * `status`: whether the save action was successful
            * `messages`: messages issued during the process
            * `updated`: if the action was successful, all user management info
              will be passed back and will replace the currently displayed
              material.
        &#34;&#34;&#34;
        (newRole, newUser) = json.loads(requestData())
        return Admin(self).linkUser(newUser, newRole, table, recordId)

    def getValue(self, table, record, key, level=None, manner=&#34;formatted&#34;):
        &#34;&#34;&#34;Retrieve a metadata value.

        Metadata sits in a big, potentially deeply nested dictionary of keys
        and values.
        These locations are known to the system (based on `fields.yml`).
        This function retrieves the information from those known locations.

        If a value is in fact composed of multiple values, it will be
        handled accordingly.

        If the user may edit the value, an edit button is added.

        Parameters
        ----------
        key: string
            an identifier for the meta data field.
        table: string
            The relevant table.
        record: string | ObjectId | AttrDict | void
            The relevant record.
        level: string, optional None
            The heading level with which the value should be formatted.

            * `0`: No heading level
            * `None`: no formatting at all

        manner: string, optional wrapped
            If it is &#34;formatted&#34;, the value is represented fully wrapped in HTML,
            possibly with edit/save controls.
            If it is &#34;bare&#34;, the value is represented as a simple string.
            If it is &#34;logical&#34;, the logical value is returned.

        Returns
        -------
        string
            It is assumed that the metadata value that is addressed exists.
            If not, we return the empty string.
        &#34;&#34;&#34;
        Auth = self.Auth

        actions = Auth.authorise(table, record)

        if &#34;read&#34; not in actions:
            return None

        F = self.makeField(key)

        isBare = manner == &#34;bare&#34;
        isLogical = manner == &#34;logical&#34;

        if isBare or isLogical:
            return (F.bare if isBare else F.logical)(record)

        editable = Auth.authorise(table, record, action=&#34;update&#34;)
        return F.formatted(table, record, editable=editable, level=level)

    def getValues(self, table, record, fieldSpecs):
        &#34;&#34;&#34;Puts several pieces of metadata on the web page.

        Parameters
        ----------
        fieldSpecs: string
            `,`-separated list of fieldSpecs
        table: string
            The relevant table
        record: string | ObjectId | AttrDict | void
            The relevant record

        Returns
        -------
        string
            The join of the individual results of retrieving metadata value.
        &#34;&#34;&#34;
        Settings = self.Settings
        H = Settings.H

        return H.content(
            self.getValue(table, record, key, level=level) or &#34;&#34;
            for (key, level) in (
                fieldSpec.strip().split(&#34;@&#34;, 1) for fieldSpec in fieldSpecs.split(&#34;+&#34;)
            )
        )

    def getUpload(self, record, key, fileName=None, bust=None, wrapped=True):
        &#34;&#34;&#34;Display the name and/or upload controls of an uploaded file.

        The user may upload model files and a scene file to an edition,
        and various png files as icons for projects, edtions, and scenes.
        Here we produce the control to do so.

        Only if the user has `update` authorisation, an upload/delete widget
        will be returned.

        Parameters
        ----------
        record: string | ObjectId | AttrDict | void
            The relevant record.
        key: string
            an identifier for the upload field.
        fileName: string, optional None
            If present, it indicates that the uploaded file will have this prescribed
            name.
            A file name for an upload object may also have been specified in
            the datamodel configuration.
        bust: string, optional None
            If not None, the image url of the file whose name is passed in
            `bust` is made unique by adding the current time to it. That will
            bust the cache for the image, so that uploaded images replace the
            existing images.

            This is useful when this function is called to provide udated
            content for an file upload widget after it has been used to
            successfully upload a file. The file name of the uploaded
            file is known, and that is the one that gets a cache buster appended.
        wrapped: boolean, optional True
            Whether the content should be wrapped in a container element.
            See `control.html.HtmlElements.finput()`.

        Returns
        -------
        string
            The name of the file that is currently present, or the indication
            that no file is present.

            If the user has edit permission for the edition, we display
            widgets to upload a new file or to delete the existing file.
        &#34;&#34;&#34;
        Auth = self.Auth

        uploadConfig = self.getUploadConfig(key)
        table = uploadConfig.table

        actions = Auth.authorise(table, record)

        if &#34;read&#34; not in actions:
            return None

        F = self.makeUpload(key, fileName=fileName)

        return F.formatted(record, &#34;update&#34; in actions, bust=bust, wrapped=wrapped)

    def getDownload(self, table, record):
        &#34;&#34;&#34;Display the name and/or upload controls of an uploaded file.

        The user may upload model files and a scene file to an edition,
        and various png files as icons for projects, edtions, and scenes.
        Here we produce the control to do so.

        Only if the user has `update` authorisation, an upload/delete widget
        will be returned.

        Parameters
        ----------
        table: string
            The table in which the relevant record sits
        record: string | ObjectId | AttrDict
            The relevant record.

        Returns
        -------
        string
            The name of the file that is currently present, or the indication
            that no file is present.

            If the user has edit permission for the edition, we display
            widgets to upload a new file or to delete the existing file.
        &#34;&#34;&#34;
        Settings = self.Settings
        H = Settings.H
        Mongo = self.Mongo
        Auth = self.Auth

        (recordId, record) = Mongo.get(table, record)
        if recordId is None:
            return &#34;&#34;

        actions = Auth.authorise(table, record)

        if &#34;read&#34; not in actions:
            return &#34;&#34;

        return H.iconx(
            &#34;download&#34;, text=&#34;download&#34;, href=f&#34;/download/{table}/{recordId}&#34;
        )

    def getPublishInfo(self, table, record):
        &#34;&#34;&#34;Display the number under which a project/edition is published.

        Editions of a project may have been published. If that is the case,
        the project has been assigned a sequence number, under which it can be
        found on the static site with published material.

        Here we collect that number, and, for editions, we may put a publish
        button here.

        Parameters
        ----------
        table: string
            The table in which the relevant record sits
        record: string | ObjectId | AttrDict
            The relevant record.

        Returns
        -------
        string
            In case of a project: the number of the project on the static site.
            In case of an edition: the number of the project and the number of the
            edition on the static site. If the edition is not yet published, and
            the user is allowed to publish the edition, then a publish button is
            also added.
        &#34;&#34;&#34;
        Settings = self.Settings

        H = Settings.H
        Mongo = self.Mongo
        Auth = self.Auth

        pubUrl = Settings.pubUrl
        published = Settings.published

        (recordId, record) = Mongo.get(table, record)
        if recordId is None:
            return &#34;&#34;

        actions = Auth.authorise(table, record)

        if &#34;read&#34; not in actions or table not in {&#34;project&#34;, &#34;edition&#34;}:
            return &#34;&#34;

        (site, siteId, projectId, project, editionId, edition) = self.context(
            table, record
        )

        pPubNum = project.pubNum

        projectPubStr = (
            H.i(&#34;No published editions&#34;)
            if pPubNum is None
            else H.span(&#34;Published: &#34;)
            + H.a(
                f&#34;{pPubNum} ⌲&#34;,
                f&#34;{pubUrl}/project/{pPubNum}/index.html&#34;,
                target=published,
                cls=&#34;button large&#34;,
            )
        )

        if table == &#34;project&#34;:
            return H.p(projectPubStr)

        ePubNum = edition.pubNum

        editionPubRow = (
            (
                H.i(&#34;Not published&#34;)
                if ePubNum is None or pPubNum is None
                else H.span(&#34;Published: &#34;)
            ),
            H.a(
                f&#34;{pPubNum}/{ePubNum} ⌲&#34;,
                f&#34;{pubUrl}/project/{pPubNum}/edition/{ePubNum}/index.html&#34;,
                target=published,
                cls=&#34;button large&#34;,
            ),
        )

        can = dict(
            precheck=True,
            publish=ePubNum is None,
            unpublish=pPubNum is not None and ePubNum is not None,
            republish=pPubNum is not None and ePubNum is not None,
        )

        rows = []

        for kind, kindRep, tbRecRoles in (
            (
                &#34;precheck&#34;,
                &#34;check articles&#34;,
                (
                    (&#34;edition&#34;, edition, &#34;editor&#34;),
                    (&#34;project&#34;, project, &#34;organiser&#34;),
                    (&#34;site&#34;, site, &#34;admin&#34;),
                    (&#34;site&#34;, site, &#34;root&#34;),
                ),
            ),
            (&#34;publish&#34;, &#34;publish&#34;, ((&#34;project&#34;, project, &#34;organiser&#34;),)),
            (
                (&#34;publishf&#34;, &#34;publish&#34;),
                &#34;force-publish&#34;,
                ((&#34;project&#34;, project, &#34;organiser&#34;),),
            ),
            (
                &#34;republish&#34;,
                &#34;re-publish&#34;,
                ((&#34;site&#34;, site, &#34;admin&#34;), (&#34;site&#34;, site, &#34;root&#34;)),
            ),
            (
                (&#34;republishf&#34;, &#34;republish&#34;),
                &#34;force-re-publish&#34;,
                ((&#34;site&#34;, site, &#34;admin&#34;), (&#34;site&#34;, site, &#34;root&#34;)),
            ),
            (
                &#34;unpublish&#34;,
                &#34;un-publish&#34;,
                ((&#34;site&#34;, site, &#34;admin&#34;), (&#34;site&#34;, site, &#34;root&#34;)),
            ),
        ):
            asKind = kind

            if type(kind) is tuple:
                (kind, asKind) = kind

            if can[asKind]:
                rows.append(
                    (
                        H.span(f&#34;You may {kindRep}:&#34;),
                        H.iconx(
                            kind,
                            href=f&#34;/{kind}/{recordId}&#34;,
                            cls=&#34;button large&#34;,
                        ),
                    )
                    if asKind in actions
                    else (
                        H.span(f&#34;You may not {kindRep}&#34;),
                        Auth.getInvolvedUsers(tbRecRoles, asString=True),
                    )
                )

        return H.table(
            [([(cell, {}) for cell in editionPubRow], {})],
            [([(cell, {}) for cell in row], {}) for row in rows],
        )

    def getViewerFile(self, path):
        &#34;&#34;&#34;Gets a viewer-related file from the file system.

        This is about files that are part of the viewer software.

        The viewer software is located in a specific directory on the server.
        This is the viewer base.

        Parameters
        ----------
        path: string
            The path of the viewer file within viewer base.

        Returns
        -------
        string
            The full path to the viewer file, if it exists.
            Otherwise, we raise an error that will lead to a 404 response.
        &#34;&#34;&#34;
        Settings = self.Settings
        Messages = self.Messages

        viewerDir = Settings.viewerDir

        viewerPath = f&#34;{viewerDir}/{path}&#34;

        if not fileExists(viewerPath):
            logmsg = f&#34;Accessing {viewerPath}: &#34;
            logmsg += &#34;does not exist. &#34;
            Messages.error(
                msg=&#34;Accessing a file&#34;,
                logmsg=logmsg,
            )

        return viewerPath

    def getDataFile(self, table, record, path, content=False, lenient=False):
        &#34;&#34;&#34;Gets a data file from the file system.

        All data files are located under a specific directory on the server.
        This is the data directory.
        Below that the files are organized by projects and editions.
        Projects and editions corresponds to records in tables in MongoDB.

        Parameters
        ----------
        path: string
            The path of the data file within site/project/edition directory
            within the data directory.
        project: string | ObjectId | AttrDict
            The id of the project in question.
        edition: string | ObjectId | AttrDict
            The id of the edition in question.
        content: boolean, optional False
            If True, delivers the content of the file, instead of the path
        lenient: boolean, optional False
            If True, do not complain if the file does not exist.

        Returns
        -------
        string
            The full path of the data file, if it exists.
            But if the `content` parameter is True, we deliver the content of the file.

            Otherwise, we raise an error that will lead to a 404 response, except
            when `lenient` is True.

        &#34;&#34;&#34;
        Settings = self.Settings
        H = Settings.H
        Messages = self.Messages
        Auth = self.Auth

        workingDir = Settings.workingDir

        (site, siteId, projectId, project, editionId, edition) = self.context(
            table, record
        )

        urlBase = (
            &#34;&#34;
            if project is None
            else f&#34;project/{projectId}&#34;
            if edition is None
            else f&#34;project/{projectId}/edition/{editionId}&#34;
        )
        sep = &#34;/&#34; if urlBase else &#34;&#34;
        base = f&#34;{workingDir}{sep}{urlBase}&#34;

        dataPath = base if path is None else f&#34;{base}/{path}&#34;

        (table, recordId, record) = self.relevant(project=project, edition=edition)
        if recordId is None:
            Messages.error(msg=&#34;record does not exist&#34;)
            return &#34;&#34;

        permitted = Auth.authorise(table, record, action=&#34;read&#34;)

        fexists = fileExists(dataPath)

        if permitted and fexists:
            if content:
                with open(dataPath) as fh:
                    result = fh.read()
            else:
                result = dataPath
        else:
            result = (
                &#34;&#34;
                if content
                else dataPath
                if lenient
                else H.span(dataPath, cls=&#34;error&#34;)
            )

            if not lenient:
                logmsg = f&#34;Accessing {dataPath}: &#34;

                if not permitted:
                    logmsg += &#34;not allowed. &#34;
                if not fexists:
                    logmsg += &#34;does not exist. &#34;

                Messages.error(
                    msg=f&#34;Accessing file {path}&#34;,
                    logmsg=logmsg,
                )
                result = &#34;&#34; if content else dataPath

        return result

    def breadCrumb(self, project):
        &#34;&#34;&#34;Makes a link to the landing page of a project.

        Parameters
        ----------
        project: string | ObjectId | AttrDict
            The project in question.
        &#34;&#34;&#34;
        Settings = self.Settings
        H = Settings.H
        Mongo = self.Mongo

        (projectId, project) = Mongo.get(&#34;project&#34;, project)
        if not project:
            return &#34;&#34;

        projectUrl = f&#34;/project/{projectId}&#34;
        text = self.getValue(&#34;project&#34;, project, &#34;title&#34;, manner=&#34;bare&#34;)
        if not text:
            text = H.i(&#34;no title&#34;)

        return H.p(
            [
                &#34;Project: &#34;,
                H.a(
                    text,
                    projectUrl,
                    cls=&#34;button&#34;,
                    title=&#34;back to the project page&#34;,
                ),
            ]
        )

    def precheck(self, record):
        &#34;&#34;&#34;Check the articles of an edition prior to publishing.

        Parameters
        ----------
        record: string
            The record of the edition to be checked.

        Return
        ------
        response
            A status response.

            It will also generate a a bunch of toc files in the edition.
        &#34;&#34;&#34;
        Messages = self.Messages
        Mongo = self.Mongo
        Auth = self.Auth
        Publish = self.Publish

        (recordId, record) = Mongo.get(&#34;edition&#34;, record)
        if recordId is None:
            Messages.error(
                msg=&#34;record does not exist&#34;, logmsg=f&#34;edition {recordId} does not exist&#34;
            )
            return False

        permitted = Auth.authorise(&#34;edition&#34;, record, action=&#34;precheck&#34;)

        if not permitted:
            logmsg = f&#34;Checking articles not permitted: edition: {recordId}&#34;
            msg = &#34;Checking articles of edition not permitted&#34;
            Messages.warning(msg=msg, logmsg=logmsg)
            return False

        (siteId, site, projectId, project, editionId, edition) = self.context(
            &#34;edition&#34;, record
        )

        return Publish.Precheck.checkEdition(project, editionId, edition)

    def publish(self, record, force):
        &#34;&#34;&#34;Publish an edition.

        Parameters
        ----------
        record: string
            The record of the item to be published.
        force: boolean
            If True, ignore when some checks fail

        Return
        ------
        response
            A publish status response.
        &#34;&#34;&#34;
        Messages = self.Messages
        Mongo = self.Mongo
        Auth = self.Auth
        Publish = self.Publish

        (recordId, record) = Mongo.get(&#34;edition&#34;, record)
        if recordId is None:
            Messages.error(
                msg=&#34;record does not exist&#34;, logmsg=f&#34;edition {recordId} does not exist&#34;
            )
            return False

        permitted = Auth.authorise(&#34;edition&#34;, record, action=&#34;publish&#34;)

        if not permitted:
            logmsg = f&#34;Publish not permitted: edition: {recordId}&#34;
            msg = &#34;Publishing of edition not permitted&#34;
            Messages.warning(msg=msg, logmsg=logmsg)
            return False

        (siteId, site, projectId, project, editionId, edition) = self.context(
            &#34;edition&#34;, record
        )

        return Publish.updateEdition(site, project, edition, &#34;add&#34;, force=force)

    def republish(self, record, force):
        &#34;&#34;&#34;Re-ublish an edition.

        Parameters
        ----------
        record: string
            The record of the item to be re-published.
        force: boolean
            If True, ignore when some checks fail

        Return
        ------
        response
            A re-publish status response.
        &#34;&#34;&#34;
        Messages = self.Messages
        Mongo = self.Mongo
        Auth = self.Auth
        Publish = self.Publish

        (recordId, record) = Mongo.get(&#34;edition&#34;, record)
        if recordId is None:
            Messages.error(
                msg=&#34;record does not exist&#34;, logmsg=f&#34;edition {recordId} does not exist&#34;
            )
            return False

        permitted = Auth.authorise(&#34;edition&#34;, record, action=&#34;republish&#34;)

        if not permitted:
            logmsg = f&#34;Re-publish not permitted: edition: {recordId}&#34;
            msg = &#34;Re-publishing of edition not permitted&#34;
            Messages.warning(msg=msg, logmsg=logmsg)
            return False

        (siteId, site, projectId, project, editionId, edition) = self.context(
            &#34;edition&#34;, record
        )

        return Publish.updateEdition(
            site, project, edition, &#34;add&#34;, force=force, again=True
        )

    def unpublish(self, record):
        &#34;&#34;&#34;Unpublish an edition.

        Parameters
        ----------
        record: string
            The record of the item to be unpublished.

        Return
        ------
        response
            An unpublish status response.
        &#34;&#34;&#34;
        Messages = self.Messages
        Mongo = self.Mongo
        Auth = self.Auth
        Publish = self.Publish

        (recordId, record) = Mongo.get(&#34;edition&#34;, record)
        if recordId is None:
            Messages.error(
                msg=&#34;record does not exist&#34;, logmsg=f&#34;edition {recordId} does not exist&#34;
            )
            return False

        permitted = Auth.authorise(&#34;edition&#34;, record, action=&#34;unpublish&#34;)

        if not permitted:
            logmsg = f&#34;Unpublish not permitted: edition: {recordId}&#34;
            msg = &#34;Unpublishing of edition not permitted&#34;
            Messages.warning(msg=msg, logmsg=logmsg)
            return False

        (siteId, site, projectId, project, editionId, edition) = self.context(
            &#34;edition&#34;, record
        )

        return Publish.updateEdition(site, project, edition, &#34;remove&#34;)

    def generate(self):
        &#34;&#34;&#34;Regenerate the HTML for the published site.

        Return
        ------
        response
            A publish status response.
        &#34;&#34;&#34;
        Messages = self.Messages
        Auth = self.Auth
        Publish = self.Publish

        site = self.relevant()[-1]
        permitted = Auth.authorise(&#34;site&#34;, site, action=&#34;republish&#34;)

        if not permitted:
            logmsg = &#34;Generate pages is not permitted&#34;
            msg = &#34;Generate pages is not permitted&#34;
            Messages.warning(msg=msg, logmsg=logmsg)
            return False

        return Publish.generatePages(None, None)

    def download(self, table, record):
        &#34;&#34;&#34;Responds with a download of a project or edition.

        Parameters
        ----------
        table: string
            The table where the item to be downloaded sits.
        record: string
            The record of the item to be downloaded.

        Return
        ------
        response
            A download response.
        &#34;&#34;&#34;
        Settings = self.Settings
        Messages = self.Messages
        Mongo = self.Mongo
        Auth = self.Auth
        dataDir = Settings.dataDir
        workingDir = Settings.workingDir
        runMode = Settings.runMode

        (recordId, record) = Mongo.get(table, record)
        if recordId is None:
            return jsonify(status=False, msgs=[[&#34;warning&#34;, &#34;record does not exist&#34;]])

        permitted = Auth.authorise(table, record, action=&#34;read&#34;)

        if not permitted:
            logmsg = f&#34;Download not permitted: {table}: {recordId}&#34;
            msg = f&#34;Download of {table} not permitted&#34;
            Messages.warning(logmsg=logmsg)
            return jsonify(status=False, msgs=[[&#34;warning&#34;, msg]])

        (siteId, site, projectId, project, editionId, edition) = self.context(
            table, record
        )

        src = f&#34;{workingDir}/project/{projectId}&#34;

        if edition is not None:
            src += f&#34;/edition/{editionId}&#34;

        sep = &#34;/&#34; if dataDir else &#34;&#34;
        tempBase = f&#34;{dataDir}{sep}temp/{runMode}&#34;
        dirMake(tempBase)
        dst = mkdtemp(dir=tempBase)
        Messages.info(logmsg=f&#34;CREATED TEMP DIR {dst}&#34;)

        good = True

        try:
            landing = f&#34;{dst}/{recordId}&#34;
            fileName = f&#34;{table}-{recordId}.zip&#34;

            if edition is None:
                yamlDest = f&#34;{landing}/project.yaml&#34;
            else:
                yamlDest = f&#34;{landing}/edition.yaml&#34;

            dirCopy(src, landing)

            with open(yamlDest, &#34;w&#34;) as yh:
                yaml.dump(Mongo.consolidate(project), yh, allow_unicode=True)

            if edition is None:
                editions = Mongo.getList(&#34;edition&#34;, sort=&#34;title&#34;, projectId=projectId)

                for ed in editions:
                    edId = ed._id
                    yamlDest = f&#34;{landing}/edition/{edId}/edition.yaml&#34;

                    with open(yamlDest, &#34;w&#34;) as yh:
                        yaml.dump(Mongo.consolidate(ed), yh, allow_unicode=True)

            zipBuffer = BytesIO()

            with ZipFile(zipBuffer, &#34;w&#34;, compression=ZIP_DEFLATED) as zipFile:

                def compress(path):
                    sep = &#34;/&#34; if path else &#34;&#34;
                    with os.scandir(f&#34;{landing}{sep}{path}&#34;) as dh:
                        for entry in dh:
                            name = entry.name
                            if entry.is_file():
                                arcFile = f&#34;{path}{sep}{name}&#34;
                                srcFile = f&#34;{landing}/{arcFile}&#34;
                                zipFile.write(srcFile, arcFile)
                            elif entry.is_dir():
                                compress(f&#34;{path}/{name}&#34;)

                compress(&#34;&#34;)

            zipData = zipBuffer.getvalue()
            Messages.info(msg=f&#34;{table} downloaded&#34;)

        except Exception as e:
            msg = &#34;Could not assemble the data for download&#34;
            Messages.error(msg=msg, logmsg=msg)
            Messages.error(logmsg=&#34;&#34;.join(format_exception(e)), stop=False)
            good = False

        dirRemove(dst)
        Messages.info(logmsg=f&#34;DELETED TEMP DIR {dst}&#34;)

        if good:
            headers = {
                &#34;Expires&#34;: &#34;0&#34;,
                &#34;Cache-Control&#34;: &#34;no-cache, no-store, must-revalidate&#34;,
                &#34;Content-Type&#34;: &#34;application/zip&#34;,
                &#34;Content-Disposition&#34;: f&#39;attachment; filename=&#34;{fileName}&#34;&#39;,
                &#34;Content-Encoding&#34;: &#34;identity&#34;,
            }

            return (zipData, headers)

        else:
            ref = getReferrer().removeprefix(&#34;/&#34;)
            return redirectStatus(f&#34;/{ref}&#34;, False)

    def saveFile(self, record, key, path, fileName, targetFileName=None):
        &#34;&#34;&#34;Saves a file in the context given by a record.

        The parameter `key` refers to a configuration section in the datamodel.
        This determines what file type to expect.
        We only accept files whose name has an extension that matches the expected
        file type.

        The key `modelz` expects a zip file with the files of an edition, in particular
        a scene file and model files. We make sure that these files have the
        proper type, and we also perform checks on the other parts of the zip file,
        namely whether they have decent paths.

        Parameters
        ----------
        record: string | ObjectId | AttrDict | void
            The relevant record.
        key: string
            The upload key
        path: string
            The path from the context directory to the file
        fileName: string
            Name  of the file to be saved as mentioned in the request.
        targetFileName: string, optional None
            The name of the file as which the uploaded file will be saved;
            if None, the file will be saved with the name from the request.

        Return
        ------
        response
            A json response with the status of the save operation:

            * a boolean: whether the save succeeded
            * a list of messages to display
            * content: new content for an upload control (only if successful)
        &#34;&#34;&#34;
        fileContent = requestData()  # essential to have this early on in the body
        # if not, the error responses might go wrong in some browsers

        Settings = self.Settings
        H = Settings.H
        Messages = self.Messages
        Mongo = self.Mongo
        Auth = self.Auth
        workingDir = Settings.workingDir

        uploadConfig = self.getUploadConfig(key)
        table = uploadConfig.table

        (recordId, record) = Mongo.get(table, record)
        if recordId is None:
            return jsonify(status=False, msgs=[[&#34;warning&#34;, &#34;record does not exist&#34;]])

        permitted = Auth.authorise(table, record, action=&#34;update&#34;)

        saveName = fileName

        if targetFileName is not None:
            saveName = targetFileName

        filePath = f&#34;{path}{saveName}&#34;
        fileFullPath = f&#34;{workingDir}/{filePath}&#34;

        if not permitted:
            logmsg = f&#34;Upload not permitted: {key}: {fileFullPath}&#34;
            msg = f&#34;Upload not permitted: {fileName}&#34;
            Messages.warning(logmsg=logmsg)
            return jsonify(status=False, msgs=[[&#34;warning&#34;, msg]])

        (good, msgs) = self.checkFileContent(key, targetFileName, fileName, fileContent)

        if not good:
            return jsonify(status=False, msgs=msgs)

        if key == &#34;modelz&#34;:
            destDir = f&#34;{workingDir}/{path}&#34;
            (good, msgs) = self.processModelZip(fileContent, destDir)
            if good:
                return jsonify(
                    status=True,
                    msgs=msgs,
                    content=H.b(&#34;Please refresh the page&#34;, cls=&#34;good&#34;),
                )
            return jsonify(status=False, msgs=msgs)

        try:
            with open(fileFullPath, &#34;wb&#34;) as fh:
                fh.write(fileContent)
        except Exception:
            logmsg = f&#34;Could not save uploaded file: {key}: {fileFullPath}&#34;
            msg = f&#34;Uploaded file not saved: {fileName}&#34;
            Messages.warning(logmsg=logmsg)
            return jsonify(status=False, msgs=[[&#34;warning&#34;, msg]])

        content = self.getUpload(
            record, key, fileName=targetFileName, bust=fileName, wrapped=False
        )

        return jsonify(status=True, msgs=[[&#34;good&#34;, &#34;Done&#34;]], content=content)

    def checkFileContent(self, key, targetFileName, fileName, fileContent):
        &#34;&#34;&#34;Performs checks on the name and content of an uploaded file before saving it.

        Parameters
        ----------
        key: string
            The key of the upload. This key determines what kind of file we expect.
            If None, we do not expect a particular mime type
        targetFileName: string
            The prescribed name to save the file under, if None, it will be saved under
            the name mentioned in the request.
        fileName: string
            The name of the file as mentioned in the request.
        fileContent: bytes
            The content of the file as bytes

        Returns
        -------
        tuple
            A boolean that tells whether the file content looks OK plus a sequences of
            messages indicating what is wrong with the content.
        &#34;&#34;&#34;
        Settings = self.Settings
        datamodel = Settings.datamodel
        mimeTypes = datamodel.mimeTypes
        uploadConfig = self.getUploadConfig(key) or AttrDict()
        acceptStr = uploadConfig.accept
        accept = (
            None
            if acceptStr is None
            else {acc[1:].strip() for acc in acceptStr.split(&#34;,&#34;)}
        )

        good = True
        msgs = []

        fileExt = extNm(fileName)

        if targetFileName is not None:
            targetExt = extNm(targetFileName)

            if targetExt != fileExt:
                good = False
                msgs.append(
                    [
                        &#34;error&#34;,
                        (
                            f&#34;the uploaded file name {fileName} has an extension &#34;
                            &#34;different from that of the target &#34;
                            f&#34;file name {targetFileName}&#34;
                        ),
                    ]
                )

            if accept is not None and targetExt not in accept:
                good = False
                msgs.append(
                    [
                        &#34;error&#34;,
                        (
                            &#34;Programming error: the prescribed file name &#34;
                            f&#34;{targetFileName} has an extension not in {acceptStr}&#34;
                        ),
                    ]
                )
                return (good, msgs)

            fileName = targetFileName
            fileExt = extNm(fileName)

        if accept is not None and fileExt not in accept:
            good = False
            msgs.append(
                (
                    &#34;error&#34;,
                    (
                        f&#34;the uploaded file name {fileName} has an extension &#34;
                        f&#34;not in {acceptStr}&#34;
                    ),
                )
            )
            return (good, msgs)

        if fileExt == &#34;gltf&#34;:
            (thisGood, messages) = check(fileContent)
            if thisGood:
                mimeType = &#34;model/gltf+json&#34;
            else:
                good = False
                msgs.extend([(&#34;error&#34;, msg) for msg in messages])
                mimeType = None
        else:
            mimeType = magic.from_buffer(fileContent, mime=True)
            if mimeType is None:
                good = False
                msgs.append(
                    (
                        &#34;error&#34;,
                        (
                            f&#34;could not determined the mime type of {fileName} &#34;
                            &#34;based on its uploaded content&#34;
                        ),
                    )
                )

        if mimeType is not None:
            if (
                fileExt not in mimeTypes.get(mimeType, [])
                and mimeType.split(&#34;/&#34;, 1)[-1].split(&#34;+&#34;, 1)[0].lower()
                != fileExt.lower()
            ):
                good = False
                msgs.append(
                    (
                        &#34;error&#34;,
                        (
                            f&#34;the uploaded file content of {mimeType} file &#34;
                            f&#34;{fileName} does not fit its extension {fileExt}&#34;
                        ),
                    )
                )

        return (good, msgs)

    def processModelZip(self, zf, destDir):
        &#34;&#34;&#34;Processes zip data with a scene and model files.

        All files in the zip file will be examined, and those with
        extension svx.json will be saved as scene.svx.json at top level
        and those with extensions glb of gltf will be saved under their
        own names, also at top level.

        All other files will be saved as is, unless they have extension .svx.json,
        or .gltf or .glb.

        These files can end up in subdirectories.

        We do not check the file types of the member files other than the svx.json files
        and the model files (glb, gltf).
        If the file type for these files does not match their extensions, they will be
        ignored.

        The user is held responsible to submit a suitable file.

        Parameters
        ----------
        zf: bytes
            The raw zip data
        &#34;&#34;&#34;
        Messages = self.Messages

        msgs = []
        good = True

        try:
            zf = BytesIO(zf)
            z = ZipFile(zf)

            allFiles = 0
            sceneFiles = set()
            modelFiles = set()
            otherFiles = set()

            goodFiles = []

            for zInfo in z.infolist():
                if zInfo.filename[-1] == &#34;/&#34;:
                    continue
                if zInfo.filename.startswith(&#34;__MACOS&#34;):
                    continue

                allFiles += 1

                zName = zInfo.filename
                zPath = zName.split(&#34;/&#34;)

                if len(zPath) == 1:
                    zDir, zFile = &#34;&#34;, zPath[0]
                else:
                    zDir = &#34;/&#34;.join(zPath[0:-1])
                    zFile = zPath[-1]

                zTest = zFile.lower()
                doFileTypeCheck = False

                if zTest.endswith(&#34;.svx.json&#34;):
                    if zDir == &#34;&#34;:
                        sceneFiles.add(zName)
                        doFileTypeCheck = True
                    else:
                        msgs.append(
                            (&#34;warning&#34;, f&#34;ignoring non-toplevel scene file {zName}&#34;)
                        )
                        continue
                elif zTest.endswith(&#34;.glb&#34;) or zTest.endswith(&#34;.gltf&#34;):
                    if zDir == &#34;&#34;:
                        modelFiles.add(zName)
                        doFileTypeCheck = True
                    else:
                        msgs.append(
                            (&#34;warning&#34;, f&#34;ignoring non-toplevel model file {zName}&#34;)
                        )
                        continue
                else:
                    otherFiles.add(zName)

                if doFileTypeCheck:
                    fileContent = z.read(zInfo)
                    (thisGood, theseMsgs) = self.checkFileContent(
                        None, None, zFile, fileContent
                    )
                    if thisGood:
                        goodFiles.append((zName, fileContent))
                    else:
                        good = False
                        msgs.extend(theseMsgs)
                else:
                    goodFiles.append((zInfo, None))

            if good:
                for zName, fileContent in goodFiles:
                    if fileContent is None:
                        z.extract(zName, path=destDir)
                    else:
                        with open(f&#34;{destDir}/{zName}&#34;, mode=&#34;wb&#34;) as fh:
                            fh.write(fileContent)

            nScenes = len(sceneFiles)
            sLabel = &#34;info&#34; if nScenes == 1 else &#34;warning&#34;
            msgs.append((&#34;info&#34;, f&#34;All files in zip: {allFiles:&gt;3}&#34;))
            msgs.append((sLabel, f&#34;Scene files: {nScenes:&gt;3} x&#34;))
            msgs.append((&#34;info&#34;, f&#34;Model files: {len(modelFiles):&gt;3} x&#34;))
            msgs.append((&#34;info&#34;, f&#34;Other files: {len(otherFiles):&gt;3} x&#34;))

        except Exception as e:
            good = False
            msgs.append((&#34;error&#34;, &#34;Something went wrong&#34;))
            Messages.warning(logmsg=str(e))

        return (good, msgs)

    def deleteFile(self, record, key, path, fileName, targetFileName=None):
        &#34;&#34;&#34;Deletes a file in the context given by a record.

        Parameters
        ----------
        record: string | ObjectId | AttrDict | void
            The relevant record.
        key: string
            The upload key
        path: string
            The path from the context directory to the file
        fileName: string
            Name  of the file to be saved as mentioned in the request.
        targetFileName: string, optional None
            The name of the file as which the uploaded file will be saved;
            if None, the file will be saved with the name from the request.

        Return
        ------
        response
            A json response with the status of the save operation:

            * a boolean: whether the save succeeded
            * a message: messages to display
            * content: new content for an upload control (only if successful)
        &#34;&#34;&#34;
        Settings = self.Settings
        Messages = self.Messages
        Mongo = self.Mongo
        Auth = self.Auth
        workingDir = Settings.workingDir

        uploadConfig = self.getUploadConfig(key)
        table = uploadConfig.table

        (recordId, record) = Mongo.get(table, record)
        if recordId is None:
            return jsonify(status=False, msgs=[[&#34;warning&#34;, &#34;record does not exist&#34;]])

        permitted = Auth.authorise(table, record, action=&#34;update&#34;)

        sep = &#34;/&#34; if path else &#34;&#34;
        filePath = f&#34;{path}{sep}{fileName}&#34;
        fileFullPath = f&#34;{workingDir}/{filePath}&#34;

        if not permitted:
            logmsg = f&#34;Delete file not permitted: {key}: {fileFullPath}&#34;
            msg = f&#34;Delete not permitted: {fileName}&#34;
            Messages.warning(logmsg=logmsg)
            return jsonify(status=False, msgs=[[&#34;warning&#34;, msg]])

        if not fileExists(fileFullPath):
            logmsg = f&#34;File does not exist: {key}: {fileFullPath}&#34;
            msg = f&#34;File does not exist: {fileName}&#34;
            Messages.warning(logmsg=logmsg)
            return jsonify(status=False, msgs=[[&#34;warning&#34;, msg]])

        try:
            fileRemove(fileFullPath)
        except Exception:
            logmsg = f&#34;Could not delete file: {key}: {fileFullPath}&#34;
            msg = f&#34;File not deleted: {fileName}&#34;
            Messages.warning(logmsg=logmsg)
            return jsonify(status=False, msgs=[[&#34;error&#34;, msg]])

        content = self.getUpload(
            record, key, fileName=targetFileName, bust=fileName, wrapped=False
        )

        return jsonify(status=True, msgs=[[&#34;good&#34;, &#34;Done&#34;]], content=content)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="control.datamodel.Datamodel" href="datamodel.html#control.datamodel.Datamodel">Datamodel</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="control.content.Content.addAuth"><code class="name flex">
<span>def <span class="ident">addAuth</span></span>(<span>self, Auth)</span>
</code></dt>
<dd>
<div class="desc"><p>Give this object a handle to the Auth object.</p>
<p>Because of cyclic dependencies some objects require to be given
a handle to Auth after their initialization.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/23c61c878149a0c80bf432c2e0e320f5e806d778/src/control/content.py#L56-L62" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def addAuth(self, Auth):
    &#34;&#34;&#34;Give this object a handle to the Auth object.

    Because of cyclic dependencies some objects require to be given
    a handle to Auth after their initialization.
    &#34;&#34;&#34;
    self.Auth = Auth</code></pre>
</details>
</dd>
<dt id="control.content.Content.addPublish"><code class="name flex">
<span>def <span class="ident">addPublish</span></span>(<span>self, Publish)</span>
</code></dt>
<dd>
<div class="desc"><p>Give this object a handle to the Publish object.</p>
<p>Because of cyclic dependencies some objects require to be given
a handle to Publish after their initialization.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/23c61c878149a0c80bf432c2e0e320f5e806d778/src/control/content.py#L64-L70" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def addPublish(self, Publish):
    &#34;&#34;&#34;Give this object a handle to the Publish object.

    Because of cyclic dependencies some objects require to be given
    a handle to Publish after their initialization.
    &#34;&#34;&#34;
    self.Publish = Publish</code></pre>
</details>
</dd>
<dt id="control.content.Content.breadCrumb"><code class="name flex">
<span>def <span class="ident">breadCrumb</span></span>(<span>self, project)</span>
</code></dt>
<dd>
<div class="desc"><p>Makes a link to the landing page of a project.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>project</code></strong> :&ensp;<code>string | ObjectId | AttrDict</code></dt>
<dd>The project in question.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/23c61c878149a0c80bf432c2e0e320f5e806d778/src/control/content.py#L1132-L1163" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def breadCrumb(self, project):
    &#34;&#34;&#34;Makes a link to the landing page of a project.

    Parameters
    ----------
    project: string | ObjectId | AttrDict
        The project in question.
    &#34;&#34;&#34;
    Settings = self.Settings
    H = Settings.H
    Mongo = self.Mongo

    (projectId, project) = Mongo.get(&#34;project&#34;, project)
    if not project:
        return &#34;&#34;

    projectUrl = f&#34;/project/{projectId}&#34;
    text = self.getValue(&#34;project&#34;, project, &#34;title&#34;, manner=&#34;bare&#34;)
    if not text:
        text = H.i(&#34;no title&#34;)

    return H.p(
        [
            &#34;Project: &#34;,
            H.a(
                text,
                projectUrl,
                cls=&#34;button&#34;,
                title=&#34;back to the project page&#34;,
            ),
        ]
    )</code></pre>
</details>
</dd>
<dt id="control.content.Content.checkFileContent"><code class="name flex">
<span>def <span class="ident">checkFileContent</span></span>(<span>self, key, targetFileName, fileName, fileContent)</span>
</code></dt>
<dd>
<div class="desc"><p>Performs checks on the name and content of an uploaded file before saving it.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>key</code></strong> :&ensp;<code>string</code></dt>
<dd>The key of the upload. This key determines what kind of file we expect.
If None, we do not expect a particular mime type</dd>
<dt><strong><code>targetFileName</code></strong> :&ensp;<code>string</code></dt>
<dd>The prescribed name to save the file under, if None, it will be saved under
the name mentioned in the request.</dd>
<dt><strong><code>fileName</code></strong> :&ensp;<code>string</code></dt>
<dd>The name of the file as mentioned in the request.</dd>
<dt><strong><code>fileContent</code></strong> :&ensp;<code>bytes</code></dt>
<dd>The content of the file as bytes</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>A boolean that tells whether the file content looks OK plus a sequences of
messages indicating what is wrong with the content.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/23c61c878149a0c80bf432c2e0e320f5e806d778/src/control/content.py#L1573-L1695" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def checkFileContent(self, key, targetFileName, fileName, fileContent):
    &#34;&#34;&#34;Performs checks on the name and content of an uploaded file before saving it.

    Parameters
    ----------
    key: string
        The key of the upload. This key determines what kind of file we expect.
        If None, we do not expect a particular mime type
    targetFileName: string
        The prescribed name to save the file under, if None, it will be saved under
        the name mentioned in the request.
    fileName: string
        The name of the file as mentioned in the request.
    fileContent: bytes
        The content of the file as bytes

    Returns
    -------
    tuple
        A boolean that tells whether the file content looks OK plus a sequences of
        messages indicating what is wrong with the content.
    &#34;&#34;&#34;
    Settings = self.Settings
    datamodel = Settings.datamodel
    mimeTypes = datamodel.mimeTypes
    uploadConfig = self.getUploadConfig(key) or AttrDict()
    acceptStr = uploadConfig.accept
    accept = (
        None
        if acceptStr is None
        else {acc[1:].strip() for acc in acceptStr.split(&#34;,&#34;)}
    )

    good = True
    msgs = []

    fileExt = extNm(fileName)

    if targetFileName is not None:
        targetExt = extNm(targetFileName)

        if targetExt != fileExt:
            good = False
            msgs.append(
                [
                    &#34;error&#34;,
                    (
                        f&#34;the uploaded file name {fileName} has an extension &#34;
                        &#34;different from that of the target &#34;
                        f&#34;file name {targetFileName}&#34;
                    ),
                ]
            )

        if accept is not None and targetExt not in accept:
            good = False
            msgs.append(
                [
                    &#34;error&#34;,
                    (
                        &#34;Programming error: the prescribed file name &#34;
                        f&#34;{targetFileName} has an extension not in {acceptStr}&#34;
                    ),
                ]
            )
            return (good, msgs)

        fileName = targetFileName
        fileExt = extNm(fileName)

    if accept is not None and fileExt not in accept:
        good = False
        msgs.append(
            (
                &#34;error&#34;,
                (
                    f&#34;the uploaded file name {fileName} has an extension &#34;
                    f&#34;not in {acceptStr}&#34;
                ),
            )
        )
        return (good, msgs)

    if fileExt == &#34;gltf&#34;:
        (thisGood, messages) = check(fileContent)
        if thisGood:
            mimeType = &#34;model/gltf+json&#34;
        else:
            good = False
            msgs.extend([(&#34;error&#34;, msg) for msg in messages])
            mimeType = None
    else:
        mimeType = magic.from_buffer(fileContent, mime=True)
        if mimeType is None:
            good = False
            msgs.append(
                (
                    &#34;error&#34;,
                    (
                        f&#34;could not determined the mime type of {fileName} &#34;
                        &#34;based on its uploaded content&#34;
                    ),
                )
            )

    if mimeType is not None:
        if (
            fileExt not in mimeTypes.get(mimeType, [])
            and mimeType.split(&#34;/&#34;, 1)[-1].split(&#34;+&#34;, 1)[0].lower()
            != fileExt.lower()
        ):
            good = False
            msgs.append(
                (
                    &#34;error&#34;,
                    (
                        f&#34;the uploaded file content of {mimeType} file &#34;
                        f&#34;{fileName} does not fit its extension {fileExt}&#34;
                    ),
                )
            )

    return (good, msgs)</code></pre>
</details>
</dd>
<dt id="control.content.Content.createEdition"><code class="name flex">
<span>def <span class="ident">createEdition</span></span>(<span>self, project)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a new edition.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>project</code></strong> :&ensp;<code>AttrDict | string</code></dt>
<dd>record that represents the maste project, or its id.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ObjectId</code></dt>
<dd>The id of the new edition.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/23c61c878149a0c80bf432c2e0e320f5e806d778/src/control/content.py#L405-L489" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def createEdition(self, project):
    &#34;&#34;&#34;Creates a new edition.

    Parameters
    ----------
    project: AttrDict | string
        record that represents the maste project, or its id.

    Returns
    -------
    ObjectId
        The id of the new edition.
    &#34;&#34;&#34;
    Mongo = self.Mongo
    Messages = self.Messages
    Auth = self.Auth
    Settings = self.Settings
    workingDir = Settings.workingDir

    def fillin(template, values):
        typ = type(template)
        if typ is str:
            for k, v in values.items():
                template = template.replace(f&#34;«{k}»&#34;, v)
            return template
        if typ in {list, tuple}:
            return [fillin(e, values) for e in template]
        if typ in {dict, AttrDict}:
            return {k: fillin(v, values) for (k, v) in template.items()}
        return template

    editionSettingsTemplate = Settings.editionSettingsTemplate
    viewerDefault = Settings.viewerDefault
    viewerInfo = Settings.viewers[viewerDefault] or AttrDict()
    versionDefault = viewerInfo.defaultVersion
    sceneFile = viewerInfo.sceneFile

    values = dict(viewer=viewerDefault, version=versionDefault, scene=sceneFile)
    editionSettings = fillin(editionSettingsTemplate, values)

    (projectId, project) = Mongo.get(&#34;project&#34;, project)
    if projectId is None:
        return None

    permitted = Auth.authorise(
        &#34;project&#34;, project, action=&#34;create&#34;, insertTable=&#34;edition&#34;
    )
    if not permitted:
        return None

    User = Auth.myDetails()
    user = User.user
    name = User.nickname

    title = &#34;Edition without title&#34;

    dcMeta = dict(
        title=title,
        description=dict(
            abstract=&#34;No intro&#34;,
            description=&#34;No description&#34;,
            provenance=&#34;No sources&#34;,
        ),
        creator=name,
    )
    editionId = Mongo.insertRecord(
        &#34;edition&#34;,
        title=title,
        projectId=projectId,
        meta=dict(dc=dcMeta),
        settings=editionSettings,
        isPublished=False,
    )
    Mongo.insertRecord(&#34;editionUser&#34;, editionId=editionId, user=user, role=&#34;editor&#34;)

    editionDir = f&#34;{workingDir}/project/{projectId}/edition/{editionId}&#34;
    if dirExists(editionDir):
        Messages.warning(
            msg=&#34;The new edition already exists on the file system&#34;,
            logmsg=f&#34;New edition {editionId} already exists on the filesystem.&#34;,
        )
    else:
        dirMake(editionDir)

    return editionId</code></pre>
</details>
</dd>
<dt id="control.content.Content.createProject"><code class="name flex">
<span>def <span class="ident">createProject</span></span>(<span>self, site)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a new project.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>site</code></strong> :&ensp;<code>AttrDict | string</code></dt>
<dd>record that represents the site, or its id.
It acts as a master record for all projects.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ObjectId</code></dt>
<dd>The id of the new project.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/23c61c878149a0c80bf432c2e0e320f5e806d778/src/control/content.py#L252-L306" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def createProject(self, site):
    &#34;&#34;&#34;Creates a new project.

    Parameters
    ----------
    site: AttrDict | string
        record that represents the site, or its id.
        It acts as a master record for all projects.

    Returns
    -------
    ObjectId
        The id of the new project.
    &#34;&#34;&#34;
    Settings = self.Settings
    Messages = self.Messages
    Mongo = self.Mongo
    Auth = self.Auth
    workingDir = Settings.workingDir

    (siteId, site) = Mongo.get(&#34;site&#34;, site)
    if siteId is None:
        return None

    permitted = Auth.authorise(&#34;site&#34;, site, action=&#34;create&#34;, insertTable=&#34;project&#34;)
    if not permitted:
        return None

    User = Auth.myDetails()
    user = User.user
    name = User.nickname

    title = &#34;Project without title&#34;

    dcMeta = dict(
        title=title,
        description=dict(abstract=&#34;No intro&#34;, description=&#34;No description&#34;),
        creator=name,
    )
    projectId = Mongo.insertRecord(
        &#34;project&#34;, title=title, meta=dict(dc=dcMeta), isVisible=False
    )
    Mongo.insertRecord(
        &#34;projectUser&#34;, projectId=projectId, user=user, role=&#34;organiser&#34;
    )
    projectDir = f&#34;{workingDir}/project/{projectId}&#34;
    if dirExists(projectDir):
        Messages.warning(
            msg=&#34;The new project already exists on the file system&#34;,
            logmsg=f&#34;New project {projectId} already exists on the filesystem.&#34;,
        )
    else:
        dirMake(projectDir)

    return projectId</code></pre>
</details>
</dd>
<dt id="control.content.Content.createUser"><code class="name flex">
<span>def <span class="ident">createUser</span></span>(<span>self, user)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a new user with a given user name.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>user</code></strong> :&ensp;<code>string</code></dt>
<dd>The user name of the user.
This should be different from the user names of existing users.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>
<p>Contains the following keys:</p>
<ul>
<li><code>status</code>: whether the create action was successful</li>
<li><code>messages</code>: messages issued during the process</li>
<li><code>name</code>: the name under which the new user has been saved</li>
</ul>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/23c61c878149a0c80bf432c2e0e320f5e806d778/src/control/content.py#L597-L615" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def createUser(self, user):
    &#34;&#34;&#34;Creates a new user with a given user name.

    Parameters
    ----------
    user: string
        The user name of the user.
        This should be different from the user names of existing users.

    Returns
    -------
    dict
        Contains the following keys:

        * `status`: whether the create action was successful
        * `messages`: messages issued during the process
        * `name`: the name under which the new user has been saved
    &#34;&#34;&#34;
    return Admin(self).createUser(user)</code></pre>
</details>
</dd>
<dt id="control.content.Content.deleteFile"><code class="name flex">
<span>def <span class="ident">deleteFile</span></span>(<span>self, record, key, path, fileName, targetFileName=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Deletes a file in the context given by a record.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>record</code></strong> :&ensp;<code>string | ObjectId | AttrDict | void</code></dt>
<dd>The relevant record.</dd>
<dt><strong><code>key</code></strong> :&ensp;<code>string</code></dt>
<dd>The upload key</dd>
<dt><strong><code>path</code></strong> :&ensp;<code>string</code></dt>
<dd>The path from the context directory to the file</dd>
<dt><strong><code>fileName</code></strong> :&ensp;<code>string</code></dt>
<dd>Name
of the file to be saved as mentioned in the request.</dd>
<dt><strong><code>targetFileName</code></strong> :&ensp;<code>string</code>, optional <code>None</code></dt>
<dd>The name of the file as which the uploaded file will be saved;
if None, the file will be saved with the name from the request.</dd>
</dl>
<h2 id="return">Return</h2>
<p>response
A json response with the status of the save operation:</p>
<pre><code>* a boolean: whether the save succeeded
* a message: messages to display
* content: new content for an upload control (only if successful)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/23c61c878149a0c80bf432c2e0e320f5e806d778/src/control/content.py#L1814-L1883" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def deleteFile(self, record, key, path, fileName, targetFileName=None):
    &#34;&#34;&#34;Deletes a file in the context given by a record.

    Parameters
    ----------
    record: string | ObjectId | AttrDict | void
        The relevant record.
    key: string
        The upload key
    path: string
        The path from the context directory to the file
    fileName: string
        Name  of the file to be saved as mentioned in the request.
    targetFileName: string, optional None
        The name of the file as which the uploaded file will be saved;
        if None, the file will be saved with the name from the request.

    Return
    ------
    response
        A json response with the status of the save operation:

        * a boolean: whether the save succeeded
        * a message: messages to display
        * content: new content for an upload control (only if successful)
    &#34;&#34;&#34;
    Settings = self.Settings
    Messages = self.Messages
    Mongo = self.Mongo
    Auth = self.Auth
    workingDir = Settings.workingDir

    uploadConfig = self.getUploadConfig(key)
    table = uploadConfig.table

    (recordId, record) = Mongo.get(table, record)
    if recordId is None:
        return jsonify(status=False, msgs=[[&#34;warning&#34;, &#34;record does not exist&#34;]])

    permitted = Auth.authorise(table, record, action=&#34;update&#34;)

    sep = &#34;/&#34; if path else &#34;&#34;
    filePath = f&#34;{path}{sep}{fileName}&#34;
    fileFullPath = f&#34;{workingDir}/{filePath}&#34;

    if not permitted:
        logmsg = f&#34;Delete file not permitted: {key}: {fileFullPath}&#34;
        msg = f&#34;Delete not permitted: {fileName}&#34;
        Messages.warning(logmsg=logmsg)
        return jsonify(status=False, msgs=[[&#34;warning&#34;, msg]])

    if not fileExists(fileFullPath):
        logmsg = f&#34;File does not exist: {key}: {fileFullPath}&#34;
        msg = f&#34;File does not exist: {fileName}&#34;
        Messages.warning(logmsg=logmsg)
        return jsonify(status=False, msgs=[[&#34;warning&#34;, msg]])

    try:
        fileRemove(fileFullPath)
    except Exception:
        logmsg = f&#34;Could not delete file: {key}: {fileFullPath}&#34;
        msg = f&#34;File not deleted: {fileName}&#34;
        Messages.warning(logmsg=logmsg)
        return jsonify(status=False, msgs=[[&#34;error&#34;, msg]])

    content = self.getUpload(
        record, key, fileName=targetFileName, bust=fileName, wrapped=False
    )

    return jsonify(status=True, msgs=[[&#34;good&#34;, &#34;Done&#34;]], content=content)</code></pre>
</details>
</dd>
<dt id="control.content.Content.deleteItem"><code class="name flex">
<span>def <span class="ident">deleteItem</span></span>(<span>self, table, record)</span>
</code></dt>
<dd>
<div class="desc"><p>Deletes an item, project or edition.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>table</code></strong> :&ensp;<code>string</code></dt>
<dd>The kind of item: <code>project</code> or <code>edition</code>.</dd>
<dt><strong><code>record</code></strong> :&ensp;<code>string | ObjectId | AttrDict</code></dt>
<dd>The item in question.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>boolean</code></dt>
<dd>Whether the deletion was successful.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/23c61c878149a0c80bf432c2e0e320f5e806d778/src/control/content.py#L308-L403" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def deleteItem(self, table, record):
    &#34;&#34;&#34;Deletes an item, project or edition.

    Parameters
    ----------
    table: string
        The kind of item: `project` or `edition`.
    record: string | ObjectId | AttrDict
        The item in question.

    Returns
    -------
    boolean
        Whether the deletion was successful.
    &#34;&#34;&#34;
    Settings = self.Settings
    Messages = self.Messages
    Mongo = self.Mongo
    Auth = self.Auth
    workingDir = Settings.workingDir

    (recordId, record) = Mongo.get(table, record)
    if recordId is None:
        Messages.warning(
            msg=f&#34;Delete {table}: no such {table}&#34;,
            logmsg=f&#34;Delete {table}: no {table} {recordId}&#34;,
        )
        return None

    permitted = Auth.authorise(table, record, action=&#34;delete&#34;)
    if not permitted:
        return None

    details = self.getDetailRecords(table, record)
    nDetails = len(details)
    if nDetails:
        Messages.warning(
            msg=f&#34;Cannot delete {table} because it has {nDetails} detail records&#34;,
            logmsg=f&#34;Delete {table} {recordId} prevented: {nDetails} details&#34;,
        )
        return None

    good = True

    links = self.getLinkedCrit(table, record)

    if links:
        for linkTable, linkCriteria in links.items():
            (thisGood, count) = Mongo.deleteRecords(
                linkTable, stop=False, **linkCriteria
            )
            if not thisGood:
                good = False
                Messages.error(
                    stop=False,
                    msg=f&#34;Error during removing link records from {linkTable}&#34;,
                    logmsg=(
                        &#34;Cannot delete records from &#34;
                        f&#34;{linkTable} by {linkCriteria}&#34;
                    ),
                )
                break

            Messages.info(
                msg=f&#34;Deleted {count} link records from {linkTable}&#34;,
                logmsg=f&#34;Deleted {count} link records from {linkTable}&#34;,
            )

    if not good:
        return False

    good = Mongo.deleteRecord(table, _id=recordId)

    if not good:
        return False

    itemDirHead = workingDir
    itemDirTail = f&#34;{table}/{recordId}&#34;
    if table == &#34;edition&#34;:
        projectId = record.projectId
        itemDirHead += f&#34;/project/{projectId}&#34;
    itemDir = f&#34;{itemDirHead}/{itemDirTail}&#34;

    if dirExists(itemDir):
        dirRemove(itemDir)
        Messages.info(
            msg=f&#34;The {table} directory is removed&#34;,
            logmsg=f&#34;The {table} dir {itemDir} is removed&#34;,
        )
    else:
        Messages.warning(
            msg=f&#34;The {table} directory on file system did not exist&#34;,
            logmsg=f&#34;The {table} dir {itemDir} did not exist&#34;,
        )

    return True</code></pre>
</details>
</dd>
<dt id="control.content.Content.deleteUser"><code class="name flex">
<span>def <span class="ident">deleteUser</span></span>(<span>self, user)</span>
</code></dt>
<dd>
<div class="desc"><p>Deletes a test user with a given user name.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>user</code></strong> :&ensp;<code>string</code></dt>
<dd>The user name of the user.
This should be a test user, not linked to any project or edition.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>
<p>Contains the following keys:</p>
<ul>
<li><code>status</code>: whether the create action was successful</li>
<li><code>messages</code>: messages issued during the process</li>
</ul>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/23c61c878149a0c80bf432c2e0e320f5e806d778/src/control/content.py#L617-L634" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def deleteUser(self, user):
    &#34;&#34;&#34;Deletes a test user with a given user name.

    Parameters
    ----------
    user: string
        The user name of the user.
        This should be a test user, not linked to any project or edition.

    Returns
    -------
    dict
        Contains the following keys:

        * `status`: whether the create action was successful
        * `messages`: messages issued during the process
    &#34;&#34;&#34;
    return Admin(self).deleteUser(user)</code></pre>
</details>
</dd>
<dt id="control.content.Content.download"><code class="name flex">
<span>def <span class="ident">download</span></span>(<span>self, table, record)</span>
</code></dt>
<dd>
<div class="desc"><p>Responds with a download of a project or edition.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>table</code></strong> :&ensp;<code>string</code></dt>
<dd>The table where the item to be downloaded sits.</dd>
<dt><strong><code>record</code></strong> :&ensp;<code>string</code></dt>
<dd>The record of the item to be downloaded.</dd>
</dl>
<h2 id="return">Return</h2>
<p>response
A download response.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/23c61c878149a0c80bf432c2e0e320f5e806d778/src/control/content.py#L1352-L1471" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def download(self, table, record):
    &#34;&#34;&#34;Responds with a download of a project or edition.

    Parameters
    ----------
    table: string
        The table where the item to be downloaded sits.
    record: string
        The record of the item to be downloaded.

    Return
    ------
    response
        A download response.
    &#34;&#34;&#34;
    Settings = self.Settings
    Messages = self.Messages
    Mongo = self.Mongo
    Auth = self.Auth
    dataDir = Settings.dataDir
    workingDir = Settings.workingDir
    runMode = Settings.runMode

    (recordId, record) = Mongo.get(table, record)
    if recordId is None:
        return jsonify(status=False, msgs=[[&#34;warning&#34;, &#34;record does not exist&#34;]])

    permitted = Auth.authorise(table, record, action=&#34;read&#34;)

    if not permitted:
        logmsg = f&#34;Download not permitted: {table}: {recordId}&#34;
        msg = f&#34;Download of {table} not permitted&#34;
        Messages.warning(logmsg=logmsg)
        return jsonify(status=False, msgs=[[&#34;warning&#34;, msg]])

    (siteId, site, projectId, project, editionId, edition) = self.context(
        table, record
    )

    src = f&#34;{workingDir}/project/{projectId}&#34;

    if edition is not None:
        src += f&#34;/edition/{editionId}&#34;

    sep = &#34;/&#34; if dataDir else &#34;&#34;
    tempBase = f&#34;{dataDir}{sep}temp/{runMode}&#34;
    dirMake(tempBase)
    dst = mkdtemp(dir=tempBase)
    Messages.info(logmsg=f&#34;CREATED TEMP DIR {dst}&#34;)

    good = True

    try:
        landing = f&#34;{dst}/{recordId}&#34;
        fileName = f&#34;{table}-{recordId}.zip&#34;

        if edition is None:
            yamlDest = f&#34;{landing}/project.yaml&#34;
        else:
            yamlDest = f&#34;{landing}/edition.yaml&#34;

        dirCopy(src, landing)

        with open(yamlDest, &#34;w&#34;) as yh:
            yaml.dump(Mongo.consolidate(project), yh, allow_unicode=True)

        if edition is None:
            editions = Mongo.getList(&#34;edition&#34;, sort=&#34;title&#34;, projectId=projectId)

            for ed in editions:
                edId = ed._id
                yamlDest = f&#34;{landing}/edition/{edId}/edition.yaml&#34;

                with open(yamlDest, &#34;w&#34;) as yh:
                    yaml.dump(Mongo.consolidate(ed), yh, allow_unicode=True)

        zipBuffer = BytesIO()

        with ZipFile(zipBuffer, &#34;w&#34;, compression=ZIP_DEFLATED) as zipFile:

            def compress(path):
                sep = &#34;/&#34; if path else &#34;&#34;
                with os.scandir(f&#34;{landing}{sep}{path}&#34;) as dh:
                    for entry in dh:
                        name = entry.name
                        if entry.is_file():
                            arcFile = f&#34;{path}{sep}{name}&#34;
                            srcFile = f&#34;{landing}/{arcFile}&#34;
                            zipFile.write(srcFile, arcFile)
                        elif entry.is_dir():
                            compress(f&#34;{path}/{name}&#34;)

            compress(&#34;&#34;)

        zipData = zipBuffer.getvalue()
        Messages.info(msg=f&#34;{table} downloaded&#34;)

    except Exception as e:
        msg = &#34;Could not assemble the data for download&#34;
        Messages.error(msg=msg, logmsg=msg)
        Messages.error(logmsg=&#34;&#34;.join(format_exception(e)), stop=False)
        good = False

    dirRemove(dst)
    Messages.info(logmsg=f&#34;DELETED TEMP DIR {dst}&#34;)

    if good:
        headers = {
            &#34;Expires&#34;: &#34;0&#34;,
            &#34;Cache-Control&#34;: &#34;no-cache, no-store, must-revalidate&#34;,
            &#34;Content-Type&#34;: &#34;application/zip&#34;,
            &#34;Content-Disposition&#34;: f&#39;attachment; filename=&#34;{fileName}&#34;&#39;,
            &#34;Content-Encoding&#34;: &#34;identity&#34;,
        }

        return (zipData, headers)

    else:
        ref = getReferrer().removeprefix(&#34;/&#34;)
        return redirectStatus(f&#34;/{ref}&#34;, False)</code></pre>
</details>
</dd>
<dt id="control.content.Content.generate"><code class="name flex">
<span>def <span class="ident">generate</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Regenerate the HTML for the published site.</p>
<h2 id="return">Return</h2>
<p>response
A publish status response.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/23c61c878149a0c80bf432c2e0e320f5e806d778/src/control/content.py#L1329-L1350" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def generate(self):
    &#34;&#34;&#34;Regenerate the HTML for the published site.

    Return
    ------
    response
        A publish status response.
    &#34;&#34;&#34;
    Messages = self.Messages
    Auth = self.Auth
    Publish = self.Publish

    site = self.relevant()[-1]
    permitted = Auth.authorise(&#34;site&#34;, site, action=&#34;republish&#34;)

    if not permitted:
        logmsg = &#34;Generate pages is not permitted&#34;
        msg = &#34;Generate pages is not permitted&#34;
        Messages.warning(msg=msg, logmsg=logmsg)
        return False

    return Publish.generatePages(None, None)</code></pre>
</details>
</dd>
<dt id="control.content.Content.getAdmin"><code class="name flex">
<span>def <span class="ident">getAdmin</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the list of relevant projects, editions and users.</p>
<p>Admin users get the list of all users.</p>
<p>Normal users get the list of users associated with</p>
<ul>
<li>the project of which they are organiser</li>
<li>the editions of which they are editor or reviewer</li>
</ul>
<p>Guests and not-logged-in users cannot see any user.</p>
<p>If the user has rights to modify the association
between users and projects/editions, he will get
the controls to do so.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>string</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/23c61c878149a0c80bf432c2e0e320f5e806d778/src/control/content.py#L230-L250" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getAdmin(self):
    &#34;&#34;&#34;Get the list of relevant projects, editions and users.

    Admin users get the list of all users.

    Normal users get the list of users associated with

    * the project of which they are organiser
    * the editions of which they are editor or reviewer

    Guests and not-logged-in users cannot see any user.

    If the user has rights to modify the association
    between users and projects/editions, he will get
    the controls to do so.

    Returns
    -------
    string
    &#34;&#34;&#34;
    return Admin(self).wrap()</code></pre>
</details>
</dd>
<dt id="control.content.Content.getDataFile"><code class="name flex">
<span>def <span class="ident">getDataFile</span></span>(<span>self, table, record, path, content=False, lenient=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets a data file from the file system.</p>
<p>All data files are located under a specific directory on the server.
This is the data directory.
Below that the files are organized by projects and editions.
Projects and editions corresponds to records in tables in MongoDB.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>string</code></dt>
<dd>The path of the data file within site/project/edition directory
within the data directory.</dd>
<dt><strong><code>project</code></strong> :&ensp;<code>string | ObjectId | AttrDict</code></dt>
<dd>The id of the project in question.</dd>
<dt><strong><code>edition</code></strong> :&ensp;<code>string | ObjectId | AttrDict</code></dt>
<dd>The id of the edition in question.</dd>
<dt><strong><code>content</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>If True, delivers the content of the file, instead of the path</dd>
<dt><strong><code>lenient</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>If True, do not complain if the file does not exist.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>string</code></dt>
<dd>
<p>The full path of the data file, if it exists.
But if the <code>content</code> parameter is True, we deliver the content of the file.</p>
<p>Otherwise, we raise an error that will lead to a 404 response, except
when <code>lenient</code> is True.</p>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/23c61c878149a0c80bf432c2e0e320f5e806d778/src/control/content.py#L1037-L1130" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getDataFile(self, table, record, path, content=False, lenient=False):
    &#34;&#34;&#34;Gets a data file from the file system.

    All data files are located under a specific directory on the server.
    This is the data directory.
    Below that the files are organized by projects and editions.
    Projects and editions corresponds to records in tables in MongoDB.

    Parameters
    ----------
    path: string
        The path of the data file within site/project/edition directory
        within the data directory.
    project: string | ObjectId | AttrDict
        The id of the project in question.
    edition: string | ObjectId | AttrDict
        The id of the edition in question.
    content: boolean, optional False
        If True, delivers the content of the file, instead of the path
    lenient: boolean, optional False
        If True, do not complain if the file does not exist.

    Returns
    -------
    string
        The full path of the data file, if it exists.
        But if the `content` parameter is True, we deliver the content of the file.

        Otherwise, we raise an error that will lead to a 404 response, except
        when `lenient` is True.

    &#34;&#34;&#34;
    Settings = self.Settings
    H = Settings.H
    Messages = self.Messages
    Auth = self.Auth

    workingDir = Settings.workingDir

    (site, siteId, projectId, project, editionId, edition) = self.context(
        table, record
    )

    urlBase = (
        &#34;&#34;
        if project is None
        else f&#34;project/{projectId}&#34;
        if edition is None
        else f&#34;project/{projectId}/edition/{editionId}&#34;
    )
    sep = &#34;/&#34; if urlBase else &#34;&#34;
    base = f&#34;{workingDir}{sep}{urlBase}&#34;

    dataPath = base if path is None else f&#34;{base}/{path}&#34;

    (table, recordId, record) = self.relevant(project=project, edition=edition)
    if recordId is None:
        Messages.error(msg=&#34;record does not exist&#34;)
        return &#34;&#34;

    permitted = Auth.authorise(table, record, action=&#34;read&#34;)

    fexists = fileExists(dataPath)

    if permitted and fexists:
        if content:
            with open(dataPath) as fh:
                result = fh.read()
        else:
            result = dataPath
    else:
        result = (
            &#34;&#34;
            if content
            else dataPath
            if lenient
            else H.span(dataPath, cls=&#34;error&#34;)
        )

        if not lenient:
            logmsg = f&#34;Accessing {dataPath}: &#34;

            if not permitted:
                logmsg += &#34;not allowed. &#34;
            if not fexists:
                logmsg += &#34;does not exist. &#34;

            Messages.error(
                msg=f&#34;Accessing file {path}&#34;,
                logmsg=logmsg,
            )
            result = &#34;&#34; if content else dataPath

    return result</code></pre>
</details>
</dd>
<dt id="control.content.Content.getDownload"><code class="name flex">
<span>def <span class="ident">getDownload</span></span>(<span>self, table, record)</span>
</code></dt>
<dd>
<div class="desc"><p>Display the name and/or upload controls of an uploaded file.</p>
<p>The user may upload model files and a scene file to an edition,
and various png files as icons for projects, edtions, and scenes.
Here we produce the control to do so.</p>
<p>Only if the user has <code>update</code> authorisation, an upload/delete widget
will be returned.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>table</code></strong> :&ensp;<code>string</code></dt>
<dd>The table in which the relevant record sits</dd>
<dt><strong><code>record</code></strong> :&ensp;<code>string | ObjectId | AttrDict</code></dt>
<dd>The relevant record.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>string</code></dt>
<dd>
<p>The name of the file that is currently present, or the indication
that no file is present.</p>
<p>If the user has edit permission for the edition, we display
widgets to upload a new file or to delete the existing file.</p>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/23c61c878149a0c80bf432c2e0e320f5e806d778/src/control/content.py#L807-L849" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getDownload(self, table, record):
    &#34;&#34;&#34;Display the name and/or upload controls of an uploaded file.

    The user may upload model files and a scene file to an edition,
    and various png files as icons for projects, edtions, and scenes.
    Here we produce the control to do so.

    Only if the user has `update` authorisation, an upload/delete widget
    will be returned.

    Parameters
    ----------
    table: string
        The table in which the relevant record sits
    record: string | ObjectId | AttrDict
        The relevant record.

    Returns
    -------
    string
        The name of the file that is currently present, or the indication
        that no file is present.

        If the user has edit permission for the edition, we display
        widgets to upload a new file or to delete the existing file.
    &#34;&#34;&#34;
    Settings = self.Settings
    H = Settings.H
    Mongo = self.Mongo
    Auth = self.Auth

    (recordId, record) = Mongo.get(table, record)
    if recordId is None:
        return &#34;&#34;

    actions = Auth.authorise(table, record)

    if &#34;read&#34; not in actions:
        return &#34;&#34;

    return H.iconx(
        &#34;download&#34;, text=&#34;download&#34;, href=f&#34;/download/{table}/{recordId}&#34;
    )</code></pre>
</details>
</dd>
<dt id="control.content.Content.getEditions"><code class="name flex">
<span>def <span class="ident">getEditions</span></span>(<span>self, project)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the list of the editions of a project.</p>
<p>Well, only if the project is visible to the current user.
See <code><a title="control.content.Content.getProjects" href="#control.content.Content.getProjects">Content.getProjects()</a></code>.</p>
<p>Editions are each displayed by means of an icon and a title.
Both link to a landing page for the edition.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>project</code></strong> :&ensp;<code>string | ObjectId | AttrDict</code></dt>
<dd>The project in question.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>string</code></dt>
<dd>A list of captions of the editions of the project,
wrapped in a HTML string.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/23c61c878149a0c80bf432c2e0e320f5e806d778/src/control/content.py#L102-L131" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getEditions(self, project):
    &#34;&#34;&#34;Get the list of the editions of a project.

    Well, only if the project is visible to the current user.
    See `Content.getProjects()`.

    Editions are each displayed by means of an icon and a title.
    Both link to a landing page for the edition.

    Parameters
    ----------
    project: string | ObjectId | AttrDict
        The project in question.

    Returns
    -------
    string
        A list of captions of the editions of the project,
        wrapped in a HTML string.
    &#34;&#34;&#34;
    Mongo = self.Mongo
    Wrap = self.Wrap

    (projectId, project) = Mongo.get(&#34;project&#34;, project)
    if projectId is None:
        return &#34;&#34;

    return Wrap.editionsMain(
        project, Mongo.getList(&#34;edition&#34;, sort=&#34;title&#34;, projectId=projectId)
    )</code></pre>
</details>
</dd>
<dt id="control.content.Content.getProjects"><code class="name flex">
<span>def <span class="ident">getProjects</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the list of all projects.</p>
<p>Well, the list of all projects visible to the current user.
Unpublished projects are only visible to users that belong to that project.</p>
<p>Visible projects are each displayed by means of an icon and a title.
Both link to a landing page for the project.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>string</code></dt>
<dd>A list of captions of the projects,
wrapped in a HTML string.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/23c61c878149a0c80bf432c2e0e320f5e806d778/src/control/content.py#L78-L100" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getProjects(self):
    &#34;&#34;&#34;Get the list of all projects.

    Well, the list of all projects visible to the current user.
    Unpublished projects are only visible to users that belong to that project.

    Visible projects are each displayed by means of an icon and a title.
    Both link to a landing page for the project.

    Returns
    -------
    string
        A list of captions of the projects,
        wrapped in a HTML string.
    &#34;&#34;&#34;
    Mongo = self.Mongo
    Wrap = self.Wrap

    (siteTable, siteId, site) = self.relevant()
    if siteId is None:
        return &#34;&#34;

    return Wrap.projectsMain(site, Mongo.getList(&#34;project&#34;, sort=&#34;title&#34;))</code></pre>
</details>
</dd>
<dt id="control.content.Content.getPublishInfo"><code class="name flex">
<span>def <span class="ident">getPublishInfo</span></span>(<span>self, table, record)</span>
</code></dt>
<dd>
<div class="desc"><p>Display the number under which a project/edition is published.</p>
<p>Editions of a project may have been published. If that is the case,
the project has been assigned a sequence number, under which it can be
found on the static site with published material.</p>
<p>Here we collect that number, and, for editions, we may put a publish
button here.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>table</code></strong> :&ensp;<code>string</code></dt>
<dd>The table in which the relevant record sits</dd>
<dt><strong><code>record</code></strong> :&ensp;<code>string | ObjectId | AttrDict</code></dt>
<dd>The relevant record.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>string</code></dt>
<dd>In case of a project: the number of the project on the static site.
In case of an edition: the number of the project and the number of the
edition on the static site. If the edition is not yet published, and
the user is allowed to publish the edition, then a publish button is
also added.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/23c61c878149a0c80bf432c2e0e320f5e806d778/src/control/content.py#L851-L999" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getPublishInfo(self, table, record):
    &#34;&#34;&#34;Display the number under which a project/edition is published.

    Editions of a project may have been published. If that is the case,
    the project has been assigned a sequence number, under which it can be
    found on the static site with published material.

    Here we collect that number, and, for editions, we may put a publish
    button here.

    Parameters
    ----------
    table: string
        The table in which the relevant record sits
    record: string | ObjectId | AttrDict
        The relevant record.

    Returns
    -------
    string
        In case of a project: the number of the project on the static site.
        In case of an edition: the number of the project and the number of the
        edition on the static site. If the edition is not yet published, and
        the user is allowed to publish the edition, then a publish button is
        also added.
    &#34;&#34;&#34;
    Settings = self.Settings

    H = Settings.H
    Mongo = self.Mongo
    Auth = self.Auth

    pubUrl = Settings.pubUrl
    published = Settings.published

    (recordId, record) = Mongo.get(table, record)
    if recordId is None:
        return &#34;&#34;

    actions = Auth.authorise(table, record)

    if &#34;read&#34; not in actions or table not in {&#34;project&#34;, &#34;edition&#34;}:
        return &#34;&#34;

    (site, siteId, projectId, project, editionId, edition) = self.context(
        table, record
    )

    pPubNum = project.pubNum

    projectPubStr = (
        H.i(&#34;No published editions&#34;)
        if pPubNum is None
        else H.span(&#34;Published: &#34;)
        + H.a(
            f&#34;{pPubNum} ⌲&#34;,
            f&#34;{pubUrl}/project/{pPubNum}/index.html&#34;,
            target=published,
            cls=&#34;button large&#34;,
        )
    )

    if table == &#34;project&#34;:
        return H.p(projectPubStr)

    ePubNum = edition.pubNum

    editionPubRow = (
        (
            H.i(&#34;Not published&#34;)
            if ePubNum is None or pPubNum is None
            else H.span(&#34;Published: &#34;)
        ),
        H.a(
            f&#34;{pPubNum}/{ePubNum} ⌲&#34;,
            f&#34;{pubUrl}/project/{pPubNum}/edition/{ePubNum}/index.html&#34;,
            target=published,
            cls=&#34;button large&#34;,
        ),
    )

    can = dict(
        precheck=True,
        publish=ePubNum is None,
        unpublish=pPubNum is not None and ePubNum is not None,
        republish=pPubNum is not None and ePubNum is not None,
    )

    rows = []

    for kind, kindRep, tbRecRoles in (
        (
            &#34;precheck&#34;,
            &#34;check articles&#34;,
            (
                (&#34;edition&#34;, edition, &#34;editor&#34;),
                (&#34;project&#34;, project, &#34;organiser&#34;),
                (&#34;site&#34;, site, &#34;admin&#34;),
                (&#34;site&#34;, site, &#34;root&#34;),
            ),
        ),
        (&#34;publish&#34;, &#34;publish&#34;, ((&#34;project&#34;, project, &#34;organiser&#34;),)),
        (
            (&#34;publishf&#34;, &#34;publish&#34;),
            &#34;force-publish&#34;,
            ((&#34;project&#34;, project, &#34;organiser&#34;),),
        ),
        (
            &#34;republish&#34;,
            &#34;re-publish&#34;,
            ((&#34;site&#34;, site, &#34;admin&#34;), (&#34;site&#34;, site, &#34;root&#34;)),
        ),
        (
            (&#34;republishf&#34;, &#34;republish&#34;),
            &#34;force-re-publish&#34;,
            ((&#34;site&#34;, site, &#34;admin&#34;), (&#34;site&#34;, site, &#34;root&#34;)),
        ),
        (
            &#34;unpublish&#34;,
            &#34;un-publish&#34;,
            ((&#34;site&#34;, site, &#34;admin&#34;), (&#34;site&#34;, site, &#34;root&#34;)),
        ),
    ):
        asKind = kind

        if type(kind) is tuple:
            (kind, asKind) = kind

        if can[asKind]:
            rows.append(
                (
                    H.span(f&#34;You may {kindRep}:&#34;),
                    H.iconx(
                        kind,
                        href=f&#34;/{kind}/{recordId}&#34;,
                        cls=&#34;button large&#34;,
                    ),
                )
                if asKind in actions
                else (
                    H.span(f&#34;You may not {kindRep}&#34;),
                    Auth.getInvolvedUsers(tbRecRoles, asString=True),
                )
            )

    return H.table(
        [([(cell, {}) for cell in editionPubRow], {})],
        [([(cell, {}) for cell in row], {}) for row in rows],
    )</code></pre>
</details>
</dd>
<dt id="control.content.Content.getScene"><code class="name flex">
<span>def <span class="ident">getScene</span></span>(<span>self, projectId, edition, version=None, action=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the scene of an edition of a project.</p>
<p>Well, only if the current user is authorised.</p>
<p>A scene is displayed by means of an icon and a row of buttons.</p>
<p>There are also buttons to upload model files and the scene file.</p>
<p>If action is not None, the scene is loaded in a specific version of the
viewer in a specific mode (<code>read</code> or <code>edit</code>).
The edition knows which viewer to choose.</p>
<p>Which version and which mode are used is determined by the parameters.
If the parameters do not specify values, sensible defaults are chosen.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>projectId</code></strong> :&ensp;<code>ObjectId</code></dt>
<dd>The id of the project to which the edition belongs.</dd>
<dt><strong><code>edition</code></strong> :&ensp;<code>string | ObjectId | AttrDict</code></dt>
<dd>The edition in question.</dd>
<dt><strong><code>version</code></strong> :&ensp;<code>string</code>, optional <code>None</code></dt>
<dd>The version of the chosen viewer that will be used.
If no version or a non-existing version are specified,
the latest existing version for that viewer will be chosen.</dd>
<dt><strong><code>action</code></strong> :&ensp;<code>string</code>, optional <code>read</code></dt>
<dd>The mode in which the viewer should be opened.
If the mode is <code>update</code>, the viewer is opened in edit mode, if the
scene file exists, otherwise in create mode,
which, in case
of the Voyager viewer, means <code>dragdrop</code> mode, in older versions
<code>standalone</code>.
All other modes lead to the viewer being opened in read-only
mode.
If the mode is read-only, but the scene file is missing, no viewer
will be opened.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>string</code></dt>
<dd>A caption of the scene of the edition,
with possibly a frame with the 3D viewer showing the scene.
The result is wrapped in a HTML string.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/23c61c878149a0c80bf432c2e0e320f5e806d778/src/control/content.py#L133-L228" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getScene(self, projectId, edition, version=None, action=None):
    &#34;&#34;&#34;Get the scene of an edition of a project.

    Well, only if the current user is authorised.

    A scene is displayed by means of an icon and a row of buttons.

    There are also buttons to upload model files and the scene file.

    If action is not None, the scene is loaded in a specific version of the
    viewer in a specific mode (`read` or `edit`).
    The edition knows which viewer to choose.

    Which version and which mode are used is determined by the parameters.
    If the parameters do not specify values, sensible defaults are chosen.

    Parameters
    ----------
    projectId: ObjectId
        The id of the project to which the edition belongs.
    edition: string | ObjectId | AttrDict
        The edition in question.
    version: string, optional None
        The version of the chosen viewer that will be used.
        If no version or a non-existing version are specified,
        the latest existing version for that viewer will be chosen.
    action: string, optional read
        The mode in which the viewer should be opened.
        If the mode is `update`, the viewer is opened in edit mode, if the
        scene file exists, otherwise in create mode,  which, in case
        of the Voyager viewer, means `dragdrop` mode, in older versions
        `standalone`.
        All other modes lead to the viewer being opened in read-only
        mode.
        If the mode is read-only, but the scene file is missing, no viewer
        will be opened.

    Returns
    -------
    string
        A caption of the scene of the edition,
        with possibly a frame with the 3D viewer showing the scene.
        The result is wrapped in a HTML string.
    &#34;&#34;&#34;
    Settings = self.Settings
    H = Settings.H
    workingDir = Settings.workingDir
    modelzFile = Settings.modelzFile
    Mongo = self.Mongo
    Viewers = self.Viewers
    Wrap = self.Wrap

    (editionId, edition) = Mongo.get(&#34;edition&#34;, edition)
    if editionId is None:
        return &#34;&#34;

    (viewer, sceneFile) = Viewers.getViewInfo(edition)
    version = Viewers.check(viewer, version)

    if sceneFile is None:
        sceneExists = False
        baseResult = &#34;&#34;
    else:
        scenePath = (
            f&#34;{workingDir}/project/{projectId}/edition/{editionId}/{sceneFile}&#34;
        )
        sceneExists = fileExists(scenePath)
        baseResult = Wrap.sceneMain(
            projectId, edition, sceneFile, viewer, version, action, sceneExists
        )

    if action is None:
        action = &#34;read&#34;

    zipUpload = (
        &#34;&#34;
        if sceneExists or sceneFile is None
        else (
            H.h(4, &#34;Scene plus model files, zipped&#34;)
            + H.div(self.getUpload(edition, &#34;modelz&#34;, fileName=modelzFile))
        )
    )
    sceneUpload = (
        &#34;&#34;
        if sceneFile is None
        else H.div(self.getUpload(edition, &#34;scene&#34;, fileName=sceneFile))
    )

    return (
        baseResult
        + H.h(4, &#34;Scene&#34; if sceneExists else &#34;No scene yet&#34;)
        + sceneUpload
        + H.h(4, &#34;Model files&#34;)
        + H.div(self.getUpload(edition, &#34;model&#34;))
        + zipUpload
    )</code></pre>
</details>
</dd>
<dt id="control.content.Content.getSurprise"><code class="name flex">
<span>def <span class="ident">getSurprise</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the data that belongs to the surprise-me functionality.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/23c61c878149a0c80bf432c2e0e320f5e806d778/src/control/content.py#L72-L76" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getSurprise(self):
    &#34;&#34;&#34;Get the data that belongs to the surprise-me functionality.&#34;&#34;&#34;
    Settings = self.Settings
    H = Settings.H
    return H.h(2, &#34;You will be surprised!&#34;)</code></pre>
</details>
</dd>
<dt id="control.content.Content.getUpload"><code class="name flex">
<span>def <span class="ident">getUpload</span></span>(<span>self, record, key, fileName=None, bust=None, wrapped=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Display the name and/or upload controls of an uploaded file.</p>
<p>The user may upload model files and a scene file to an edition,
and various png files as icons for projects, edtions, and scenes.
Here we produce the control to do so.</p>
<p>Only if the user has <code>update</code> authorisation, an upload/delete widget
will be returned.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>record</code></strong> :&ensp;<code>string | ObjectId | AttrDict | void</code></dt>
<dd>The relevant record.</dd>
<dt><strong><code>key</code></strong> :&ensp;<code>string</code></dt>
<dd>an identifier for the upload field.</dd>
<dt><strong><code>fileName</code></strong> :&ensp;<code>string</code>, optional <code>None</code></dt>
<dd>If present, it indicates that the uploaded file will have this prescribed
name.
A file name for an upload object may also have been specified in
the datamodel configuration.</dd>
<dt><strong><code>bust</code></strong> :&ensp;<code>string</code>, optional <code>None</code></dt>
<dd>
<p>If not None, the image url of the file whose name is passed in
<code>bust</code> is made unique by adding the current time to it. That will
bust the cache for the image, so that uploaded images replace the
existing images.</p>
<p>This is useful when this function is called to provide udated
content for an file upload widget after it has been used to
successfully upload a file. The file name of the uploaded
file is known, and that is the one that gets a cache buster appended.</p>
</dd>
<dt><strong><code>wrapped</code></strong> :&ensp;<code>boolean</code>, optional <code>True</code></dt>
<dd>Whether the content should be wrapped in a container element.
See <code><a title="control.html.HtmlElements.finput" href="html.html#control.html.HtmlElements.finput">HtmlElements.finput()</a></code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>string</code></dt>
<dd>
<p>The name of the file that is currently present, or the indication
that no file is present.</p>
<p>If the user has edit permission for the edition, we display
widgets to upload a new file or to delete the existing file.</p>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/23c61c878149a0c80bf432c2e0e320f5e806d778/src/control/content.py#L749-L805" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getUpload(self, record, key, fileName=None, bust=None, wrapped=True):
    &#34;&#34;&#34;Display the name and/or upload controls of an uploaded file.

    The user may upload model files and a scene file to an edition,
    and various png files as icons for projects, edtions, and scenes.
    Here we produce the control to do so.

    Only if the user has `update` authorisation, an upload/delete widget
    will be returned.

    Parameters
    ----------
    record: string | ObjectId | AttrDict | void
        The relevant record.
    key: string
        an identifier for the upload field.
    fileName: string, optional None
        If present, it indicates that the uploaded file will have this prescribed
        name.
        A file name for an upload object may also have been specified in
        the datamodel configuration.
    bust: string, optional None
        If not None, the image url of the file whose name is passed in
        `bust` is made unique by adding the current time to it. That will
        bust the cache for the image, so that uploaded images replace the
        existing images.

        This is useful when this function is called to provide udated
        content for an file upload widget after it has been used to
        successfully upload a file. The file name of the uploaded
        file is known, and that is the one that gets a cache buster appended.
    wrapped: boolean, optional True
        Whether the content should be wrapped in a container element.
        See `control.html.HtmlElements.finput()`.

    Returns
    -------
    string
        The name of the file that is currently present, or the indication
        that no file is present.

        If the user has edit permission for the edition, we display
        widgets to upload a new file or to delete the existing file.
    &#34;&#34;&#34;
    Auth = self.Auth

    uploadConfig = self.getUploadConfig(key)
    table = uploadConfig.table

    actions = Auth.authorise(table, record)

    if &#34;read&#34; not in actions:
        return None

    F = self.makeUpload(key, fileName=fileName)

    return F.formatted(record, &#34;update&#34; in actions, bust=bust, wrapped=wrapped)</code></pre>
</details>
</dd>
<dt id="control.content.Content.getValue"><code class="name flex">
<span>def <span class="ident">getValue</span></span>(<span>self, table, record, key, level=None, manner='formatted')</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve a metadata value.</p>
<p>Metadata sits in a big, potentially deeply nested dictionary of keys
and values.
These locations are known to the system (based on <code>fields.yml</code>).
This function retrieves the information from those known locations.</p>
<p>If a value is in fact composed of multiple values, it will be
handled accordingly.</p>
<p>If the user may edit the value, an edit button is added.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>key</code></strong> :&ensp;<code>string</code></dt>
<dd>an identifier for the meta data field.</dd>
<dt><strong><code>table</code></strong> :&ensp;<code>string</code></dt>
<dd>The relevant table.</dd>
<dt><strong><code>record</code></strong> :&ensp;<code>string | ObjectId | AttrDict | void</code></dt>
<dd>The relevant record.</dd>
<dt><strong><code>level</code></strong> :&ensp;<code>string</code>, optional <code>None</code></dt>
<dd>
<p>The heading level with which the value should be formatted.</p>
<ul>
<li><code>0</code>: No heading level</li>
<li><code>None</code>: no formatting at all</li>
</ul>
</dd>
<dt><strong><code>manner</code></strong> :&ensp;<code>string</code>, optional <code>wrapped</code></dt>
<dd>If it is "formatted", the value is represented fully wrapped in HTML,
possibly with edit/save controls.
If it is "bare", the value is represented as a simple string.
If it is "logical", the logical value is returned.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>string</code></dt>
<dd>It is assumed that the metadata value that is addressed exists.
If not, we return the empty string.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/23c61c878149a0c80bf432c2e0e320f5e806d778/src/control/content.py#L665-L720" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getValue(self, table, record, key, level=None, manner=&#34;formatted&#34;):
    &#34;&#34;&#34;Retrieve a metadata value.

    Metadata sits in a big, potentially deeply nested dictionary of keys
    and values.
    These locations are known to the system (based on `fields.yml`).
    This function retrieves the information from those known locations.

    If a value is in fact composed of multiple values, it will be
    handled accordingly.

    If the user may edit the value, an edit button is added.

    Parameters
    ----------
    key: string
        an identifier for the meta data field.
    table: string
        The relevant table.
    record: string | ObjectId | AttrDict | void
        The relevant record.
    level: string, optional None
        The heading level with which the value should be formatted.

        * `0`: No heading level
        * `None`: no formatting at all

    manner: string, optional wrapped
        If it is &#34;formatted&#34;, the value is represented fully wrapped in HTML,
        possibly with edit/save controls.
        If it is &#34;bare&#34;, the value is represented as a simple string.
        If it is &#34;logical&#34;, the logical value is returned.

    Returns
    -------
    string
        It is assumed that the metadata value that is addressed exists.
        If not, we return the empty string.
    &#34;&#34;&#34;
    Auth = self.Auth

    actions = Auth.authorise(table, record)

    if &#34;read&#34; not in actions:
        return None

    F = self.makeField(key)

    isBare = manner == &#34;bare&#34;
    isLogical = manner == &#34;logical&#34;

    if isBare or isLogical:
        return (F.bare if isBare else F.logical)(record)

    editable = Auth.authorise(table, record, action=&#34;update&#34;)
    return F.formatted(table, record, editable=editable, level=level)</code></pre>
</details>
</dd>
<dt id="control.content.Content.getValues"><code class="name flex">
<span>def <span class="ident">getValues</span></span>(<span>self, table, record, fieldSpecs)</span>
</code></dt>
<dd>
<div class="desc"><p>Puts several pieces of metadata on the web page.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>fieldSpecs</code></strong> :&ensp;<code>string</code></dt>
<dd><code>,</code>-separated list of fieldSpecs</dd>
<dt><strong><code>table</code></strong> :&ensp;<code>string</code></dt>
<dd>The relevant table</dd>
<dt><strong><code>record</code></strong> :&ensp;<code>string | ObjectId | AttrDict | void</code></dt>
<dd>The relevant record</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>string</code></dt>
<dd>The join of the individual results of retrieving metadata value.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/23c61c878149a0c80bf432c2e0e320f5e806d778/src/control/content.py#L722-L747" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getValues(self, table, record, fieldSpecs):
    &#34;&#34;&#34;Puts several pieces of metadata on the web page.

    Parameters
    ----------
    fieldSpecs: string
        `,`-separated list of fieldSpecs
    table: string
        The relevant table
    record: string | ObjectId | AttrDict | void
        The relevant record

    Returns
    -------
    string
        The join of the individual results of retrieving metadata value.
    &#34;&#34;&#34;
    Settings = self.Settings
    H = Settings.H

    return H.content(
        self.getValue(table, record, key, level=level) or &#34;&#34;
        for (key, level) in (
            fieldSpec.strip().split(&#34;@&#34;, 1) for fieldSpec in fieldSpecs.split(&#34;+&#34;)
        )
    )</code></pre>
</details>
</dd>
<dt id="control.content.Content.getViewerFile"><code class="name flex">
<span>def <span class="ident">getViewerFile</span></span>(<span>self, path)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets a viewer-related file from the file system.</p>
<p>This is about files that are part of the viewer software.</p>
<p>The viewer software is located in a specific directory on the server.
This is the viewer base.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>string</code></dt>
<dd>The path of the viewer file within viewer base.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>string</code></dt>
<dd>The full path to the viewer file, if it exists.
Otherwise, we raise an error that will lead to a 404 response.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/23c61c878149a0c80bf432c2e0e320f5e806d778/src/control/content.py#L1001-L1035" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getViewerFile(self, path):
    &#34;&#34;&#34;Gets a viewer-related file from the file system.

    This is about files that are part of the viewer software.

    The viewer software is located in a specific directory on the server.
    This is the viewer base.

    Parameters
    ----------
    path: string
        The path of the viewer file within viewer base.

    Returns
    -------
    string
        The full path to the viewer file, if it exists.
        Otherwise, we raise an error that will lead to a 404 response.
    &#34;&#34;&#34;
    Settings = self.Settings
    Messages = self.Messages

    viewerDir = Settings.viewerDir

    viewerPath = f&#34;{viewerDir}/{path}&#34;

    if not fileExists(viewerPath):
        logmsg = f&#34;Accessing {viewerPath}: &#34;
        logmsg += &#34;does not exist. &#34;
        Messages.error(
            msg=&#34;Accessing a file&#34;,
            logmsg=logmsg,
        )

    return viewerPath</code></pre>
</details>
</dd>
<dt id="control.content.Content.linkUser"><code class="name flex">
<span>def <span class="ident">linkUser</span></span>(<span>self, table, recordId)</span>
</code></dt>
<dd>
<div class="desc"><p>Links a user in certain role to a project/edition record.</p>
<p>The user and role are given by the request.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>table</code></strong> :&ensp;<code>string</code></dt>
<dd>The relevant table.</dd>
<dt><strong><code>recordId</code></strong> :&ensp;<code>string</code></dt>
<dd>The id of the relevant record,
which can be used to locate the cross record between the
user table and the project/edition record where the user's
role is stored.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>
<p>Contains the following keys:</p>
<ul>
<li><code>status</code>: whether the save action was successful</li>
<li><code>messages</code>: messages issued during the process</li>
<li><code>updated</code>: if the action was successful, all user management info
will be passed back and will replace the currently displayed
material.</li>
</ul>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/23c61c878149a0c80bf432c2e0e320f5e806d778/src/control/content.py#L636-L663" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def linkUser(self, table, recordId):
    &#34;&#34;&#34;Links a user in certain role to a project/edition record.

    The user and role are given by the request.

    Parameters
    ----------
    table: string
        The relevant table.
    recordId: string
        The id of the relevant record,
        which can be used to locate the cross record between the
        user table and the project/edition record where the user&#39;s
        role is stored.

    Returns
    -------
    dict
        Contains the following keys:

        * `status`: whether the save action was successful
        * `messages`: messages issued during the process
        * `updated`: if the action was successful, all user management info
          will be passed back and will replace the currently displayed
          material.
    &#34;&#34;&#34;
    (newRole, newUser) = json.loads(requestData())
    return Admin(self).linkUser(newUser, newRole, table, recordId)</code></pre>
</details>
</dd>
<dt id="control.content.Content.precheck"><code class="name flex">
<span>def <span class="ident">precheck</span></span>(<span>self, record)</span>
</code></dt>
<dd>
<div class="desc"><p>Check the articles of an edition prior to publishing.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>record</code></strong> :&ensp;<code>string</code></dt>
<dd>The record of the edition to be checked.</dd>
</dl>
<h2 id="return">Return</h2>
<p>response
A status response.</p>
<pre><code>It will also generate a a bunch of toc files in the edition.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/23c61c878149a0c80bf432c2e0e320f5e806d778/src/control/content.py#L1165-L1204" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def precheck(self, record):
    &#34;&#34;&#34;Check the articles of an edition prior to publishing.

    Parameters
    ----------
    record: string
        The record of the edition to be checked.

    Return
    ------
    response
        A status response.

        It will also generate a a bunch of toc files in the edition.
    &#34;&#34;&#34;
    Messages = self.Messages
    Mongo = self.Mongo
    Auth = self.Auth
    Publish = self.Publish

    (recordId, record) = Mongo.get(&#34;edition&#34;, record)
    if recordId is None:
        Messages.error(
            msg=&#34;record does not exist&#34;, logmsg=f&#34;edition {recordId} does not exist&#34;
        )
        return False

    permitted = Auth.authorise(&#34;edition&#34;, record, action=&#34;precheck&#34;)

    if not permitted:
        logmsg = f&#34;Checking articles not permitted: edition: {recordId}&#34;
        msg = &#34;Checking articles of edition not permitted&#34;
        Messages.warning(msg=msg, logmsg=logmsg)
        return False

    (siteId, site, projectId, project, editionId, edition) = self.context(
        &#34;edition&#34;, record
    )

    return Publish.Precheck.checkEdition(project, editionId, edition)</code></pre>
</details>
</dd>
<dt id="control.content.Content.processModelZip"><code class="name flex">
<span>def <span class="ident">processModelZip</span></span>(<span>self, zf, destDir)</span>
</code></dt>
<dd>
<div class="desc"><p>Processes zip data with a scene and model files.</p>
<p>All files in the zip file will be examined, and those with
extension svx.json will be saved as scene.svx.json at top level
and those with extensions glb of gltf will be saved under their
own names, also at top level.</p>
<p>All other files will be saved as is, unless they have extension .svx.json,
or .gltf or .glb.</p>
<p>These files can end up in subdirectories.</p>
<p>We do not check the file types of the member files other than the svx.json files
and the model files (glb, gltf).
If the file type for these files does not match their extensions, they will be
ignored.</p>
<p>The user is held responsible to submit a suitable file.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>zf</code></strong> :&ensp;<code>bytes</code></dt>
<dd>The raw zip data</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/23c61c878149a0c80bf432c2e0e320f5e806d778/src/control/content.py#L1697-L1812" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def processModelZip(self, zf, destDir):
    &#34;&#34;&#34;Processes zip data with a scene and model files.

    All files in the zip file will be examined, and those with
    extension svx.json will be saved as scene.svx.json at top level
    and those with extensions glb of gltf will be saved under their
    own names, also at top level.

    All other files will be saved as is, unless they have extension .svx.json,
    or .gltf or .glb.

    These files can end up in subdirectories.

    We do not check the file types of the member files other than the svx.json files
    and the model files (glb, gltf).
    If the file type for these files does not match their extensions, they will be
    ignored.

    The user is held responsible to submit a suitable file.

    Parameters
    ----------
    zf: bytes
        The raw zip data
    &#34;&#34;&#34;
    Messages = self.Messages

    msgs = []
    good = True

    try:
        zf = BytesIO(zf)
        z = ZipFile(zf)

        allFiles = 0
        sceneFiles = set()
        modelFiles = set()
        otherFiles = set()

        goodFiles = []

        for zInfo in z.infolist():
            if zInfo.filename[-1] == &#34;/&#34;:
                continue
            if zInfo.filename.startswith(&#34;__MACOS&#34;):
                continue

            allFiles += 1

            zName = zInfo.filename
            zPath = zName.split(&#34;/&#34;)

            if len(zPath) == 1:
                zDir, zFile = &#34;&#34;, zPath[0]
            else:
                zDir = &#34;/&#34;.join(zPath[0:-1])
                zFile = zPath[-1]

            zTest = zFile.lower()
            doFileTypeCheck = False

            if zTest.endswith(&#34;.svx.json&#34;):
                if zDir == &#34;&#34;:
                    sceneFiles.add(zName)
                    doFileTypeCheck = True
                else:
                    msgs.append(
                        (&#34;warning&#34;, f&#34;ignoring non-toplevel scene file {zName}&#34;)
                    )
                    continue
            elif zTest.endswith(&#34;.glb&#34;) or zTest.endswith(&#34;.gltf&#34;):
                if zDir == &#34;&#34;:
                    modelFiles.add(zName)
                    doFileTypeCheck = True
                else:
                    msgs.append(
                        (&#34;warning&#34;, f&#34;ignoring non-toplevel model file {zName}&#34;)
                    )
                    continue
            else:
                otherFiles.add(zName)

            if doFileTypeCheck:
                fileContent = z.read(zInfo)
                (thisGood, theseMsgs) = self.checkFileContent(
                    None, None, zFile, fileContent
                )
                if thisGood:
                    goodFiles.append((zName, fileContent))
                else:
                    good = False
                    msgs.extend(theseMsgs)
            else:
                goodFiles.append((zInfo, None))

        if good:
            for zName, fileContent in goodFiles:
                if fileContent is None:
                    z.extract(zName, path=destDir)
                else:
                    with open(f&#34;{destDir}/{zName}&#34;, mode=&#34;wb&#34;) as fh:
                        fh.write(fileContent)

        nScenes = len(sceneFiles)
        sLabel = &#34;info&#34; if nScenes == 1 else &#34;warning&#34;
        msgs.append((&#34;info&#34;, f&#34;All files in zip: {allFiles:&gt;3}&#34;))
        msgs.append((sLabel, f&#34;Scene files: {nScenes:&gt;3} x&#34;))
        msgs.append((&#34;info&#34;, f&#34;Model files: {len(modelFiles):&gt;3} x&#34;))
        msgs.append((&#34;info&#34;, f&#34;Other files: {len(otherFiles):&gt;3} x&#34;))

    except Exception as e:
        good = False
        msgs.append((&#34;error&#34;, &#34;Something went wrong&#34;))
        Messages.warning(logmsg=str(e))

    return (good, msgs)</code></pre>
</details>
</dd>
<dt id="control.content.Content.publish"><code class="name flex">
<span>def <span class="ident">publish</span></span>(<span>self, record, force)</span>
</code></dt>
<dd>
<div class="desc"><p>Publish an edition.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>record</code></strong> :&ensp;<code>string</code></dt>
<dd>The record of the item to be published.</dd>
<dt><strong><code>force</code></strong> :&ensp;<code>boolean</code></dt>
<dd>If True, ignore when some checks fail</dd>
</dl>
<h2 id="return">Return</h2>
<p>response
A publish status response.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/23c61c878149a0c80bf432c2e0e320f5e806d778/src/control/content.py#L1206-L1245" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def publish(self, record, force):
    &#34;&#34;&#34;Publish an edition.

    Parameters
    ----------
    record: string
        The record of the item to be published.
    force: boolean
        If True, ignore when some checks fail

    Return
    ------
    response
        A publish status response.
    &#34;&#34;&#34;
    Messages = self.Messages
    Mongo = self.Mongo
    Auth = self.Auth
    Publish = self.Publish

    (recordId, record) = Mongo.get(&#34;edition&#34;, record)
    if recordId is None:
        Messages.error(
            msg=&#34;record does not exist&#34;, logmsg=f&#34;edition {recordId} does not exist&#34;
        )
        return False

    permitted = Auth.authorise(&#34;edition&#34;, record, action=&#34;publish&#34;)

    if not permitted:
        logmsg = f&#34;Publish not permitted: edition: {recordId}&#34;
        msg = &#34;Publishing of edition not permitted&#34;
        Messages.warning(msg=msg, logmsg=logmsg)
        return False

    (siteId, site, projectId, project, editionId, edition) = self.context(
        &#34;edition&#34;, record
    )

    return Publish.updateEdition(site, project, edition, &#34;add&#34;, force=force)</code></pre>
</details>
</dd>
<dt id="control.content.Content.republish"><code class="name flex">
<span>def <span class="ident">republish</span></span>(<span>self, record, force)</span>
</code></dt>
<dd>
<div class="desc"><p>Re-ublish an edition.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>record</code></strong> :&ensp;<code>string</code></dt>
<dd>The record of the item to be re-published.</dd>
<dt><strong><code>force</code></strong> :&ensp;<code>boolean</code></dt>
<dd>If True, ignore when some checks fail</dd>
</dl>
<h2 id="return">Return</h2>
<p>response
A re-publish status response.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/23c61c878149a0c80bf432c2e0e320f5e806d778/src/control/content.py#L1247-L1288" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def republish(self, record, force):
    &#34;&#34;&#34;Re-ublish an edition.

    Parameters
    ----------
    record: string
        The record of the item to be re-published.
    force: boolean
        If True, ignore when some checks fail

    Return
    ------
    response
        A re-publish status response.
    &#34;&#34;&#34;
    Messages = self.Messages
    Mongo = self.Mongo
    Auth = self.Auth
    Publish = self.Publish

    (recordId, record) = Mongo.get(&#34;edition&#34;, record)
    if recordId is None:
        Messages.error(
            msg=&#34;record does not exist&#34;, logmsg=f&#34;edition {recordId} does not exist&#34;
        )
        return False

    permitted = Auth.authorise(&#34;edition&#34;, record, action=&#34;republish&#34;)

    if not permitted:
        logmsg = f&#34;Re-publish not permitted: edition: {recordId}&#34;
        msg = &#34;Re-publishing of edition not permitted&#34;
        Messages.warning(msg=msg, logmsg=logmsg)
        return False

    (siteId, site, projectId, project, editionId, edition) = self.context(
        &#34;edition&#34;, record
    )

    return Publish.updateEdition(
        site, project, edition, &#34;add&#34;, force=force, again=True
    )</code></pre>
</details>
</dd>
<dt id="control.content.Content.saveFile"><code class="name flex">
<span>def <span class="ident">saveFile</span></span>(<span>self, record, key, path, fileName, targetFileName=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Saves a file in the context given by a record.</p>
<p>The parameter <code>key</code> refers to a configuration section in the datamodel.
This determines what file type to expect.
We only accept files whose name has an extension that matches the expected
file type.</p>
<p>The key <code>modelz</code> expects a zip file with the files of an edition, in particular
a scene file and model files. We make sure that these files have the
proper type, and we also perform checks on the other parts of the zip file,
namely whether they have decent paths.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>record</code></strong> :&ensp;<code>string | ObjectId | AttrDict | void</code></dt>
<dd>The relevant record.</dd>
<dt><strong><code>key</code></strong> :&ensp;<code>string</code></dt>
<dd>The upload key</dd>
<dt><strong><code>path</code></strong> :&ensp;<code>string</code></dt>
<dd>The path from the context directory to the file</dd>
<dt><strong><code>fileName</code></strong> :&ensp;<code>string</code></dt>
<dd>Name
of the file to be saved as mentioned in the request.</dd>
<dt><strong><code>targetFileName</code></strong> :&ensp;<code>string</code>, optional <code>None</code></dt>
<dd>The name of the file as which the uploaded file will be saved;
if None, the file will be saved with the name from the request.</dd>
</dl>
<h2 id="return">Return</h2>
<p>response
A json response with the status of the save operation:</p>
<pre><code>* a boolean: whether the save succeeded
* a list of messages to display
* content: new content for an upload control (only if successful)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/23c61c878149a0c80bf432c2e0e320f5e806d778/src/control/content.py#L1473-L1571" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def saveFile(self, record, key, path, fileName, targetFileName=None):
    &#34;&#34;&#34;Saves a file in the context given by a record.

    The parameter `key` refers to a configuration section in the datamodel.
    This determines what file type to expect.
    We only accept files whose name has an extension that matches the expected
    file type.

    The key `modelz` expects a zip file with the files of an edition, in particular
    a scene file and model files. We make sure that these files have the
    proper type, and we also perform checks on the other parts of the zip file,
    namely whether they have decent paths.

    Parameters
    ----------
    record: string | ObjectId | AttrDict | void
        The relevant record.
    key: string
        The upload key
    path: string
        The path from the context directory to the file
    fileName: string
        Name  of the file to be saved as mentioned in the request.
    targetFileName: string, optional None
        The name of the file as which the uploaded file will be saved;
        if None, the file will be saved with the name from the request.

    Return
    ------
    response
        A json response with the status of the save operation:

        * a boolean: whether the save succeeded
        * a list of messages to display
        * content: new content for an upload control (only if successful)
    &#34;&#34;&#34;
    fileContent = requestData()  # essential to have this early on in the body
    # if not, the error responses might go wrong in some browsers

    Settings = self.Settings
    H = Settings.H
    Messages = self.Messages
    Mongo = self.Mongo
    Auth = self.Auth
    workingDir = Settings.workingDir

    uploadConfig = self.getUploadConfig(key)
    table = uploadConfig.table

    (recordId, record) = Mongo.get(table, record)
    if recordId is None:
        return jsonify(status=False, msgs=[[&#34;warning&#34;, &#34;record does not exist&#34;]])

    permitted = Auth.authorise(table, record, action=&#34;update&#34;)

    saveName = fileName

    if targetFileName is not None:
        saveName = targetFileName

    filePath = f&#34;{path}{saveName}&#34;
    fileFullPath = f&#34;{workingDir}/{filePath}&#34;

    if not permitted:
        logmsg = f&#34;Upload not permitted: {key}: {fileFullPath}&#34;
        msg = f&#34;Upload not permitted: {fileName}&#34;
        Messages.warning(logmsg=logmsg)
        return jsonify(status=False, msgs=[[&#34;warning&#34;, msg]])

    (good, msgs) = self.checkFileContent(key, targetFileName, fileName, fileContent)

    if not good:
        return jsonify(status=False, msgs=msgs)

    if key == &#34;modelz&#34;:
        destDir = f&#34;{workingDir}/{path}&#34;
        (good, msgs) = self.processModelZip(fileContent, destDir)
        if good:
            return jsonify(
                status=True,
                msgs=msgs,
                content=H.b(&#34;Please refresh the page&#34;, cls=&#34;good&#34;),
            )
        return jsonify(status=False, msgs=msgs)

    try:
        with open(fileFullPath, &#34;wb&#34;) as fh:
            fh.write(fileContent)
    except Exception:
        logmsg = f&#34;Could not save uploaded file: {key}: {fileFullPath}&#34;
        msg = f&#34;Uploaded file not saved: {fileName}&#34;
        Messages.warning(logmsg=logmsg)
        return jsonify(status=False, msgs=[[&#34;warning&#34;, msg]])

    content = self.getUpload(
        record, key, fileName=targetFileName, bust=fileName, wrapped=False
    )

    return jsonify(status=True, msgs=[[&#34;good&#34;, &#34;Done&#34;]], content=content)</code></pre>
</details>
</dd>
<dt id="control.content.Content.saveRole"><code class="name flex">
<span>def <span class="ident">saveRole</span></span>(<span>self, user, table, recordId)</span>
</code></dt>
<dd>
<div class="desc"><p>Saves a role into a user or cross table record.</p>
<p>The role is given by the request.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>user</code></strong> :&ensp;<code>string</code></dt>
<dd>The eppn of the user.</dd>
<dt><strong><code>table</code></strong> :&ensp;<code>string | void</code></dt>
<dd>The relevant table. If not None, it indicates whether we are updating
site-wide roles, otherwise project/edition roles.</dd>
<dt><strong><code>recordId</code></strong> :&ensp;<code>string | void</code></dt>
<dd>The id of the relevant record. If not None, it is a project/edition
record Id, which can be used to locate the cross record between the
user table and the project/edition record where the user's
role is stored.
If None, the user's role is inside the user record.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>
<p>Contains the following keys:</p>
<ul>
<li><code>status</code>: whether the save action was successful</li>
<li><code>messages</code>: messages issued during the process</li>
<li><code>updated</code>: if the action was successful, all user management info
will be passed back and will replace the currently displayed
material.</li>
</ul>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/23c61c878149a0c80bf432c2e0e320f5e806d778/src/control/content.py#L564-L595" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def saveRole(self, user, table, recordId):
    &#34;&#34;&#34;Saves a role into a user or cross table record.

    The role is given by the request.

    Parameters
    ----------
    user: string
        The eppn of the user.
    table: string | void
        The relevant table. If not None, it indicates whether we are updating
        site-wide roles, otherwise project/edition roles.
    recordId: string | void
        The id of the relevant record. If not None, it is a project/edition
        record Id, which can be used to locate the cross record between the
        user table and the project/edition record where the user&#39;s
        role is stored.
        If None, the user&#39;s role is inside the user record.

    Returns
    -------
    dict
        Contains the following keys:

        * `status`: whether the save action was successful
        * `messages`: messages issued during the process
        * `updated`: if the action was successful, all user management info
          will be passed back and will replace the currently displayed
          material.
    &#34;&#34;&#34;
    newRole = json.loads(requestData())
    return Admin(self).saveRole(user, newRole, table, recordId)</code></pre>
</details>
</dd>
<dt id="control.content.Content.saveValue"><code class="name flex">
<span>def <span class="ident">saveValue</span></span>(<span>self, table, record, key)</span>
</code></dt>
<dd>
<div class="desc"><p>Saves a value of into a record.</p>
<p>A record is a document, which is a (nested) dict.
A value is inserted somewhere (deep) in that dict.</p>
<p>The value is given by the request.</p>
<p>Where exactly is given by a path that is stored in the field information,
which is accessible by the key.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>table</code></strong> :&ensp;<code>string</code></dt>
<dd>The relevant table.</dd>
<dt><strong><code>record</code></strong> :&ensp;<code>string | ObjectId | AttrDict | void</code></dt>
<dd>The relevant record.</dd>
<dt><strong><code>key</code></strong> :&ensp;<code>string</code></dt>
<dd>an identifier for the meta data field.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>
<p>Contains the following keys:</p>
<ul>
<li><code>status</code>: whether the save action was successful</li>
<li><code>messages</code>: messages issued during the process</li>
<li><code>readonly</code>: the html of the updated formatted value,
this will replace the currently displayed value.</li>
</ul>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/23c61c878149a0c80bf432c2e0e320f5e806d778/src/control/content.py#L491-L562" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def saveValue(self, table, record, key):
    &#34;&#34;&#34;Saves a value of into a record.

    A record is a document, which is a (nested) dict.
    A value is inserted somewhere (deep) in that dict.

    The value is given by the request.

    Where exactly is given by a path that is stored in the field information,
    which is accessible by the key.

    Parameters
    ----------
    table: string
        The relevant table.
    record: string | ObjectId | AttrDict | void
        The relevant record.

    key: string
        an identifier for the meta data field.

    Returns
    -------
    dict
        Contains the following keys:

        * `status`: whether the save action was successful
        * `messages`: messages issued during the process
        * `readonly`: the html of the updated formatted value,
          this will replace the currently displayed value.
    &#34;&#34;&#34;
    Auth = self.Auth
    Mongo = self.Mongo

    value = json.loads(requestData())
    permitted = Auth.authorise(table, record, action=&#34;update&#34;)

    if not permitted:
        return dict(stat=False, messages=[[&#34;error&#34;, &#34;update not allowed&#34;]])

    F = self.makeField(key)

    nameSpace = F.nameSpace
    fieldPath = F.fieldPath
    tp = F.tp

    (recordId, record) = Mongo.get(table, record)
    if recordId is None:
        return dict(
            stat=False,
            messages=[[&#34;error&#34;, &#34;record does not exist&#34;]],
        )

    sValue = value if tp == &#34;text&#34; else readYaml(value, plain=True, ignore=True)
    nameSpaceRep = &#34;&#34; if not nameSpace else f&#34;{nameSpace}.&#34;
    update = {f&#34;{nameSpaceRep}{fieldPath}&#34;: sValue}
    if key == &#34;title&#34;:
        update[key] = sValue

    if Mongo.updateRecord(table, update, stop=False, _id=recordId) is None:
        return dict(
            stat=False,
            messages=[[&#34;error&#34;, &#34;could not update the record in the database&#34;]],
        )
    else:
        (recordId, record) = Mongo.get(table, recordId)

    return dict(
        stat=True,
        messages=[],
        readonly=F.formatted(table, record, editable=False, level=None),
    )</code></pre>
</details>
</dd>
<dt id="control.content.Content.unpublish"><code class="name flex">
<span>def <span class="ident">unpublish</span></span>(<span>self, record)</span>
</code></dt>
<dd>
<div class="desc"><p>Unpublish an edition.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>record</code></strong> :&ensp;<code>string</code></dt>
<dd>The record of the item to be unpublished.</dd>
</dl>
<h2 id="return">Return</h2>
<p>response
An unpublish status response.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/23c61c878149a0c80bf432c2e0e320f5e806d778/src/control/content.py#L1290-L1327" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def unpublish(self, record):
    &#34;&#34;&#34;Unpublish an edition.

    Parameters
    ----------
    record: string
        The record of the item to be unpublished.

    Return
    ------
    response
        An unpublish status response.
    &#34;&#34;&#34;
    Messages = self.Messages
    Mongo = self.Mongo
    Auth = self.Auth
    Publish = self.Publish

    (recordId, record) = Mongo.get(&#34;edition&#34;, record)
    if recordId is None:
        Messages.error(
            msg=&#34;record does not exist&#34;, logmsg=f&#34;edition {recordId} does not exist&#34;
        )
        return False

    permitted = Auth.authorise(&#34;edition&#34;, record, action=&#34;unpublish&#34;)

    if not permitted:
        logmsg = f&#34;Unpublish not permitted: edition: {recordId}&#34;
        msg = &#34;Unpublishing of edition not permitted&#34;
        Messages.warning(msg=msg, logmsg=logmsg)
        return False

    (siteId, site, projectId, project, editionId, edition) = self.context(
        &#34;edition&#34;, record
    )

    return Publish.updateEdition(site, project, edition, &#34;remove&#34;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="control.datamodel.Datamodel" href="datamodel.html#control.datamodel.Datamodel">Datamodel</a></b></code>:
<ul class="hlist">
<li><code><a title="control.datamodel.Datamodel.context" href="datamodel.html#control.datamodel.Datamodel.context">context</a></code></li>
<li><code><a title="control.datamodel.Datamodel.getDetailRecords" href="datamodel.html#control.datamodel.Datamodel.getDetailRecords">getDetailRecords</a></code></li>
<li><code><a title="control.datamodel.Datamodel.getFieldObject" href="datamodel.html#control.datamodel.Datamodel.getFieldObject">getFieldObject</a></code></li>
<li><code><a title="control.datamodel.Datamodel.getLinkedCrit" href="datamodel.html#control.datamodel.Datamodel.getLinkedCrit">getLinkedCrit</a></code></li>
<li><code><a title="control.datamodel.Datamodel.getUploadConfig" href="datamodel.html#control.datamodel.Datamodel.getUploadConfig">getUploadConfig</a></code></li>
<li><code><a title="control.datamodel.Datamodel.getUploadObject" href="datamodel.html#control.datamodel.Datamodel.getUploadObject">getUploadObject</a></code></li>
<li><code><a title="control.datamodel.Datamodel.getUserWork" href="datamodel.html#control.datamodel.Datamodel.getUserWork">getUserWork</a></code></li>
<li><code><a title="control.datamodel.Datamodel.makeField" href="datamodel.html#control.datamodel.Datamodel.makeField">makeField</a></code></li>
<li><code><a title="control.datamodel.Datamodel.makeUpload" href="datamodel.html#control.datamodel.Datamodel.makeUpload">makeUpload</a></code></li>
<li><code><a title="control.datamodel.Datamodel.relevant" href="datamodel.html#control.datamodel.Datamodel.relevant">relevant</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<p><a href="https://github.com/CLARIAH/pure3dx" title="GitHub repo">GitHub</a></p>
<p><a href="https://github.com/CLARIAH/pure3dx/blob/main/stats.md" title="GitHub repo">code stats</a></p>
<form>
<input id="lunr-search" name="q" placeholder="🔎 Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="control" href="index.html">control</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="control.content.Content" href="#control.content.Content">Content</a></code></h4>
<ul class="two-column">
<li><code><a title="control.content.Content.addAuth" href="#control.content.Content.addAuth">addAuth</a></code></li>
<li><code><a title="control.content.Content.addPublish" href="#control.content.Content.addPublish">addPublish</a></code></li>
<li><code><a title="control.content.Content.breadCrumb" href="#control.content.Content.breadCrumb">breadCrumb</a></code></li>
<li><code><a title="control.content.Content.checkFileContent" href="#control.content.Content.checkFileContent">checkFileContent</a></code></li>
<li><code><a title="control.content.Content.createEdition" href="#control.content.Content.createEdition">createEdition</a></code></li>
<li><code><a title="control.content.Content.createProject" href="#control.content.Content.createProject">createProject</a></code></li>
<li><code><a title="control.content.Content.createUser" href="#control.content.Content.createUser">createUser</a></code></li>
<li><code><a title="control.content.Content.deleteFile" href="#control.content.Content.deleteFile">deleteFile</a></code></li>
<li><code><a title="control.content.Content.deleteItem" href="#control.content.Content.deleteItem">deleteItem</a></code></li>
<li><code><a title="control.content.Content.deleteUser" href="#control.content.Content.deleteUser">deleteUser</a></code></li>
<li><code><a title="control.content.Content.download" href="#control.content.Content.download">download</a></code></li>
<li><code><a title="control.content.Content.generate" href="#control.content.Content.generate">generate</a></code></li>
<li><code><a title="control.content.Content.getAdmin" href="#control.content.Content.getAdmin">getAdmin</a></code></li>
<li><code><a title="control.content.Content.getDataFile" href="#control.content.Content.getDataFile">getDataFile</a></code></li>
<li><code><a title="control.content.Content.getDownload" href="#control.content.Content.getDownload">getDownload</a></code></li>
<li><code><a title="control.content.Content.getEditions" href="#control.content.Content.getEditions">getEditions</a></code></li>
<li><code><a title="control.content.Content.getProjects" href="#control.content.Content.getProjects">getProjects</a></code></li>
<li><code><a title="control.content.Content.getPublishInfo" href="#control.content.Content.getPublishInfo">getPublishInfo</a></code></li>
<li><code><a title="control.content.Content.getScene" href="#control.content.Content.getScene">getScene</a></code></li>
<li><code><a title="control.content.Content.getSurprise" href="#control.content.Content.getSurprise">getSurprise</a></code></li>
<li><code><a title="control.content.Content.getUpload" href="#control.content.Content.getUpload">getUpload</a></code></li>
<li><code><a title="control.content.Content.getValue" href="#control.content.Content.getValue">getValue</a></code></li>
<li><code><a title="control.content.Content.getValues" href="#control.content.Content.getValues">getValues</a></code></li>
<li><code><a title="control.content.Content.getViewerFile" href="#control.content.Content.getViewerFile">getViewerFile</a></code></li>
<li><code><a title="control.content.Content.linkUser" href="#control.content.Content.linkUser">linkUser</a></code></li>
<li><code><a title="control.content.Content.precheck" href="#control.content.Content.precheck">precheck</a></code></li>
<li><code><a title="control.content.Content.processModelZip" href="#control.content.Content.processModelZip">processModelZip</a></code></li>
<li><code><a title="control.content.Content.publish" href="#control.content.Content.publish">publish</a></code></li>
<li><code><a title="control.content.Content.republish" href="#control.content.Content.republish">republish</a></code></li>
<li><code><a title="control.content.Content.saveFile" href="#control.content.Content.saveFile">saveFile</a></code></li>
<li><code><a title="control.content.Content.saveRole" href="#control.content.Content.saveRole">saveRole</a></code></li>
<li><code><a title="control.content.Content.saveValue" href="#control.content.Content.saveValue">saveValue</a></code></li>
<li><code><a title="control.content.Content.unpublish" href="#control.content.Content.unpublish">unpublish</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<a href="https://pure.knaw.nl/portal/en/persons/dirk-roorda">Dirk Roorda</a>
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>