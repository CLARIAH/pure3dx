<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>control.content API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>control.content</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/43bd2e150961ad81f2af6575b1c8f269a7e20738/src/pure3d/control/content.py#L1-L751" class="git-link">Browse git</a>
</summary>
<pre><code class="python">from flask import jsonify
from control.generic import AttrDict
from control.files import fileExists, fileRemove
from control.datamodel import Datamodel
from control.html import HtmlElements as H
from control.flask import data


class Content(Datamodel):
    def __init__(self, Settings, Viewers, Messages, Mongo):
        &#34;&#34;&#34;Retrieving content from database and file system.

        This class has methods to retrieve various pieces of content
        from the data sources, and hand it over to the `control.pages.Pages`
        class that will compose a response out of it.

        It is instantiated by a singleton object.

        Parameters
        ----------
        Settings: `control.generic.AttrDict`
            App-wide configuration data obtained from
            `control.config.Config.Settings`.
        Viewers: object
            Singleton instance of `control.viewers.Viewers`.
        Messages: object
            Singleton instance of `control.messages.Messages`.
        Mongo: object
            Singleton instance of `control.mongo.Mongo`.
        &#34;&#34;&#34;
        super().__init__(Settings, Messages, Mongo)
        self.Viewers = Viewers

    def addAuth(self, Auth):
        &#34;&#34;&#34;Give this object a handle to the Auth object.

        Because of cyclic dependencies some objects require to be given
        a handle to Auth after their initialization.
        &#34;&#34;&#34;
        self.Auth = Auth

    def getSurprise(self):
        &#34;&#34;&#34;Get the data that belongs to the surprise-me functionality.&#34;&#34;&#34;
        return H.h(2, &#34;You will be surprised!&#34;)

    def getProjects(self):
        &#34;&#34;&#34;Get the list of all projects.

        Well, the list of all projects visible to the current user.
        Unpublished projects are only visible to users that belong to that project.

        Visible projects are each displayed by means of an icon and a title.
        Both link to a landing page for the project.

        Returns
        -------
        string
            A list of captions of the projects,
            wrapped in a HTML string.
        &#34;&#34;&#34;
        Mongo = self.Mongo
        Auth = self.Auth

        wrapped = []
        wrapped.append(self.actionButton(&#34;create&#34;, &#34;projects&#34;))

        for record in Mongo.getList(&#34;projects&#34;):
            projectId = record._id
            permitted = Auth.authorise(&#34;projects&#34;, recordId=projectId, action=&#34;read&#34;)
            if not permitted:
                continue

            title = record.title

            projectUrl = f&#34;/projects/{projectId}&#34;
            button = self.actionButton(
                &#34;delete&#34;,
                &#34;projects&#34;,
                recordId=projectId,
            )
            self.debug(f&#34;deletebutton: {button}&#34;)
            visual = self.getUpload(&#34;iconProject&#34;, projectId=projectId)
            caption = self.getCaption(visual, title, button, projectUrl)

            wrapped.append(caption)

        return H.content(*wrapped)

    def insertProject(self):
        Mongo = self.Mongo
        Auth = self.Auth

        permitted = Auth.authorise(&#34;projects&#34;)
        if not permitted:
            return None

        User = Auth.myDetails()
        user = User.sub
        name = User.nickname

        title = &#34;Project without title&#34;

        dcMeta = dict(
            title=title,
            description=dict(abstract=&#34;No intro&#34;, description=&#34;No description&#34;),
            creator=name,
        )
        projectId = Mongo.insertRecord(&#34;projects&#34;, title=title, meta=dict(dc=dcMeta))
        Mongo.insertRecord(
            &#34;projectUsers&#34;,
            projectId=projectId,
            user=user,
            role=&#34;creator&#34;,
        )
        return projectId

    def getEditions(self, projectId):
        &#34;&#34;&#34;Get the list of the editions of a project.

        Well, only if the project is visible to the current user.
        See `Content.getProjects()`.

        Editions are each displayed by means of an icon and a title.
        Both link to a landing page for the edition.

        Parameters
        ----------
        projectId: ObjectId
            The project in question.

        Returns
        -------
        string
            A list of captions of the editions of the project,
            wrapped in a HTML string.
        &#34;&#34;&#34;
        Mongo = self.Mongo
        Auth = self.Auth

        wrapped = []

        for record in Mongo.getList(&#34;editions&#34;, projectId=projectId):
            editionId = record._id
            permitted = Auth.authorise(&#34;editions&#34;, recordId=editionId, action=&#34;read&#34;)
            if not permitted:
                continue

            title = record.title

            editionUrl = f&#34;/editions/{editionId}&#34;
            button = self.actionButton(
                &#34;delete&#34;,
                &#34;editions&#34;,
                recordId=editionId,
            )
            visual = self.getUpload(
                &#34;iconEdition&#34;, projectId=projectId, editionId=editionId
            )
            caption = self.getCaption(visual, title, button, editionUrl)
            wrapped.append(caption)

        wrapped.append(self.actionButton(&#34;create&#34;, &#34;editions&#34;, projectId=projectId))
        return H.content(*wrapped)

    def insertEdition(self, projectId):
        Mongo = self.Mongo
        Auth = self.Auth

        permitted = Auth.authorise(&#34;editions&#34;, projectId=projectId)
        if not permitted:
            return None

        User = Auth.myDetails()
        name = User.nickname

        title = &#34;Edition without title&#34;

        dcMeta = dict(
            title=title,
            description=dict(
                abstract=&#34;No intro&#34;,
                description=&#34;No description&#34;,
                provenance=&#34;No sources&#34;,
            ),
            creator=name,
        )
        editionId = Mongo.insertRecord(
            &#34;editions&#34;, title=title, projectId=projectId, meta=dict(dc=dcMeta)
        )
        return editionId

    def getScenes(
        self,
        projectId,
        editionId,
        sceneId=None,
        viewer=None,
        version=None,
        action=None,
    ):
        &#34;&#34;&#34;Get the list of the scenes of an edition of a project.

        Well, only if the project is visible to the current user.
        See `Content.getProjects()`.

        Scenes are each displayed by means of an icon a title and a row of buttons.
        The title is the file name (without the `.json` extension) of the scene.
        Both link to a landing page for the edition.

        One of the scenes is made *active*, i.e.
        it is loaded in a specific version of a viewer in a specific
        mode (`view` or `edit`).

        Which scene is loaded in which viewer and version in which mode,
        is determined by the parameters.
        If the parameters do not specify values, sensible defaults are chosen.

        Parameters
        ----------
        projectId: ObjectId
            The project in question.
        editionId: ObjectId
            The edition in question.
        sceneId: ObjectId, optional None
            The active scene. If None the default scene is chosen.
            A scene record specifies whether that scene is the default scene for
            that edition.
        viewer: string, optional None
            The viewer to be used for the 3D viewing. It should be a supported viewer.
            If None, the default viewer is chosen.
            The list of those viewers is in the `yaml/viewers.yml` file,
            which also specifies what the default viewer is.
        version: string, optional None
            The version of the chosen viewer that will be used.
            If no version or a non-existing version are specified,
            the latest existing version for that viewer will be chosen.
        action: string, optional `view`
            The mode in which the viewer should be opened.
            If the mode is `edit`, the viewer is opened in edit mode.
            All other modes lead to the viewer being opened in read-only
            mode.

        Returns
        -------
        string
            A list of captions of the scenes of the edition,
            with one caption replaced by a 3D viewer showing the scene.
            The list is wrapped in a HTML string.
        &#34;&#34;&#34;
        Mongo = self.Mongo
        Auth = self.Auth
        Viewers = self.Viewers

        wrapped = []

        actions = Auth.authorise(&#34;editions&#34;, recordId=editionId)
        if &#34;read&#34; not in actions:
            return &#34;&#34;

        (viewer, version) = Viewers.check(viewer, version)

        wrapped = []

        for record in Mongo.getList(&#34;scenes&#34;, editionId=editionId):
            thisSceneId = record._id

            isSceneActive = sceneId is None and record.default or record._id == sceneId
            titleText = H.span(record.name, cls=&#34;entrytitle&#34;)
            button = self.actionButton(
                &#34;delete&#34;,
                &#34;scenes&#34;,
                recordId=thisSceneId,
            )

            if isSceneActive:
                (frame, buttons) = Viewers.getFrame(
                    thisSceneId, actions, viewer, version, action
                )
                title = H.span(titleText, cls=&#34;entrytitle&#34;)
                content = f&#34;&#34;&#34;{frame}{title}{buttons}&#34;&#34;&#34;
                caption = self.wrapCaption(content, button, active=True)
            else:
                sceneUrl = f&#34;/scenes/{record._id}&#34;
                visual = self.getUpload(
                    &#34;iconScene&#34;,
                    projectId=projectId,
                    editionId=editionId,
                    sceneId=thisSceneId,
                )
                caption = self.getCaption(visual, titleText, button, sceneUrl)

            wrapped.append(caption)

        wrapped.append(
            self.actionButton(
                &#34;create&#34;, &#34;scenes&#34;, projectId=projectId, editionId=editionId
            )
        )
        return H.content(*wrapped)

    def insertScene(self, projectId, editionId):
        Mongo = self.Mongo
        Auth = self.Auth

        permitted = Auth.authorise(&#34;scenes&#34;, projectId=projectId)
        if not permitted:
            return None

        User = Auth.myDetails()
        name = User.nickname

        title = &#34;Scene without title&#34;

        dcMeta = dict(
            title=title,
            creator=name,
        )
        sceneId = Mongo.insertRecord(
            &#34;scenes&#34;,
            name=title,
            projectId=projectId,
            editionId=editionId,
            meta=dict(dc=dcMeta),
        )
        return sceneId

    def wrapCaption(self, content, button, active=False):
        activeCls = &#34;active&#34; if active else &#34;&#34;
        return H.div(
            [H.div(content, cls=f&#34;caption {activeCls}&#34;), button], cls=&#34;captioncontent&#34;
        )

    def getCaption(self, visual, titleText, button, url):
        title = H.span(titleText, cls=&#34;entrytitle&#34;)

        # visual = H.img(f&#34;{iconUrlBase}/{icon}&#34;, imgAtts=dict(cls=&#34;previewicon&#34;))
        content = H.a(f&#34;{visual}{title}&#34;, url, cls=&#34;entry&#34;)
        return self.wrapCaption(content, button)

    def getValue(self, key, projectId=None, editionId=None, level=None, bare=False):
        &#34;&#34;&#34;Retrieve a metadata value.

        Metadata sits in a big, potentially deeply nested dictionary of keys
        and values.
        These locations are known to the system (based on `fields.yml`).
        This function retrieves the information from those known locations.

        If a value is in fact composed of multiple values, it will be
        handled accordingly.

        Parameters
        ----------
        key: an identifier for the meta data field.
        projectId: ObjectId, optional None
            The project whose metadata we need. If it is None, we are at the site level.
        editionId: ObjectId, optional None
            The edition whose metadata we need. If it is None, we need metadata of
            a project or outer metadata.
        bare: boolean, optional None
            Get the bare value, without HTML wrapping and without buttons.

        Returns
        -------
        string
            It is assumed that the metadata value that is addressed exists.
            If not, we return the empty string.
        &#34;&#34;&#34;
        Mongo = self.Mongo
        Auth = self.Auth

        if editionId is not None:
            table = &#34;editions&#34;
            crit = dict(_id=editionId)
        elif projectId is not None:
            table = &#34;projects&#34;
            crit = dict(_id=projectId)
        else:
            table = &#34;meta&#34;
            crit = dict(name=&#34;site&#34;)

        record = Mongo.getRecord(table, **crit) or AttrDict()
        recordId = record._id

        permissions = Auth.authorise(table, recordId=recordId, projectId=projectId)

        if &#34;read&#34; not in permissions:
            return None

        F = self.makeField(key)

        if bare:
            return F.bare(record)

        button = self.actionButton(
            &#34;update&#34;,
            table,
            recordId=recordId,
            key=key,
            projectId=projectId,
            editionId=editionId,
        )

        return F.formatted(table, record, level=level, button=button)

    def getUpload(self, key, projectId=None, editionId=None, sceneId=None):
        &#34;&#34;&#34;Display the name and/or upload controls of an uploaded file.

        The user may to upload model files and scene files to an edition,
        and various png files as icons for projects, edtions, and scenes.
        Here we produce the control to do so.

        Only if the user has `update` authorisation, an upload/delete widget will be returned.

        Parameters
        ----------
        key: an identifier for the upload field.
        projectId: ObjectId, optional None
            The project in question. If it is None, we are at the site level.
        editionId: ObjectId, optional None
            The edition in question. If it is None, we are at the project level
            or site level.
        sceneId: ObjectId, optional None
            The scene in question. If it is None, we are at the edition,
            project, or site level.

        Returns
        -------
        string
            The name of the file that is currently present, or the indication
            that no file is present.

            If the user has edit permission for the edition, we display
            widgets to upload a new file or to delete the existing file.
        &#34;&#34;&#34;
        Mongo = self.Mongo
        Auth = self.Auth

        if sceneId is not None:
            table = &#34;scenes&#34;
            crit = dict(_id=sceneId)
        elif editionId is not None:
            table = &#34;editions&#34;
            crit = dict(_id=editionId)
        elif projectId is not None:
            table = &#34;projects&#34;
            crit = dict(_id=projectId)
        else:
            table = &#34;meta&#34;
            crit = dict(name=&#34;site&#34;)

        record = Mongo.getRecord(table, **crit) or AttrDict()
        recordId = record._id

        permissions = Auth.authorise(table, recordId=recordId, projectId=projectId)

        if &#34;read&#34; not in permissions:
            return None

        F = self.makeUpload(key)

        return F.formatted(record, &#34;update&#34; in permissions)

    def getViewerFile(self, path):
        &#34;&#34;&#34;Gets a viewer-related file from the file system.

        This is about files that are part of the viewer software.

        The viewer software is located in a specific directory on the server.
        This is the viewer base.

        Parameters
        ----------
        path: string
            The path of the viewer file within viewer base.

        Returns
        -------
        string
            The full path to the viewer file, if it exists.
            Otherwise, we raise an error that will lead to a 404 response.
        &#34;&#34;&#34;
        Settings = self.Settings
        Messages = self.Messages

        viewerDir = Settings.viewerDir

        viewerPath = f&#34;{viewerDir}/{path}&#34;

        if not fileExists(viewerPath):
            logmsg = f&#34;Accessing {viewerPath}: &#34;
            logmsg += &#34;does not exist. &#34;
            Messages.error(
                msg=&#34;Accessing a file&#34;,
                logmsg=logmsg,
            )

        return viewerPath

    def getData(self, path, projectId=None, editionId=None):
        &#34;&#34;&#34;Gets a data file from the file system.

        All data files are located under a specific directory on the server.
        This is the data directory.
        Below that the files are organized by projects and editions.

        Parameters
        ----------
        path: string
            The path of the data file within project/edition directory
            within the data directory.
        projectId: ObjectId, optional None
            The id of the project in question.
        editionId: ObjectId, optional None
            The id of the edition in question.

        Returns
        -------
        string
            The full path of the data file, if it exists.
            Otherwise, we raise an error that will lead to a 404 response.
        &#34;&#34;&#34;
        Settings = self.Settings
        Messages = self.Messages
        Auth = self.Auth

        workingDir = Settings.workingDir

        urlBase = (
            &#34;&#34;
            if projectId is None
            else f&#34;projects/{projectId}&#34;
            if editionId is None
            else f&#34;projects/{projectId}/editions/{editionId}&#34;
        )
        sep = &#34;/&#34; if urlBase else &#34;&#34;
        base = f&#34;{workingDir}{sep}{urlBase}&#34;

        dataPath = base if path is None else f&#34;{base}/{path}&#34;

        if projectId is None:
            table = &#34;meta&#34;
            recordId = (
                True  # dummy value for authorise, which only tests whether it is falsy
            )
        elif editionId is None:
            table = &#34;projects&#34;
            recordId = projectId
        else:
            table = &#34;editions&#34;
            recordId = editionId
        permitted = Auth.authorise(table, recordId=recordId, action=&#34;read&#34;)

        fexists = fileExists(dataPath)
        if not permitted or not fexists:
            logmsg = f&#34;Accessing {dataPath}: &#34;
            if not permitted:
                logmsg += &#34;not allowed. &#34;
            if not fexists:
                logmsg += &#34;does not exist. &#34;
            Messages.error(
                msg=f&#34;Accessing file {path}&#34;,
                logmsg=logmsg,
            )

        return dataPath

    def getItem(self, table, *args, **kwargs):
        &#34;&#34;&#34;Get a all information about an item.

        The item can be a project, edition, or scene.
        The information about that item is a record in MongoDb.
        possibly additional files on the file system.

        Parameters
        ----------
        table: string
            The name of the table from which to fetch an item
        *args, **kwargs: any
            Additional arguments to select the item&#39;s record
            from MongoDB

        Returns
        -------
        AttrDict
            the contents of the item&#39;s record in MongoDB
        &#34;&#34;&#34;
        return self.Mongo.getRecord(table, *args, **kwargs)

    def actionButton(
        self, action, table, recordId=None, key=None, projectId=None, editionId=None
    ):
        &#34;&#34;&#34;Puts a button on the interface, if that makes sense.

        The button, when pressed, will lead to an action on certain content.
        It will be checked first if that action is allowed for the current user.
        If not the button will not be shown.

        !!! note &#34;Delete buttons&#34;
            Even if a user is authorised to delete a record,
            it is not allowed to delete master records if its detail records
            still exist.
            In that case, no delete button is displayed. Instead we display a count
            of detail records.

        Parameters
        ----------
        action: string, optional None
            The type of action that will be performed if the button triggered.
        table: string
            the table to which the action applies;
        recordId: ObjectId, optional None
            the record in question
        projectId: ObjectId, optional None
            The project in question, if any.
            Needed to determine whether a press on the button is permitted.
        editionId: ObjectId, optional None
            The edition in question, if any.
            Needed to determine whether a press on the button is permitted.
        key: string, optional None
            If present, it identifies a metadata field that is stored inside the
            record. From the key, the value can be found.
        &#34;&#34;&#34;
        Settings = self.Settings
        Auth = self.Auth

        urlInsert = &#34;/&#34;
        if projectId is not None:
            urlInsert += f&#34;projects/{projectId}/&#34;
        if editionId is not None:
            urlInsert += f&#34;editions/{editionId}/&#34;

        permitted = Auth.authorise(
            table, recordId=recordId, projectId=projectId, action=action
        )

        if not permitted:
            return &#34;&#34;

        Settings = self.Settings
        actions = Settings.auth.actions

        disable = False
        report = &#34;&#34;

        if action == &#34;delete&#34;:
            details = self.getDetailRecords(table, recordId)
            if len(details):
                disable = True
                detailContent = []
                for (detailTable, detailRecords) in details.items():
                    nDetails = len(detailRecords)
                    plural = &#34;&#34; if nDetails == 1 else &#34;s&#34;
                    detailRep = detailTable.rstrip(&#34;s&#34;) + plural
                    detailContent.append(f&#34;&#34;&#34;{nDetails}&amp;nbsp;{detailRep}&#34;&#34;&#34;)

                report = H.div(
                    [
                        H.span(thisContent, cls=&#34;dreport&#34;) + H.br()
                        for thisContent in detailContent
                    ]
                )
                report = H.br() + report

        actionInfo = AttrDict(actions.get(action, {}))
        text = actionInfo.acro
        name = actionInfo.name
        tableItem = table.rstrip(&#34;s&#34;)
        keyRepTip = &#34;&#34; if key is None else f&#34; {key} of&#34;
        keyRepUrl = &#34;&#34; if key is None else f&#34;/{key}&#34;
        recordIdRep = &#34;&#34; if recordId is None else f&#34;/{recordId}&#34;

        if disable:
            elem = &#34;span&#34;
            href = []
            cls = &#34;disabled&#34;
            can = &#34;Cannot &#34;
        else:
            elem = &#34;a&#34;
            href = [
                f&#34;{urlInsert}{table}/create&#34;
                if action == &#34;create&#34;
                else f&#34;/{table}{recordIdRep}{keyRepUrl}/{action}&#34;
            ]
            cls = &#34;&#34;
            can = &#34;&#34;

        fullCls = f&#34;button large {cls}&#34;
        tip = (
            f&#34;{name} new {tableItem}&#34;
            if action == &#34;create&#34;
            else f&#34;{can}{name}{keyRepTip} this {tableItem}&#34;
        )

        return H.elem(elem, text, *href, title=tip, cls=fullCls) + report

    def save(self, table, recordId, field, path, fileName):
        Settings = self.Settings
        Messages = self.Messages
        Mongo = self.Mongo
        Auth = self.Auth
        workingDir = Settings.workingDir

        permitted = Auth.authorise(table, recordId=recordId, action=&#34;update&#34;)
        previousFileName = Mongo.getRecord(table, _id=recordId)[field]

        sep = &#34;/&#34; if path else &#34;&#34;
        filePath = f&#34;{path}{sep}{fileName}&#34;
        fileFullPath = f&#34;{workingDir}/{filePath}&#34;

        if not permitted:
            logmsg = f&#34;Upload not permitted: {table}-{field}: {fileFullPath}&#34;
            Messages.warning(
                logmsg=logmsg,
                msg=f&#34;Upload not permitted: {filePath}&#34;,
            )
            return jsonify(status=False, msg=logmsg)

        try:
            with open(fileFullPath, &#34;wb&#34;) as fh:
                fh.write(data())
        except Exception:
            logmsg = &#34;Could not save uploaded file: {table}-{field}: {fileFullPath}&#34;
            Messages.warning(
                logmsg=logmsg,
                msg=f&#34;Uploaded file not saved: {filePath}&#34;,
            )
            return jsonify(status=False, msg=logmsg)

        if not Mongo.updateRecord(
            table, dict(field=fileName), warn=False, _id=recordId
        ):
            logmsg = (
                &#34;Could not store uploaded file name in MongoDB: &#34;
                f&#34;{table}-{field}: {filePath}&#34;
            )
            Messages.warning(
                logmsg=logmsg,
                msg=f&#34;Uploaded file name not stored: {fileName}&#34;,
            )
            return jsonify(status=False, msg=logmsg)

        previousFilePath = f&#34;{path}{sep}{previousFileName}&#34;
        previousFileFullPath = f&#34;{workingDir}/{previousFilePath}&#34;

        if previousFileFullPath != fileFullPath:
            fileRemove(previousFileFullPath)

        fid = f&#34;{table}/{recordId}/{field}&#34;
        staticUrl = f&#34;/data/{filePath}&#34;

        return jsonify(status=True, fid=fid, staticUrl=staticUrl)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="control.content.Content"><code class="flex name class">
<span>class <span class="ident">Content</span></span>
<span>(</span><span>Settings, Viewers, Messages, Mongo)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieving content from database and file system.</p>
<p>This class has methods to retrieve various pieces of content
from the data sources, and hand it over to the <code><a title="control.pages.Pages" href="pages.html#control.pages.Pages">Pages</a></code>
class that will compose a response out of it.</p>
<p>It is instantiated by a singleton object.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>Settings</code></strong> :&ensp;<code><a title="control.generic.AttrDict" href="generic.html#control.generic.AttrDict">AttrDict</a></code></dt>
<dd>App-wide configuration data obtained from
<code><a title="control.config.Config.Settings" href="config.html#control.config.Config.Settings">Config.Settings</a></code>.</dd>
<dt><strong><code>Viewers</code></strong> :&ensp;<code>object</code></dt>
<dd>Singleton instance of <code><a title="control.viewers.Viewers" href="viewers.html#control.viewers.Viewers">Viewers</a></code>.</dd>
<dt><strong><code>Messages</code></strong> :&ensp;<code>object</code></dt>
<dd>Singleton instance of <code><a title="control.messages.Messages" href="messages.html#control.messages.Messages">Messages</a></code>.</dd>
<dt><strong><code>Mongo</code></strong> :&ensp;<code>object</code></dt>
<dd>Singleton instance of <code><a title="control.mongo.Mongo" href="mongo.html#control.mongo.Mongo">Mongo</a></code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/43bd2e150961ad81f2af6575b1c8f269a7e20738/src/pure3d/control/content.py#L9-L751" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Content(Datamodel):
    def __init__(self, Settings, Viewers, Messages, Mongo):
        &#34;&#34;&#34;Retrieving content from database and file system.

        This class has methods to retrieve various pieces of content
        from the data sources, and hand it over to the `control.pages.Pages`
        class that will compose a response out of it.

        It is instantiated by a singleton object.

        Parameters
        ----------
        Settings: `control.generic.AttrDict`
            App-wide configuration data obtained from
            `control.config.Config.Settings`.
        Viewers: object
            Singleton instance of `control.viewers.Viewers`.
        Messages: object
            Singleton instance of `control.messages.Messages`.
        Mongo: object
            Singleton instance of `control.mongo.Mongo`.
        &#34;&#34;&#34;
        super().__init__(Settings, Messages, Mongo)
        self.Viewers = Viewers

    def addAuth(self, Auth):
        &#34;&#34;&#34;Give this object a handle to the Auth object.

        Because of cyclic dependencies some objects require to be given
        a handle to Auth after their initialization.
        &#34;&#34;&#34;
        self.Auth = Auth

    def getSurprise(self):
        &#34;&#34;&#34;Get the data that belongs to the surprise-me functionality.&#34;&#34;&#34;
        return H.h(2, &#34;You will be surprised!&#34;)

    def getProjects(self):
        &#34;&#34;&#34;Get the list of all projects.

        Well, the list of all projects visible to the current user.
        Unpublished projects are only visible to users that belong to that project.

        Visible projects are each displayed by means of an icon and a title.
        Both link to a landing page for the project.

        Returns
        -------
        string
            A list of captions of the projects,
            wrapped in a HTML string.
        &#34;&#34;&#34;
        Mongo = self.Mongo
        Auth = self.Auth

        wrapped = []
        wrapped.append(self.actionButton(&#34;create&#34;, &#34;projects&#34;))

        for record in Mongo.getList(&#34;projects&#34;):
            projectId = record._id
            permitted = Auth.authorise(&#34;projects&#34;, recordId=projectId, action=&#34;read&#34;)
            if not permitted:
                continue

            title = record.title

            projectUrl = f&#34;/projects/{projectId}&#34;
            button = self.actionButton(
                &#34;delete&#34;,
                &#34;projects&#34;,
                recordId=projectId,
            )
            self.debug(f&#34;deletebutton: {button}&#34;)
            visual = self.getUpload(&#34;iconProject&#34;, projectId=projectId)
            caption = self.getCaption(visual, title, button, projectUrl)

            wrapped.append(caption)

        return H.content(*wrapped)

    def insertProject(self):
        Mongo = self.Mongo
        Auth = self.Auth

        permitted = Auth.authorise(&#34;projects&#34;)
        if not permitted:
            return None

        User = Auth.myDetails()
        user = User.sub
        name = User.nickname

        title = &#34;Project without title&#34;

        dcMeta = dict(
            title=title,
            description=dict(abstract=&#34;No intro&#34;, description=&#34;No description&#34;),
            creator=name,
        )
        projectId = Mongo.insertRecord(&#34;projects&#34;, title=title, meta=dict(dc=dcMeta))
        Mongo.insertRecord(
            &#34;projectUsers&#34;,
            projectId=projectId,
            user=user,
            role=&#34;creator&#34;,
        )
        return projectId

    def getEditions(self, projectId):
        &#34;&#34;&#34;Get the list of the editions of a project.

        Well, only if the project is visible to the current user.
        See `Content.getProjects()`.

        Editions are each displayed by means of an icon and a title.
        Both link to a landing page for the edition.

        Parameters
        ----------
        projectId: ObjectId
            The project in question.

        Returns
        -------
        string
            A list of captions of the editions of the project,
            wrapped in a HTML string.
        &#34;&#34;&#34;
        Mongo = self.Mongo
        Auth = self.Auth

        wrapped = []

        for record in Mongo.getList(&#34;editions&#34;, projectId=projectId):
            editionId = record._id
            permitted = Auth.authorise(&#34;editions&#34;, recordId=editionId, action=&#34;read&#34;)
            if not permitted:
                continue

            title = record.title

            editionUrl = f&#34;/editions/{editionId}&#34;
            button = self.actionButton(
                &#34;delete&#34;,
                &#34;editions&#34;,
                recordId=editionId,
            )
            visual = self.getUpload(
                &#34;iconEdition&#34;, projectId=projectId, editionId=editionId
            )
            caption = self.getCaption(visual, title, button, editionUrl)
            wrapped.append(caption)

        wrapped.append(self.actionButton(&#34;create&#34;, &#34;editions&#34;, projectId=projectId))
        return H.content(*wrapped)

    def insertEdition(self, projectId):
        Mongo = self.Mongo
        Auth = self.Auth

        permitted = Auth.authorise(&#34;editions&#34;, projectId=projectId)
        if not permitted:
            return None

        User = Auth.myDetails()
        name = User.nickname

        title = &#34;Edition without title&#34;

        dcMeta = dict(
            title=title,
            description=dict(
                abstract=&#34;No intro&#34;,
                description=&#34;No description&#34;,
                provenance=&#34;No sources&#34;,
            ),
            creator=name,
        )
        editionId = Mongo.insertRecord(
            &#34;editions&#34;, title=title, projectId=projectId, meta=dict(dc=dcMeta)
        )
        return editionId

    def getScenes(
        self,
        projectId,
        editionId,
        sceneId=None,
        viewer=None,
        version=None,
        action=None,
    ):
        &#34;&#34;&#34;Get the list of the scenes of an edition of a project.

        Well, only if the project is visible to the current user.
        See `Content.getProjects()`.

        Scenes are each displayed by means of an icon a title and a row of buttons.
        The title is the file name (without the `.json` extension) of the scene.
        Both link to a landing page for the edition.

        One of the scenes is made *active*, i.e.
        it is loaded in a specific version of a viewer in a specific
        mode (`view` or `edit`).

        Which scene is loaded in which viewer and version in which mode,
        is determined by the parameters.
        If the parameters do not specify values, sensible defaults are chosen.

        Parameters
        ----------
        projectId: ObjectId
            The project in question.
        editionId: ObjectId
            The edition in question.
        sceneId: ObjectId, optional None
            The active scene. If None the default scene is chosen.
            A scene record specifies whether that scene is the default scene for
            that edition.
        viewer: string, optional None
            The viewer to be used for the 3D viewing. It should be a supported viewer.
            If None, the default viewer is chosen.
            The list of those viewers is in the `yaml/viewers.yml` file,
            which also specifies what the default viewer is.
        version: string, optional None
            The version of the chosen viewer that will be used.
            If no version or a non-existing version are specified,
            the latest existing version for that viewer will be chosen.
        action: string, optional `view`
            The mode in which the viewer should be opened.
            If the mode is `edit`, the viewer is opened in edit mode.
            All other modes lead to the viewer being opened in read-only
            mode.

        Returns
        -------
        string
            A list of captions of the scenes of the edition,
            with one caption replaced by a 3D viewer showing the scene.
            The list is wrapped in a HTML string.
        &#34;&#34;&#34;
        Mongo = self.Mongo
        Auth = self.Auth
        Viewers = self.Viewers

        wrapped = []

        actions = Auth.authorise(&#34;editions&#34;, recordId=editionId)
        if &#34;read&#34; not in actions:
            return &#34;&#34;

        (viewer, version) = Viewers.check(viewer, version)

        wrapped = []

        for record in Mongo.getList(&#34;scenes&#34;, editionId=editionId):
            thisSceneId = record._id

            isSceneActive = sceneId is None and record.default or record._id == sceneId
            titleText = H.span(record.name, cls=&#34;entrytitle&#34;)
            button = self.actionButton(
                &#34;delete&#34;,
                &#34;scenes&#34;,
                recordId=thisSceneId,
            )

            if isSceneActive:
                (frame, buttons) = Viewers.getFrame(
                    thisSceneId, actions, viewer, version, action
                )
                title = H.span(titleText, cls=&#34;entrytitle&#34;)
                content = f&#34;&#34;&#34;{frame}{title}{buttons}&#34;&#34;&#34;
                caption = self.wrapCaption(content, button, active=True)
            else:
                sceneUrl = f&#34;/scenes/{record._id}&#34;
                visual = self.getUpload(
                    &#34;iconScene&#34;,
                    projectId=projectId,
                    editionId=editionId,
                    sceneId=thisSceneId,
                )
                caption = self.getCaption(visual, titleText, button, sceneUrl)

            wrapped.append(caption)

        wrapped.append(
            self.actionButton(
                &#34;create&#34;, &#34;scenes&#34;, projectId=projectId, editionId=editionId
            )
        )
        return H.content(*wrapped)

    def insertScene(self, projectId, editionId):
        Mongo = self.Mongo
        Auth = self.Auth

        permitted = Auth.authorise(&#34;scenes&#34;, projectId=projectId)
        if not permitted:
            return None

        User = Auth.myDetails()
        name = User.nickname

        title = &#34;Scene without title&#34;

        dcMeta = dict(
            title=title,
            creator=name,
        )
        sceneId = Mongo.insertRecord(
            &#34;scenes&#34;,
            name=title,
            projectId=projectId,
            editionId=editionId,
            meta=dict(dc=dcMeta),
        )
        return sceneId

    def wrapCaption(self, content, button, active=False):
        activeCls = &#34;active&#34; if active else &#34;&#34;
        return H.div(
            [H.div(content, cls=f&#34;caption {activeCls}&#34;), button], cls=&#34;captioncontent&#34;
        )

    def getCaption(self, visual, titleText, button, url):
        title = H.span(titleText, cls=&#34;entrytitle&#34;)

        # visual = H.img(f&#34;{iconUrlBase}/{icon}&#34;, imgAtts=dict(cls=&#34;previewicon&#34;))
        content = H.a(f&#34;{visual}{title}&#34;, url, cls=&#34;entry&#34;)
        return self.wrapCaption(content, button)

    def getValue(self, key, projectId=None, editionId=None, level=None, bare=False):
        &#34;&#34;&#34;Retrieve a metadata value.

        Metadata sits in a big, potentially deeply nested dictionary of keys
        and values.
        These locations are known to the system (based on `fields.yml`).
        This function retrieves the information from those known locations.

        If a value is in fact composed of multiple values, it will be
        handled accordingly.

        Parameters
        ----------
        key: an identifier for the meta data field.
        projectId: ObjectId, optional None
            The project whose metadata we need. If it is None, we are at the site level.
        editionId: ObjectId, optional None
            The edition whose metadata we need. If it is None, we need metadata of
            a project or outer metadata.
        bare: boolean, optional None
            Get the bare value, without HTML wrapping and without buttons.

        Returns
        -------
        string
            It is assumed that the metadata value that is addressed exists.
            If not, we return the empty string.
        &#34;&#34;&#34;
        Mongo = self.Mongo
        Auth = self.Auth

        if editionId is not None:
            table = &#34;editions&#34;
            crit = dict(_id=editionId)
        elif projectId is not None:
            table = &#34;projects&#34;
            crit = dict(_id=projectId)
        else:
            table = &#34;meta&#34;
            crit = dict(name=&#34;site&#34;)

        record = Mongo.getRecord(table, **crit) or AttrDict()
        recordId = record._id

        permissions = Auth.authorise(table, recordId=recordId, projectId=projectId)

        if &#34;read&#34; not in permissions:
            return None

        F = self.makeField(key)

        if bare:
            return F.bare(record)

        button = self.actionButton(
            &#34;update&#34;,
            table,
            recordId=recordId,
            key=key,
            projectId=projectId,
            editionId=editionId,
        )

        return F.formatted(table, record, level=level, button=button)

    def getUpload(self, key, projectId=None, editionId=None, sceneId=None):
        &#34;&#34;&#34;Display the name and/or upload controls of an uploaded file.

        The user may to upload model files and scene files to an edition,
        and various png files as icons for projects, edtions, and scenes.
        Here we produce the control to do so.

        Only if the user has `update` authorisation, an upload/delete widget will be returned.

        Parameters
        ----------
        key: an identifier for the upload field.
        projectId: ObjectId, optional None
            The project in question. If it is None, we are at the site level.
        editionId: ObjectId, optional None
            The edition in question. If it is None, we are at the project level
            or site level.
        sceneId: ObjectId, optional None
            The scene in question. If it is None, we are at the edition,
            project, or site level.

        Returns
        -------
        string
            The name of the file that is currently present, or the indication
            that no file is present.

            If the user has edit permission for the edition, we display
            widgets to upload a new file or to delete the existing file.
        &#34;&#34;&#34;
        Mongo = self.Mongo
        Auth = self.Auth

        if sceneId is not None:
            table = &#34;scenes&#34;
            crit = dict(_id=sceneId)
        elif editionId is not None:
            table = &#34;editions&#34;
            crit = dict(_id=editionId)
        elif projectId is not None:
            table = &#34;projects&#34;
            crit = dict(_id=projectId)
        else:
            table = &#34;meta&#34;
            crit = dict(name=&#34;site&#34;)

        record = Mongo.getRecord(table, **crit) or AttrDict()
        recordId = record._id

        permissions = Auth.authorise(table, recordId=recordId, projectId=projectId)

        if &#34;read&#34; not in permissions:
            return None

        F = self.makeUpload(key)

        return F.formatted(record, &#34;update&#34; in permissions)

    def getViewerFile(self, path):
        &#34;&#34;&#34;Gets a viewer-related file from the file system.

        This is about files that are part of the viewer software.

        The viewer software is located in a specific directory on the server.
        This is the viewer base.

        Parameters
        ----------
        path: string
            The path of the viewer file within viewer base.

        Returns
        -------
        string
            The full path to the viewer file, if it exists.
            Otherwise, we raise an error that will lead to a 404 response.
        &#34;&#34;&#34;
        Settings = self.Settings
        Messages = self.Messages

        viewerDir = Settings.viewerDir

        viewerPath = f&#34;{viewerDir}/{path}&#34;

        if not fileExists(viewerPath):
            logmsg = f&#34;Accessing {viewerPath}: &#34;
            logmsg += &#34;does not exist. &#34;
            Messages.error(
                msg=&#34;Accessing a file&#34;,
                logmsg=logmsg,
            )

        return viewerPath

    def getData(self, path, projectId=None, editionId=None):
        &#34;&#34;&#34;Gets a data file from the file system.

        All data files are located under a specific directory on the server.
        This is the data directory.
        Below that the files are organized by projects and editions.

        Parameters
        ----------
        path: string
            The path of the data file within project/edition directory
            within the data directory.
        projectId: ObjectId, optional None
            The id of the project in question.
        editionId: ObjectId, optional None
            The id of the edition in question.

        Returns
        -------
        string
            The full path of the data file, if it exists.
            Otherwise, we raise an error that will lead to a 404 response.
        &#34;&#34;&#34;
        Settings = self.Settings
        Messages = self.Messages
        Auth = self.Auth

        workingDir = Settings.workingDir

        urlBase = (
            &#34;&#34;
            if projectId is None
            else f&#34;projects/{projectId}&#34;
            if editionId is None
            else f&#34;projects/{projectId}/editions/{editionId}&#34;
        )
        sep = &#34;/&#34; if urlBase else &#34;&#34;
        base = f&#34;{workingDir}{sep}{urlBase}&#34;

        dataPath = base if path is None else f&#34;{base}/{path}&#34;

        if projectId is None:
            table = &#34;meta&#34;
            recordId = (
                True  # dummy value for authorise, which only tests whether it is falsy
            )
        elif editionId is None:
            table = &#34;projects&#34;
            recordId = projectId
        else:
            table = &#34;editions&#34;
            recordId = editionId
        permitted = Auth.authorise(table, recordId=recordId, action=&#34;read&#34;)

        fexists = fileExists(dataPath)
        if not permitted or not fexists:
            logmsg = f&#34;Accessing {dataPath}: &#34;
            if not permitted:
                logmsg += &#34;not allowed. &#34;
            if not fexists:
                logmsg += &#34;does not exist. &#34;
            Messages.error(
                msg=f&#34;Accessing file {path}&#34;,
                logmsg=logmsg,
            )

        return dataPath

    def getItem(self, table, *args, **kwargs):
        &#34;&#34;&#34;Get a all information about an item.

        The item can be a project, edition, or scene.
        The information about that item is a record in MongoDb.
        possibly additional files on the file system.

        Parameters
        ----------
        table: string
            The name of the table from which to fetch an item
        *args, **kwargs: any
            Additional arguments to select the item&#39;s record
            from MongoDB

        Returns
        -------
        AttrDict
            the contents of the item&#39;s record in MongoDB
        &#34;&#34;&#34;
        return self.Mongo.getRecord(table, *args, **kwargs)

    def actionButton(
        self, action, table, recordId=None, key=None, projectId=None, editionId=None
    ):
        &#34;&#34;&#34;Puts a button on the interface, if that makes sense.

        The button, when pressed, will lead to an action on certain content.
        It will be checked first if that action is allowed for the current user.
        If not the button will not be shown.

        !!! note &#34;Delete buttons&#34;
            Even if a user is authorised to delete a record,
            it is not allowed to delete master records if its detail records
            still exist.
            In that case, no delete button is displayed. Instead we display a count
            of detail records.

        Parameters
        ----------
        action: string, optional None
            The type of action that will be performed if the button triggered.
        table: string
            the table to which the action applies;
        recordId: ObjectId, optional None
            the record in question
        projectId: ObjectId, optional None
            The project in question, if any.
            Needed to determine whether a press on the button is permitted.
        editionId: ObjectId, optional None
            The edition in question, if any.
            Needed to determine whether a press on the button is permitted.
        key: string, optional None
            If present, it identifies a metadata field that is stored inside the
            record. From the key, the value can be found.
        &#34;&#34;&#34;
        Settings = self.Settings
        Auth = self.Auth

        urlInsert = &#34;/&#34;
        if projectId is not None:
            urlInsert += f&#34;projects/{projectId}/&#34;
        if editionId is not None:
            urlInsert += f&#34;editions/{editionId}/&#34;

        permitted = Auth.authorise(
            table, recordId=recordId, projectId=projectId, action=action
        )

        if not permitted:
            return &#34;&#34;

        Settings = self.Settings
        actions = Settings.auth.actions

        disable = False
        report = &#34;&#34;

        if action == &#34;delete&#34;:
            details = self.getDetailRecords(table, recordId)
            if len(details):
                disable = True
                detailContent = []
                for (detailTable, detailRecords) in details.items():
                    nDetails = len(detailRecords)
                    plural = &#34;&#34; if nDetails == 1 else &#34;s&#34;
                    detailRep = detailTable.rstrip(&#34;s&#34;) + plural
                    detailContent.append(f&#34;&#34;&#34;{nDetails}&amp;nbsp;{detailRep}&#34;&#34;&#34;)

                report = H.div(
                    [
                        H.span(thisContent, cls=&#34;dreport&#34;) + H.br()
                        for thisContent in detailContent
                    ]
                )
                report = H.br() + report

        actionInfo = AttrDict(actions.get(action, {}))
        text = actionInfo.acro
        name = actionInfo.name
        tableItem = table.rstrip(&#34;s&#34;)
        keyRepTip = &#34;&#34; if key is None else f&#34; {key} of&#34;
        keyRepUrl = &#34;&#34; if key is None else f&#34;/{key}&#34;
        recordIdRep = &#34;&#34; if recordId is None else f&#34;/{recordId}&#34;

        if disable:
            elem = &#34;span&#34;
            href = []
            cls = &#34;disabled&#34;
            can = &#34;Cannot &#34;
        else:
            elem = &#34;a&#34;
            href = [
                f&#34;{urlInsert}{table}/create&#34;
                if action == &#34;create&#34;
                else f&#34;/{table}{recordIdRep}{keyRepUrl}/{action}&#34;
            ]
            cls = &#34;&#34;
            can = &#34;&#34;

        fullCls = f&#34;button large {cls}&#34;
        tip = (
            f&#34;{name} new {tableItem}&#34;
            if action == &#34;create&#34;
            else f&#34;{can}{name}{keyRepTip} this {tableItem}&#34;
        )

        return H.elem(elem, text, *href, title=tip, cls=fullCls) + report

    def save(self, table, recordId, field, path, fileName):
        Settings = self.Settings
        Messages = self.Messages
        Mongo = self.Mongo
        Auth = self.Auth
        workingDir = Settings.workingDir

        permitted = Auth.authorise(table, recordId=recordId, action=&#34;update&#34;)
        previousFileName = Mongo.getRecord(table, _id=recordId)[field]

        sep = &#34;/&#34; if path else &#34;&#34;
        filePath = f&#34;{path}{sep}{fileName}&#34;
        fileFullPath = f&#34;{workingDir}/{filePath}&#34;

        if not permitted:
            logmsg = f&#34;Upload not permitted: {table}-{field}: {fileFullPath}&#34;
            Messages.warning(
                logmsg=logmsg,
                msg=f&#34;Upload not permitted: {filePath}&#34;,
            )
            return jsonify(status=False, msg=logmsg)

        try:
            with open(fileFullPath, &#34;wb&#34;) as fh:
                fh.write(data())
        except Exception:
            logmsg = &#34;Could not save uploaded file: {table}-{field}: {fileFullPath}&#34;
            Messages.warning(
                logmsg=logmsg,
                msg=f&#34;Uploaded file not saved: {filePath}&#34;,
            )
            return jsonify(status=False, msg=logmsg)

        if not Mongo.updateRecord(
            table, dict(field=fileName), warn=False, _id=recordId
        ):
            logmsg = (
                &#34;Could not store uploaded file name in MongoDB: &#34;
                f&#34;{table}-{field}: {filePath}&#34;
            )
            Messages.warning(
                logmsg=logmsg,
                msg=f&#34;Uploaded file name not stored: {fileName}&#34;,
            )
            return jsonify(status=False, msg=logmsg)

        previousFilePath = f&#34;{path}{sep}{previousFileName}&#34;
        previousFileFullPath = f&#34;{workingDir}/{previousFilePath}&#34;

        if previousFileFullPath != fileFullPath:
            fileRemove(previousFileFullPath)

        fid = f&#34;{table}/{recordId}/{field}&#34;
        staticUrl = f&#34;/data/{filePath}&#34;

        return jsonify(status=True, fid=fid, staticUrl=staticUrl)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="control.datamodel.Datamodel" href="datamodel.html#control.datamodel.Datamodel">Datamodel</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="control.content.Content.actionButton"><code class="name flex">
<span>def <span class="ident">actionButton</span></span>(<span>self, action, table, recordId=None, key=None, projectId=None, editionId=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Puts a button on the interface, if that makes sense.</p>
<p>The button, when pressed, will lead to an action on certain content.
It will be checked first if that action is allowed for the current user.
If not the button will not be shown.</p>
<div class="admonition note">
<p class="admonition-title">Delete buttons</p>
<p>Even if a user is authorised to delete a record,
it is not allowed to delete master records if its detail records
still exist.
In that case, no delete button is displayed. Instead we display a count
of detail records.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>action</code></strong> :&ensp;<code>string</code>, optional <code>None</code></dt>
<dd>The type of action that will be performed if the button triggered.</dd>
<dt><strong><code>table</code></strong> :&ensp;<code>string</code></dt>
<dd>the table to which the action applies;</dd>
<dt><strong><code>recordId</code></strong> :&ensp;<code>ObjectId</code>, optional <code>None</code></dt>
<dd>the record in question</dd>
<dt><strong><code>projectId</code></strong> :&ensp;<code>ObjectId</code>, optional <code>None</code></dt>
<dd>The project in question, if any.
Needed to determine whether a press on the button is permitted.</dd>
<dt><strong><code>editionId</code></strong> :&ensp;<code>ObjectId</code>, optional <code>None</code></dt>
<dd>The edition in question, if any.
Needed to determine whether a press on the button is permitted.</dd>
<dt><strong><code>key</code></strong> :&ensp;<code>string</code>, optional <code>None</code></dt>
<dd>If present, it identifies a metadata field that is stored inside the
record. From the key, the value can be found.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/43bd2e150961ad81f2af6575b1c8f269a7e20738/src/pure3d/control/content.py#L589-L694" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def actionButton(
    self, action, table, recordId=None, key=None, projectId=None, editionId=None
):
    &#34;&#34;&#34;Puts a button on the interface, if that makes sense.

    The button, when pressed, will lead to an action on certain content.
    It will be checked first if that action is allowed for the current user.
    If not the button will not be shown.

    !!! note &#34;Delete buttons&#34;
        Even if a user is authorised to delete a record,
        it is not allowed to delete master records if its detail records
        still exist.
        In that case, no delete button is displayed. Instead we display a count
        of detail records.

    Parameters
    ----------
    action: string, optional None
        The type of action that will be performed if the button triggered.
    table: string
        the table to which the action applies;
    recordId: ObjectId, optional None
        the record in question
    projectId: ObjectId, optional None
        The project in question, if any.
        Needed to determine whether a press on the button is permitted.
    editionId: ObjectId, optional None
        The edition in question, if any.
        Needed to determine whether a press on the button is permitted.
    key: string, optional None
        If present, it identifies a metadata field that is stored inside the
        record. From the key, the value can be found.
    &#34;&#34;&#34;
    Settings = self.Settings
    Auth = self.Auth

    urlInsert = &#34;/&#34;
    if projectId is not None:
        urlInsert += f&#34;projects/{projectId}/&#34;
    if editionId is not None:
        urlInsert += f&#34;editions/{editionId}/&#34;

    permitted = Auth.authorise(
        table, recordId=recordId, projectId=projectId, action=action
    )

    if not permitted:
        return &#34;&#34;

    Settings = self.Settings
    actions = Settings.auth.actions

    disable = False
    report = &#34;&#34;

    if action == &#34;delete&#34;:
        details = self.getDetailRecords(table, recordId)
        if len(details):
            disable = True
            detailContent = []
            for (detailTable, detailRecords) in details.items():
                nDetails = len(detailRecords)
                plural = &#34;&#34; if nDetails == 1 else &#34;s&#34;
                detailRep = detailTable.rstrip(&#34;s&#34;) + plural
                detailContent.append(f&#34;&#34;&#34;{nDetails}&amp;nbsp;{detailRep}&#34;&#34;&#34;)

            report = H.div(
                [
                    H.span(thisContent, cls=&#34;dreport&#34;) + H.br()
                    for thisContent in detailContent
                ]
            )
            report = H.br() + report

    actionInfo = AttrDict(actions.get(action, {}))
    text = actionInfo.acro
    name = actionInfo.name
    tableItem = table.rstrip(&#34;s&#34;)
    keyRepTip = &#34;&#34; if key is None else f&#34; {key} of&#34;
    keyRepUrl = &#34;&#34; if key is None else f&#34;/{key}&#34;
    recordIdRep = &#34;&#34; if recordId is None else f&#34;/{recordId}&#34;

    if disable:
        elem = &#34;span&#34;
        href = []
        cls = &#34;disabled&#34;
        can = &#34;Cannot &#34;
    else:
        elem = &#34;a&#34;
        href = [
            f&#34;{urlInsert}{table}/create&#34;
            if action == &#34;create&#34;
            else f&#34;/{table}{recordIdRep}{keyRepUrl}/{action}&#34;
        ]
        cls = &#34;&#34;
        can = &#34;&#34;

    fullCls = f&#34;button large {cls}&#34;
    tip = (
        f&#34;{name} new {tableItem}&#34;
        if action == &#34;create&#34;
        else f&#34;{can}{name}{keyRepTip} this {tableItem}&#34;
    )

    return H.elem(elem, text, *href, title=tip, cls=fullCls) + report</code></pre>
</details>
</dd>
<dt id="control.content.Content.addAuth"><code class="name flex">
<span>def <span class="ident">addAuth</span></span>(<span>self, Auth)</span>
</code></dt>
<dd>
<div class="desc"><p>Give this object a handle to the Auth object.</p>
<p>Because of cyclic dependencies some objects require to be given
a handle to Auth after their initialization.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/43bd2e150961ad81f2af6575b1c8f269a7e20738/src/pure3d/control/content.py#L34-L40" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def addAuth(self, Auth):
    &#34;&#34;&#34;Give this object a handle to the Auth object.

    Because of cyclic dependencies some objects require to be given
    a handle to Auth after their initialization.
    &#34;&#34;&#34;
    self.Auth = Auth</code></pre>
</details>
</dd>
<dt id="control.content.Content.getCaption"><code class="name flex">
<span>def <span class="ident">getCaption</span></span>(<span>self, visual, titleText, button, url)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/43bd2e150961ad81f2af6575b1c8f269a7e20738/src/pure3d/control/content.py#L333-L338" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getCaption(self, visual, titleText, button, url):
    title = H.span(titleText, cls=&#34;entrytitle&#34;)

    # visual = H.img(f&#34;{iconUrlBase}/{icon}&#34;, imgAtts=dict(cls=&#34;previewicon&#34;))
    content = H.a(f&#34;{visual}{title}&#34;, url, cls=&#34;entry&#34;)
    return self.wrapCaption(content, button)</code></pre>
</details>
</dd>
<dt id="control.content.Content.getData"><code class="name flex">
<span>def <span class="ident">getData</span></span>(<span>self, path, projectId=None, editionId=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets a data file from the file system.</p>
<p>All data files are located under a specific directory on the server.
This is the data directory.
Below that the files are organized by projects and editions.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>string</code></dt>
<dd>The path of the data file within project/edition directory
within the data directory.</dd>
<dt><strong><code>projectId</code></strong> :&ensp;<code>ObjectId</code>, optional <code>None</code></dt>
<dd>The id of the project in question.</dd>
<dt><strong><code>editionId</code></strong> :&ensp;<code>ObjectId</code>, optional <code>None</code></dt>
<dd>The id of the edition in question.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>string</code></dt>
<dd>The full path of the data file, if it exists.
Otherwise, we raise an error that will lead to a 404 response.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/43bd2e150961ad81f2af6575b1c8f269a7e20738/src/pure3d/control/content.py#L499-L565" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getData(self, path, projectId=None, editionId=None):
    &#34;&#34;&#34;Gets a data file from the file system.

    All data files are located under a specific directory on the server.
    This is the data directory.
    Below that the files are organized by projects and editions.

    Parameters
    ----------
    path: string
        The path of the data file within project/edition directory
        within the data directory.
    projectId: ObjectId, optional None
        The id of the project in question.
    editionId: ObjectId, optional None
        The id of the edition in question.

    Returns
    -------
    string
        The full path of the data file, if it exists.
        Otherwise, we raise an error that will lead to a 404 response.
    &#34;&#34;&#34;
    Settings = self.Settings
    Messages = self.Messages
    Auth = self.Auth

    workingDir = Settings.workingDir

    urlBase = (
        &#34;&#34;
        if projectId is None
        else f&#34;projects/{projectId}&#34;
        if editionId is None
        else f&#34;projects/{projectId}/editions/{editionId}&#34;
    )
    sep = &#34;/&#34; if urlBase else &#34;&#34;
    base = f&#34;{workingDir}{sep}{urlBase}&#34;

    dataPath = base if path is None else f&#34;{base}/{path}&#34;

    if projectId is None:
        table = &#34;meta&#34;
        recordId = (
            True  # dummy value for authorise, which only tests whether it is falsy
        )
    elif editionId is None:
        table = &#34;projects&#34;
        recordId = projectId
    else:
        table = &#34;editions&#34;
        recordId = editionId
    permitted = Auth.authorise(table, recordId=recordId, action=&#34;read&#34;)

    fexists = fileExists(dataPath)
    if not permitted or not fexists:
        logmsg = f&#34;Accessing {dataPath}: &#34;
        if not permitted:
            logmsg += &#34;not allowed. &#34;
        if not fexists:
            logmsg += &#34;does not exist. &#34;
        Messages.error(
            msg=f&#34;Accessing file {path}&#34;,
            logmsg=logmsg,
        )

    return dataPath</code></pre>
</details>
</dd>
<dt id="control.content.Content.getEditions"><code class="name flex">
<span>def <span class="ident">getEditions</span></span>(<span>self, projectId)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the list of the editions of a project.</p>
<p>Well, only if the project is visible to the current user.
See <code><a title="control.content.Content.getProjects" href="#control.content.Content.getProjects">Content.getProjects()</a></code>.</p>
<p>Editions are each displayed by means of an icon and a title.
Both link to a landing page for the edition.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>projectId</code></strong> :&ensp;<code>ObjectId</code></dt>
<dd>The project in question.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>string</code></dt>
<dd>A list of captions of the editions of the project,
wrapped in a HTML string.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/43bd2e150961ad81f2af6575b1c8f269a7e20738/src/pure3d/control/content.py#L117-L163" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getEditions(self, projectId):
    &#34;&#34;&#34;Get the list of the editions of a project.

    Well, only if the project is visible to the current user.
    See `Content.getProjects()`.

    Editions are each displayed by means of an icon and a title.
    Both link to a landing page for the edition.

    Parameters
    ----------
    projectId: ObjectId
        The project in question.

    Returns
    -------
    string
        A list of captions of the editions of the project,
        wrapped in a HTML string.
    &#34;&#34;&#34;
    Mongo = self.Mongo
    Auth = self.Auth

    wrapped = []

    for record in Mongo.getList(&#34;editions&#34;, projectId=projectId):
        editionId = record._id
        permitted = Auth.authorise(&#34;editions&#34;, recordId=editionId, action=&#34;read&#34;)
        if not permitted:
            continue

        title = record.title

        editionUrl = f&#34;/editions/{editionId}&#34;
        button = self.actionButton(
            &#34;delete&#34;,
            &#34;editions&#34;,
            recordId=editionId,
        )
        visual = self.getUpload(
            &#34;iconEdition&#34;, projectId=projectId, editionId=editionId
        )
        caption = self.getCaption(visual, title, button, editionUrl)
        wrapped.append(caption)

    wrapped.append(self.actionButton(&#34;create&#34;, &#34;editions&#34;, projectId=projectId))
    return H.content(*wrapped)</code></pre>
</details>
</dd>
<dt id="control.content.Content.getItem"><code class="name flex">
<span>def <span class="ident">getItem</span></span>(<span>self, table, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Get a all information about an item.</p>
<p>The item can be a project, edition, or scene.
The information about that item is a record in MongoDb.
possibly additional files on the file system.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>table</code></strong> :&ensp;<code>string</code></dt>
<dd>The name of the table from which to fetch an item</dd>
<dt><strong><code>*args</code></strong>, <strong><code>**kwargs</code></strong> :&ensp;<code>any</code></dt>
<dd>Additional arguments to select the item's record
from MongoDB</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>AttrDict</code></dt>
<dd>the contents of the item's record in MongoDB</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/43bd2e150961ad81f2af6575b1c8f269a7e20738/src/pure3d/control/content.py#L567-L587" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getItem(self, table, *args, **kwargs):
    &#34;&#34;&#34;Get a all information about an item.

    The item can be a project, edition, or scene.
    The information about that item is a record in MongoDb.
    possibly additional files on the file system.

    Parameters
    ----------
    table: string
        The name of the table from which to fetch an item
    *args, **kwargs: any
        Additional arguments to select the item&#39;s record
        from MongoDB

    Returns
    -------
    AttrDict
        the contents of the item&#39;s record in MongoDB
    &#34;&#34;&#34;
    return self.Mongo.getRecord(table, *args, **kwargs)</code></pre>
</details>
</dd>
<dt id="control.content.Content.getProjects"><code class="name flex">
<span>def <span class="ident">getProjects</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the list of all projects.</p>
<p>Well, the list of all projects visible to the current user.
Unpublished projects are only visible to users that belong to that project.</p>
<p>Visible projects are each displayed by means of an icon and a title.
Both link to a landing page for the project.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>string</code></dt>
<dd>A list of captions of the projects,
wrapped in a HTML string.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/43bd2e150961ad81f2af6575b1c8f269a7e20738/src/pure3d/control/content.py#L46-L87" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getProjects(self):
    &#34;&#34;&#34;Get the list of all projects.

    Well, the list of all projects visible to the current user.
    Unpublished projects are only visible to users that belong to that project.

    Visible projects are each displayed by means of an icon and a title.
    Both link to a landing page for the project.

    Returns
    -------
    string
        A list of captions of the projects,
        wrapped in a HTML string.
    &#34;&#34;&#34;
    Mongo = self.Mongo
    Auth = self.Auth

    wrapped = []
    wrapped.append(self.actionButton(&#34;create&#34;, &#34;projects&#34;))

    for record in Mongo.getList(&#34;projects&#34;):
        projectId = record._id
        permitted = Auth.authorise(&#34;projects&#34;, recordId=projectId, action=&#34;read&#34;)
        if not permitted:
            continue

        title = record.title

        projectUrl = f&#34;/projects/{projectId}&#34;
        button = self.actionButton(
            &#34;delete&#34;,
            &#34;projects&#34;,
            recordId=projectId,
        )
        self.debug(f&#34;deletebutton: {button}&#34;)
        visual = self.getUpload(&#34;iconProject&#34;, projectId=projectId)
        caption = self.getCaption(visual, title, button, projectUrl)

        wrapped.append(caption)

    return H.content(*wrapped)</code></pre>
</details>
</dd>
<dt id="control.content.Content.getScenes"><code class="name flex">
<span>def <span class="ident">getScenes</span></span>(<span>self, projectId, editionId, sceneId=None, viewer=None, version=None, action=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the list of the scenes of an edition of a project.</p>
<p>Well, only if the project is visible to the current user.
See <code><a title="control.content.Content.getProjects" href="#control.content.Content.getProjects">Content.getProjects()</a></code>.</p>
<p>Scenes are each displayed by means of an icon a title and a row of buttons.
The title is the file name (without the <code>.json</code> extension) of the scene.
Both link to a landing page for the edition.</p>
<p>One of the scenes is made <em>active</em>, i.e.
it is loaded in a specific version of a viewer in a specific
mode (<code>view</code> or <code>edit</code>).</p>
<p>Which scene is loaded in which viewer and version in which mode,
is determined by the parameters.
If the parameters do not specify values, sensible defaults are chosen.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>projectId</code></strong> :&ensp;<code>ObjectId</code></dt>
<dd>The project in question.</dd>
<dt><strong><code>editionId</code></strong> :&ensp;<code>ObjectId</code></dt>
<dd>The edition in question.</dd>
<dt><strong><code>sceneId</code></strong> :&ensp;<code>ObjectId</code>, optional <code>None</code></dt>
<dd>The active scene. If None the default scene is chosen.
A scene record specifies whether that scene is the default scene for
that edition.</dd>
<dt><strong><code>viewer</code></strong> :&ensp;<code>string</code>, optional <code>None</code></dt>
<dd>The viewer to be used for the 3D viewing. It should be a supported viewer.
If None, the default viewer is chosen.
The list of those viewers is in the <code>yaml/viewers.yml</code> file,
which also specifies what the default viewer is.</dd>
<dt><strong><code>version</code></strong> :&ensp;<code>string</code>, optional <code>None</code></dt>
<dd>The version of the chosen viewer that will be used.
If no version or a non-existing version are specified,
the latest existing version for that viewer will be chosen.</dd>
<dt><strong><code>action</code></strong> :&ensp;<code>string</code>, optional <code>view</code></dt>
<dd>The mode in which the viewer should be opened.
If the mode is <code>edit</code>, the viewer is opened in edit mode.
All other modes lead to the viewer being opened in read-only
mode.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>string</code></dt>
<dd>A list of captions of the scenes of the edition,
with one caption replaced by a 3D viewer showing the scene.
The list is wrapped in a HTML string.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/43bd2e150961ad81f2af6575b1c8f269a7e20738/src/pure3d/control/content.py#L192-L299" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getScenes(
    self,
    projectId,
    editionId,
    sceneId=None,
    viewer=None,
    version=None,
    action=None,
):
    &#34;&#34;&#34;Get the list of the scenes of an edition of a project.

    Well, only if the project is visible to the current user.
    See `Content.getProjects()`.

    Scenes are each displayed by means of an icon a title and a row of buttons.
    The title is the file name (without the `.json` extension) of the scene.
    Both link to a landing page for the edition.

    One of the scenes is made *active*, i.e.
    it is loaded in a specific version of a viewer in a specific
    mode (`view` or `edit`).

    Which scene is loaded in which viewer and version in which mode,
    is determined by the parameters.
    If the parameters do not specify values, sensible defaults are chosen.

    Parameters
    ----------
    projectId: ObjectId
        The project in question.
    editionId: ObjectId
        The edition in question.
    sceneId: ObjectId, optional None
        The active scene. If None the default scene is chosen.
        A scene record specifies whether that scene is the default scene for
        that edition.
    viewer: string, optional None
        The viewer to be used for the 3D viewing. It should be a supported viewer.
        If None, the default viewer is chosen.
        The list of those viewers is in the `yaml/viewers.yml` file,
        which also specifies what the default viewer is.
    version: string, optional None
        The version of the chosen viewer that will be used.
        If no version or a non-existing version are specified,
        the latest existing version for that viewer will be chosen.
    action: string, optional `view`
        The mode in which the viewer should be opened.
        If the mode is `edit`, the viewer is opened in edit mode.
        All other modes lead to the viewer being opened in read-only
        mode.

    Returns
    -------
    string
        A list of captions of the scenes of the edition,
        with one caption replaced by a 3D viewer showing the scene.
        The list is wrapped in a HTML string.
    &#34;&#34;&#34;
    Mongo = self.Mongo
    Auth = self.Auth
    Viewers = self.Viewers

    wrapped = []

    actions = Auth.authorise(&#34;editions&#34;, recordId=editionId)
    if &#34;read&#34; not in actions:
        return &#34;&#34;

    (viewer, version) = Viewers.check(viewer, version)

    wrapped = []

    for record in Mongo.getList(&#34;scenes&#34;, editionId=editionId):
        thisSceneId = record._id

        isSceneActive = sceneId is None and record.default or record._id == sceneId
        titleText = H.span(record.name, cls=&#34;entrytitle&#34;)
        button = self.actionButton(
            &#34;delete&#34;,
            &#34;scenes&#34;,
            recordId=thisSceneId,
        )

        if isSceneActive:
            (frame, buttons) = Viewers.getFrame(
                thisSceneId, actions, viewer, version, action
            )
            title = H.span(titleText, cls=&#34;entrytitle&#34;)
            content = f&#34;&#34;&#34;{frame}{title}{buttons}&#34;&#34;&#34;
            caption = self.wrapCaption(content, button, active=True)
        else:
            sceneUrl = f&#34;/scenes/{record._id}&#34;
            visual = self.getUpload(
                &#34;iconScene&#34;,
                projectId=projectId,
                editionId=editionId,
                sceneId=thisSceneId,
            )
            caption = self.getCaption(visual, titleText, button, sceneUrl)

        wrapped.append(caption)

    wrapped.append(
        self.actionButton(
            &#34;create&#34;, &#34;scenes&#34;, projectId=projectId, editionId=editionId
        )
    )
    return H.content(*wrapped)</code></pre>
</details>
</dd>
<dt id="control.content.Content.getSurprise"><code class="name flex">
<span>def <span class="ident">getSurprise</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the data that belongs to the surprise-me functionality.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/43bd2e150961ad81f2af6575b1c8f269a7e20738/src/pure3d/control/content.py#L42-L44" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getSurprise(self):
    &#34;&#34;&#34;Get the data that belongs to the surprise-me functionality.&#34;&#34;&#34;
    return H.h(2, &#34;You will be surprised!&#34;)</code></pre>
</details>
</dd>
<dt id="control.content.Content.getUpload"><code class="name flex">
<span>def <span class="ident">getUpload</span></span>(<span>self, key, projectId=None, editionId=None, sceneId=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Display the name and/or upload controls of an uploaded file.</p>
<p>The user may to upload model files and scene files to an edition,
and various png files as icons for projects, edtions, and scenes.
Here we produce the control to do so.</p>
<p>Only if the user has <code>update</code> authorisation, an upload/delete widget will be returned.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt>key: an identifier for the upload field.</dt>
<dt><strong><code>projectId</code></strong> :&ensp;<code>ObjectId</code>, optional <code>None</code></dt>
<dd>The project in question. If it is None, we are at the site level.</dd>
<dt><strong><code>editionId</code></strong> :&ensp;<code>ObjectId</code>, optional <code>None</code></dt>
<dd>The edition in question. If it is None, we are at the project level
or site level.</dd>
<dt><strong><code>sceneId</code></strong> :&ensp;<code>ObjectId</code>, optional <code>None</code></dt>
<dd>The scene in question. If it is None, we are at the edition,
project, or site level.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>string</code></dt>
<dd>
<p>The name of the file that is currently present, or the indication
that no file is present.</p>
<p>If the user has edit permission for the edition, we display
widgets to upload a new file or to delete the existing file.</p>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/43bd2e150961ad81f2af6575b1c8f269a7e20738/src/pure3d/control/content.py#L405-L461" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getUpload(self, key, projectId=None, editionId=None, sceneId=None):
    &#34;&#34;&#34;Display the name and/or upload controls of an uploaded file.

    The user may to upload model files and scene files to an edition,
    and various png files as icons for projects, edtions, and scenes.
    Here we produce the control to do so.

    Only if the user has `update` authorisation, an upload/delete widget will be returned.

    Parameters
    ----------
    key: an identifier for the upload field.
    projectId: ObjectId, optional None
        The project in question. If it is None, we are at the site level.
    editionId: ObjectId, optional None
        The edition in question. If it is None, we are at the project level
        or site level.
    sceneId: ObjectId, optional None
        The scene in question. If it is None, we are at the edition,
        project, or site level.

    Returns
    -------
    string
        The name of the file that is currently present, or the indication
        that no file is present.

        If the user has edit permission for the edition, we display
        widgets to upload a new file or to delete the existing file.
    &#34;&#34;&#34;
    Mongo = self.Mongo
    Auth = self.Auth

    if sceneId is not None:
        table = &#34;scenes&#34;
        crit = dict(_id=sceneId)
    elif editionId is not None:
        table = &#34;editions&#34;
        crit = dict(_id=editionId)
    elif projectId is not None:
        table = &#34;projects&#34;
        crit = dict(_id=projectId)
    else:
        table = &#34;meta&#34;
        crit = dict(name=&#34;site&#34;)

    record = Mongo.getRecord(table, **crit) or AttrDict()
    recordId = record._id

    permissions = Auth.authorise(table, recordId=recordId, projectId=projectId)

    if &#34;read&#34; not in permissions:
        return None

    F = self.makeUpload(key)

    return F.formatted(record, &#34;update&#34; in permissions)</code></pre>
</details>
</dd>
<dt id="control.content.Content.getValue"><code class="name flex">
<span>def <span class="ident">getValue</span></span>(<span>self, key, projectId=None, editionId=None, level=None, bare=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve a metadata value.</p>
<p>Metadata sits in a big, potentially deeply nested dictionary of keys
and values.
These locations are known to the system (based on <code>fields.yml</code>).
This function retrieves the information from those known locations.</p>
<p>If a value is in fact composed of multiple values, it will be
handled accordingly.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt>key: an identifier for the meta data field.</dt>
<dt><strong><code>projectId</code></strong> :&ensp;<code>ObjectId</code>, optional <code>None</code></dt>
<dd>The project whose metadata we need. If it is None, we are at the site level.</dd>
<dt><strong><code>editionId</code></strong> :&ensp;<code>ObjectId</code>, optional <code>None</code></dt>
<dd>The edition whose metadata we need. If it is None, we need metadata of
a project or outer metadata.</dd>
<dt><strong><code>bare</code></strong> :&ensp;<code>boolean</code>, optional <code>None</code></dt>
<dd>Get the bare value, without HTML wrapping and without buttons.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>string</code></dt>
<dd>It is assumed that the metadata value that is addressed exists.
If not, we return the empty string.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/43bd2e150961ad81f2af6575b1c8f269a7e20738/src/pure3d/control/content.py#L340-L403" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getValue(self, key, projectId=None, editionId=None, level=None, bare=False):
    &#34;&#34;&#34;Retrieve a metadata value.

    Metadata sits in a big, potentially deeply nested dictionary of keys
    and values.
    These locations are known to the system (based on `fields.yml`).
    This function retrieves the information from those known locations.

    If a value is in fact composed of multiple values, it will be
    handled accordingly.

    Parameters
    ----------
    key: an identifier for the meta data field.
    projectId: ObjectId, optional None
        The project whose metadata we need. If it is None, we are at the site level.
    editionId: ObjectId, optional None
        The edition whose metadata we need. If it is None, we need metadata of
        a project or outer metadata.
    bare: boolean, optional None
        Get the bare value, without HTML wrapping and without buttons.

    Returns
    -------
    string
        It is assumed that the metadata value that is addressed exists.
        If not, we return the empty string.
    &#34;&#34;&#34;
    Mongo = self.Mongo
    Auth = self.Auth

    if editionId is not None:
        table = &#34;editions&#34;
        crit = dict(_id=editionId)
    elif projectId is not None:
        table = &#34;projects&#34;
        crit = dict(_id=projectId)
    else:
        table = &#34;meta&#34;
        crit = dict(name=&#34;site&#34;)

    record = Mongo.getRecord(table, **crit) or AttrDict()
    recordId = record._id

    permissions = Auth.authorise(table, recordId=recordId, projectId=projectId)

    if &#34;read&#34; not in permissions:
        return None

    F = self.makeField(key)

    if bare:
        return F.bare(record)

    button = self.actionButton(
        &#34;update&#34;,
        table,
        recordId=recordId,
        key=key,
        projectId=projectId,
        editionId=editionId,
    )

    return F.formatted(table, record, level=level, button=button)</code></pre>
</details>
</dd>
<dt id="control.content.Content.getViewerFile"><code class="name flex">
<span>def <span class="ident">getViewerFile</span></span>(<span>self, path)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets a viewer-related file from the file system.</p>
<p>This is about files that are part of the viewer software.</p>
<p>The viewer software is located in a specific directory on the server.
This is the viewer base.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>string</code></dt>
<dd>The path of the viewer file within viewer base.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>string</code></dt>
<dd>The full path to the viewer file, if it exists.
Otherwise, we raise an error that will lead to a 404 response.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/43bd2e150961ad81f2af6575b1c8f269a7e20738/src/pure3d/control/content.py#L463-L497" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getViewerFile(self, path):
    &#34;&#34;&#34;Gets a viewer-related file from the file system.

    This is about files that are part of the viewer software.

    The viewer software is located in a specific directory on the server.
    This is the viewer base.

    Parameters
    ----------
    path: string
        The path of the viewer file within viewer base.

    Returns
    -------
    string
        The full path to the viewer file, if it exists.
        Otherwise, we raise an error that will lead to a 404 response.
    &#34;&#34;&#34;
    Settings = self.Settings
    Messages = self.Messages

    viewerDir = Settings.viewerDir

    viewerPath = f&#34;{viewerDir}/{path}&#34;

    if not fileExists(viewerPath):
        logmsg = f&#34;Accessing {viewerPath}: &#34;
        logmsg += &#34;does not exist. &#34;
        Messages.error(
            msg=&#34;Accessing a file&#34;,
            logmsg=logmsg,
        )

    return viewerPath</code></pre>
</details>
</dd>
<dt id="control.content.Content.insertEdition"><code class="name flex">
<span>def <span class="ident">insertEdition</span></span>(<span>self, projectId)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/43bd2e150961ad81f2af6575b1c8f269a7e20738/src/pure3d/control/content.py#L165-L190" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def insertEdition(self, projectId):
    Mongo = self.Mongo
    Auth = self.Auth

    permitted = Auth.authorise(&#34;editions&#34;, projectId=projectId)
    if not permitted:
        return None

    User = Auth.myDetails()
    name = User.nickname

    title = &#34;Edition without title&#34;

    dcMeta = dict(
        title=title,
        description=dict(
            abstract=&#34;No intro&#34;,
            description=&#34;No description&#34;,
            provenance=&#34;No sources&#34;,
        ),
        creator=name,
    )
    editionId = Mongo.insertRecord(
        &#34;editions&#34;, title=title, projectId=projectId, meta=dict(dc=dcMeta)
    )
    return editionId</code></pre>
</details>
</dd>
<dt id="control.content.Content.insertProject"><code class="name flex">
<span>def <span class="ident">insertProject</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/43bd2e150961ad81f2af6575b1c8f269a7e20738/src/pure3d/control/content.py#L89-L115" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def insertProject(self):
    Mongo = self.Mongo
    Auth = self.Auth

    permitted = Auth.authorise(&#34;projects&#34;)
    if not permitted:
        return None

    User = Auth.myDetails()
    user = User.sub
    name = User.nickname

    title = &#34;Project without title&#34;

    dcMeta = dict(
        title=title,
        description=dict(abstract=&#34;No intro&#34;, description=&#34;No description&#34;),
        creator=name,
    )
    projectId = Mongo.insertRecord(&#34;projects&#34;, title=title, meta=dict(dc=dcMeta))
    Mongo.insertRecord(
        &#34;projectUsers&#34;,
        projectId=projectId,
        user=user,
        role=&#34;creator&#34;,
    )
    return projectId</code></pre>
</details>
</dd>
<dt id="control.content.Content.insertScene"><code class="name flex">
<span>def <span class="ident">insertScene</span></span>(<span>self, projectId, editionId)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/43bd2e150961ad81f2af6575b1c8f269a7e20738/src/pure3d/control/content.py#L301-L325" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def insertScene(self, projectId, editionId):
    Mongo = self.Mongo
    Auth = self.Auth

    permitted = Auth.authorise(&#34;scenes&#34;, projectId=projectId)
    if not permitted:
        return None

    User = Auth.myDetails()
    name = User.nickname

    title = &#34;Scene without title&#34;

    dcMeta = dict(
        title=title,
        creator=name,
    )
    sceneId = Mongo.insertRecord(
        &#34;scenes&#34;,
        name=title,
        projectId=projectId,
        editionId=editionId,
        meta=dict(dc=dcMeta),
    )
    return sceneId</code></pre>
</details>
</dd>
<dt id="control.content.Content.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self, table, recordId, field, path, fileName)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/43bd2e150961ad81f2af6575b1c8f269a7e20738/src/pure3d/control/content.py#L696-L751" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def save(self, table, recordId, field, path, fileName):
    Settings = self.Settings
    Messages = self.Messages
    Mongo = self.Mongo
    Auth = self.Auth
    workingDir = Settings.workingDir

    permitted = Auth.authorise(table, recordId=recordId, action=&#34;update&#34;)
    previousFileName = Mongo.getRecord(table, _id=recordId)[field]

    sep = &#34;/&#34; if path else &#34;&#34;
    filePath = f&#34;{path}{sep}{fileName}&#34;
    fileFullPath = f&#34;{workingDir}/{filePath}&#34;

    if not permitted:
        logmsg = f&#34;Upload not permitted: {table}-{field}: {fileFullPath}&#34;
        Messages.warning(
            logmsg=logmsg,
            msg=f&#34;Upload not permitted: {filePath}&#34;,
        )
        return jsonify(status=False, msg=logmsg)

    try:
        with open(fileFullPath, &#34;wb&#34;) as fh:
            fh.write(data())
    except Exception:
        logmsg = &#34;Could not save uploaded file: {table}-{field}: {fileFullPath}&#34;
        Messages.warning(
            logmsg=logmsg,
            msg=f&#34;Uploaded file not saved: {filePath}&#34;,
        )
        return jsonify(status=False, msg=logmsg)

    if not Mongo.updateRecord(
        table, dict(field=fileName), warn=False, _id=recordId
    ):
        logmsg = (
            &#34;Could not store uploaded file name in MongoDB: &#34;
            f&#34;{table}-{field}: {filePath}&#34;
        )
        Messages.warning(
            logmsg=logmsg,
            msg=f&#34;Uploaded file name not stored: {fileName}&#34;,
        )
        return jsonify(status=False, msg=logmsg)

    previousFilePath = f&#34;{path}{sep}{previousFileName}&#34;
    previousFileFullPath = f&#34;{workingDir}/{previousFilePath}&#34;

    if previousFileFullPath != fileFullPath:
        fileRemove(previousFileFullPath)

    fid = f&#34;{table}/{recordId}/{field}&#34;
    staticUrl = f&#34;/data/{filePath}&#34;

    return jsonify(status=True, fid=fid, staticUrl=staticUrl)</code></pre>
</details>
</dd>
<dt id="control.content.Content.wrapCaption"><code class="name flex">
<span>def <span class="ident">wrapCaption</span></span>(<span>self, content, button, active=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/43bd2e150961ad81f2af6575b1c8f269a7e20738/src/pure3d/control/content.py#L327-L331" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def wrapCaption(self, content, button, active=False):
    activeCls = &#34;active&#34; if active else &#34;&#34;
    return H.div(
        [H.div(content, cls=f&#34;caption {activeCls}&#34;), button], cls=&#34;captioncontent&#34;
    )</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="control.datamodel.Datamodel" href="datamodel.html#control.datamodel.Datamodel">Datamodel</a></b></code>:
<ul class="hlist">
<li><code><a title="control.datamodel.Datamodel.getDetailRecords" href="datamodel.html#control.datamodel.Datamodel.getDetailRecords">getDetailRecords</a></code></li>
<li><code><a title="control.datamodel.Datamodel.makeField" href="datamodel.html#control.datamodel.Datamodel.makeField">makeField</a></code></li>
<li><code><a title="control.datamodel.Datamodel.makeUpload" href="datamodel.html#control.datamodel.Datamodel.makeUpload">makeUpload</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<p><a href="https://github.com/CLARIAH/pure3dx" title="GitHub repo">GitHub</a></p>
<form>
<input id="lunr-search" name="q" placeholder=" Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="control" href="index.html">control</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="control.content.Content" href="#control.content.Content">Content</a></code></h4>
<ul class="two-column">
<li><code><a title="control.content.Content.actionButton" href="#control.content.Content.actionButton">actionButton</a></code></li>
<li><code><a title="control.content.Content.addAuth" href="#control.content.Content.addAuth">addAuth</a></code></li>
<li><code><a title="control.content.Content.getCaption" href="#control.content.Content.getCaption">getCaption</a></code></li>
<li><code><a title="control.content.Content.getData" href="#control.content.Content.getData">getData</a></code></li>
<li><code><a title="control.content.Content.getEditions" href="#control.content.Content.getEditions">getEditions</a></code></li>
<li><code><a title="control.content.Content.getItem" href="#control.content.Content.getItem">getItem</a></code></li>
<li><code><a title="control.content.Content.getProjects" href="#control.content.Content.getProjects">getProjects</a></code></li>
<li><code><a title="control.content.Content.getScenes" href="#control.content.Content.getScenes">getScenes</a></code></li>
<li><code><a title="control.content.Content.getSurprise" href="#control.content.Content.getSurprise">getSurprise</a></code></li>
<li><code><a title="control.content.Content.getUpload" href="#control.content.Content.getUpload">getUpload</a></code></li>
<li><code><a title="control.content.Content.getValue" href="#control.content.Content.getValue">getValue</a></code></li>
<li><code><a title="control.content.Content.getViewerFile" href="#control.content.Content.getViewerFile">getViewerFile</a></code></li>
<li><code><a title="control.content.Content.insertEdition" href="#control.content.Content.insertEdition">insertEdition</a></code></li>
<li><code><a title="control.content.Content.insertProject" href="#control.content.Content.insertProject">insertProject</a></code></li>
<li><code><a title="control.content.Content.insertScene" href="#control.content.Content.insertScene">insertScene</a></code></li>
<li><code><a title="control.content.Content.save" href="#control.content.Content.save">save</a></code></li>
<li><code><a title="control.content.Content.wrapCaption" href="#control.content.Content.wrapCaption">wrapCaption</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<a href="https://pure.knaw.nl/portal/en/persons/dirk-roorda">Dirk Roorda</a>
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>