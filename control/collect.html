<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>control.collect API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>control.collect</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/43bd2e150961ad81f2af6575b1c8f269a7e20738/src/pure3d/control/collect.py#L1-L386" class="git-link">Browse git</a>
</summary>
<pre><code class="python">from control.files import (
    listDirs,
    listFiles,
    get3d,
    readYaml,
    dirMake,
    dirRemove,
    dirCopy,
    fileCopy,
)
from control.environment import var
from control.flask import initializing

ICON_FILE = &#34;icon.png&#34;
FAVICON_FILE = &#34;favicon.ico&#34;


class Collect:
    def __init__(self, Settings, Messages, Mongo):
        &#34;&#34;&#34;Provides initial data collection into MongoDb.

        Normally, this does not have to run, since the MongoDb is persistent.
        Only when the MongoDb of the Pure3D app is fresh,
        or when the MongoDb is out of sync with the data on the filesystem
        it must be initialized.

        It reads:

        * configuration data of the app,
        * project data on the file system
        * workflow data on the file system
        * 3D-viewer code on file system

        The project-, workflow, and viewer data should be placed on the same share
        in the file system, by a provision step that is done on the host.

        The data for the supported viewers is in repo `pure3d-data`, under `viewers`.

        For testing, there is `exampledata` in the same `pure3d-data` repo.
        The provision step should copy the contents of `exampledata` to the
        `data` directory of this repo (`pure3dx`).

        If data collection is triggered in test mode, the user table will be wiped,
        and the test users present in the example data will be imported.

        Otherwise the user table will be left unchanged.

        Parameters
        ----------
        Settings: `control.generic.AttrDict`
            App-wide configuration data obtained from
            `control.config.Config.Settings`.
        Messages: object
            Singleton instance of `control.messages.Messages`.
        Mongo: object
            Singleton instance of `control.mongo.Mongo`.
        &#34;&#34;&#34;
        self.Settings = Settings
        self.Messages = Messages
        Messages.debugAdd(self)
        self.Mongo = Mongo

        importSubdir = var(&#34;initdata&#34;) or &#34;exampledata&#34;
        dataDir = Settings.dataDir
        self.workingDir = Settings.workingDir
        self.importDir = f&#34;{dataDir}/{importSubdir}&#34;

    def trigger(self):
        &#34;&#34;&#34;Determines whether data collection should be done.

        We only do data collection if the environment variable `docollect` is `v`
        If so, the value of the environment variable `initdata`
        is the name of a subdirectory of the data directory.
        This subdirectory contains example data that will be imported into the system.

        We also prevent this from happening twice, which occurs when Flask runs
        in debug mode, since then the code is loaded twice.
        We guard against this by inspecting the environment variable
        `WERKZEUG_RUN_MAIN`. If it is set, we are already running the app,
        and data collection should be inhibited, because it has been done
        just before Flask started running.
        &#34;&#34;&#34;
        doCollect = var(&#34;docollect&#34;) == &#34;v&#34;

        return initializing() and doCollect

    def fetch(self):
        &#34;&#34;&#34;Performs a data collection.&#34;&#34;&#34;
        Messages = self.Messages
        Messages.info(logmsg=&#34;Collecting data before starting the app&#34;)

        self.clearDb()
        self.doOuter()
        self.doProjects()
        self.doWorkflow()

    def clearDb(self):
        &#34;&#34;&#34;Clears selected collections in the MongoDb.

        All collections that will be filled with data from the filesystem
        will be wiped.

        !!! &#34;Users collection will be wiped in test mode&#34;
            If in test mode, the `users` collection will be wiped,
            and then filled from the example data.
        &#34;&#34;&#34;
        Settings = self.Settings
        Mongo = self.Mongo

        for table in (
            &#34;meta&#34;,
            &#34;projects&#34;,
            &#34;editions&#34;,
            &#34;scenes&#34;,
            &#34;users&#34;,
            &#34;projectUsers&#34;,
        ):
            Mongo.checkCollection(table, reset=True)

        if Settings.testMode:
            Mongo.checkCollection(&#34;users&#34;, reset=True)

    def doOuter(self):
        &#34;&#34;&#34;Collects data not belonging to specific projects.&#34;&#34;&#34;
        Messages = self.Messages
        Mongo = self.Mongo

        importDir = self.importDir
        workingDir = self.workingDir

        Messages.plain(logmsg=f&#34;Import metadata from {importDir} to {workingDir}&#34;)

        dirMake(workingDir)

        metaDir = f&#34;{importDir}/meta&#34;
        metaFiles = listFiles(metaDir, &#34;.yml&#34;)
        meta = {}

        for metaFile in metaFiles:
            meta[metaFile] = readYaml(f&#34;{metaDir}/{metaFile}.yml&#34;, defaultEmpty=True)

        Mongo.insertRecord(&#34;meta&#34;, name=&#34;site&#34;, icon=ICON_FILE, **meta)

        fileCopy(f&#34;{importDir}/{ICON_FILE}&#34;, f&#34;{workingDir}/{ICON_FILE}&#34;)
        fileCopy(f&#34;{importDir}/{FAVICON_FILE}&#34;, f&#34;{workingDir}/{FAVICON_FILE}&#34;)

    def doProjects(self):
        &#34;&#34;&#34;Collects data belonging to projects.&#34;&#34;&#34;
        importDir = self.importDir
        workingDir = self.workingDir

        projectsInPath = f&#34;{importDir}/projects&#34;
        projectsOutPath = f&#34;{workingDir}/projects&#34;
        dirRemove(projectsOutPath)

        self.projectIdByName = {}

        projectNames = listDirs(projectsInPath)

        for projectName in projectNames:
            self.doProject(projectsInPath, projectsOutPath, projectName)

    def doProject(self, projectsInPath, projectsOutPath, projectName):
        &#34;&#34;&#34;Collects data belonging to a specific project.

        Parameters
        ----------
        projectsInPath: string
            Path on the filesystem to the projects input directory
        projectsOutPath: string
            Path on the filesystem to the projects destination directory
        projectName: string
            Directory name of the project to collect.
        &#34;&#34;&#34;
        Messages = self.Messages
        Mongo = self.Mongo
        projectIdByName = self.projectIdByName

        projectInPath = f&#34;{projectsInPath}/{projectName}&#34;

        meta = {}
        metaDir = f&#34;{projectInPath}/meta&#34;
        metaFiles = listFiles(metaDir, &#34;.yml&#34;)

        for metaFile in metaFiles:
            meta[metaFile] = readYaml(f&#34;{metaDir}/{metaFile}.yml&#34;, defaultEmpty=True)

        title = meta.get(&#34;dc&#34;, {}).get(&#34;title&#34;, projectName)

        projectInfo = dict(title=title, icon=ICON_FILE, **meta)

        projectId = Mongo.insertRecord(&#34;projects&#34;, **projectInfo)
        projectIdByName[projectName] = projectId

        Messages.plain(logmsg=f&#34;PROJECT {projectName} =&gt; {projectId}&#34;)

        projectOutPath = f&#34;{projectsOutPath}/{projectId}&#34;
        dirMake(projectOutPath)
        fileCopy(f&#34;{projectInPath}/{ICON_FILE}&#34;, f&#34;{projectOutPath}/{ICON_FILE}&#34;)

        self.doEditions(projectInPath, projectOutPath, projectId)

    def doEditions(self, projectInPath, projectOutPath, projectId):
        &#34;&#34;&#34;Collects data belonging to the editions of a project.

        Parameters
        ----------
        projectInPath: string
            Path on the filesystem to the input directory of this project
        projectOutPath: string
            Path on the filesystem to the destination directory of this project
        projectId: ObjectId
            MongoId of the project to collect.
        &#34;&#34;&#34;
        editionsInPath = f&#34;{projectInPath}/editions&#34;
        editionsOutPath = f&#34;{projectOutPath}/editions&#34;

        editionNames = listDirs(editionsInPath)

        for editionName in editionNames:
            self.doEdition(projectId, editionsInPath, editionsOutPath, editionName)

    def doEdition(self, projectId, editionsInPath, editionsOutPath, editionName):
        &#34;&#34;&#34;Collects data belonging to a specific edition.

        Parameters
        ----------
        projectId: ObjectId
            MongoId of the project to which the edition belongs.
        editionsInPath: string
            Path on the filesystem to the editions input directory
            within this project.
        editionsOutPath: string
            Path on the filesystem to the editions working directory
            within this project.
        editionName: string
            Directory name of the edition to collect.
        &#34;&#34;&#34;
        Messages = self.Messages
        Mongo = self.Mongo

        editionInPath = f&#34;{editionsInPath}/{editionName}&#34;

        meta = {}
        metaDir = f&#34;{editionInPath}/meta&#34;
        metaFiles = listFiles(metaDir, &#34;.yml&#34;)

        for metaFile in metaFiles:
            meta[metaFile] = readYaml(f&#34;{metaDir}/{metaFile}.yml&#34;, defaultEmpty=True)

        title = meta.get(&#34;dc&#34;, {}).get(&#34;title&#34;, editionName)

        modelFile = None

        modelFiles = get3d(editionInPath, &#34;model&#34;)

        if len(modelFiles) == 0:
            Messages.plain(logmsg=&#34;\t\tNo model&#34;)
        else:
            extensions = modelFiles[&#34;model&#34;]
            if len(extensions) &gt; 1:
                Messages.plain(
                    logmsg=f&#34;\t\tMultiple extensions for model: {&#39;, &#39;.join(extensions)}&#34;
                )
            else:
                modelExt = extensions[0]
                modelFile = f&#34;model.{modelExt.lower()}&#34;

        editionInfo = dict(
            title=title, projectId=projectId, model=modelFile, icon=ICON_FILE, **meta
        )
        editionId = Mongo.insertRecord(&#34;editions&#34;, **editionInfo)

        Messages.plain(logmsg=f&#34;\tEDITION {editionName} =&gt; {editionId}&#34;)

        editionOutPath = f&#34;{editionsOutPath}/{editionId}&#34;
        dirMake(editionOutPath)
        fileCopy(f&#34;{editionInPath}/{ICON_FILE}&#34;, f&#34;{editionOutPath}/{ICON_FILE}&#34;)

        if modelFile is not None:
            modelFileIn = f&#34;{editionInPath}/model.{modelExt}&#34;
            modelFileOut = f&#34;{editionOutPath}/{modelFile}&#34;
            fileCopy(modelFileIn, modelFileOut)

        self.doScenes(editionInPath, editionOutPath, projectId, editionId)

    def doScenes(self, editionInPath, editionOutPath, projectId, editionId):
        &#34;&#34;&#34;Collects data belonging to the scenes of an edition.

        Parameters
        ----------
        editionInPath: string
            Path on the filesystem to the input directory of this edition
        editionOutPath: string
            Path on the filesystem to the destination directory of this edition
        projectId: ObjectId
            MongoId of the project to collect.
        editionId: ObjectId
            MongoId of the edition to collect.
        &#34;&#34;&#34;
        Messages = self.Messages
        Mongo = self.Mongo

        scenes = listFiles(editionInPath, &#34;.json&#34;)

        sceneDefault = None

        for scene in scenes:
            Messages.plain(logmsg=f&#34;\t\tSCENE {scene}&#34;)

            default = sceneDefault is None and scene == &#34;intro&#34;
            if default:
                sceneDefault = scene

            sceneFile = f&#34;{scene}.json&#34;
            sceneIcon = f&#34;{scene}.png&#34;

            sceneInfo = dict(
                name=scene,
                scene=sceneFile,
                icon=sceneIcon,
                editionId=editionId,
                projectId=projectId,
                default=default,
            )
            Mongo.insertRecord(&#34;scenes&#34;, **sceneInfo)
            sceneInPath = f&#34;{editionInPath}/{sceneFile}&#34;
            sceneOutPath = f&#34;{editionOutPath}/{sceneFile}&#34;
            fileCopy(sceneInPath, sceneOutPath)
            iconInPath = f&#34;{editionInPath}/{sceneIcon}&#34;
            iconOutPath = f&#34;{editionOutPath}/{sceneIcon}&#34;
            fileCopy(iconInPath, iconOutPath)

        articlesInPath = f&#34;{editionInPath}/articles&#34;
        articlesOutPath = f&#34;{editionOutPath}/articles&#34;
        Messages.plain(logmsg=&#34;\t\tARTICLES&#34;)
        dirCopy(articlesInPath, articlesOutPath)

    def doWorkflow(self):
        &#34;&#34;&#34;Collects workflow information from yaml files.

        !!! note &#34;Test users&#34;
            This includes test users when in test mode.
        &#34;&#34;&#34;
        Messages = self.Messages
        Mongo = self.Mongo
        importDir = self.importDir

        projectIdByName = self.projectIdByName

        workflowDir = f&#34;{importDir}/workflow&#34;
        workflowPath = f&#34;{workflowDir}/init.yml&#34;
        workflow = readYaml(workflowPath, defaultEmpty=True)
        users = workflow[&#34;users&#34;]
        projectUsers = workflow[&#34;projectUsers&#34;]
        projectStatus = workflow[&#34;projectStatus&#34;]

        userByName = {}

        for (userName, role) in users.items():
            sub = f&#34;{userName:0&gt;16}&#34;
            userInfo = dict(
                nickname=userName,
                sub=sub,
                role=role,
                isTest=True,
            )
            Mongo.insertRecord(&#34;users&#34;, **userInfo)
            userByName[userName] = sub

        for (projectName, isPublished) in projectStatus.items():
            Messages.plain(logmsg=f&#34;PROJECT {projectName} published: {isPublished}&#34;)
            Mongo.updateRecord(
                &#34;projects&#34;,
                dict(isPublished=isPublished),
                _id=projectIdByName[projectName],
            )

        for (projectName, projectUsrs) in projectUsers.items():
            for (userName, role) in projectUsrs.items():
                xInfo = dict(
                    user=userByName[userName],
                    projectId=projectIdByName[projectName],
                    role=role,
                )
                Mongo.insertRecord(&#34;projectUsers&#34;, **xInfo)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="control.collect.Collect"><code class="flex name class">
<span>class <span class="ident">Collect</span></span>
<span>(</span><span>Settings, Messages, Mongo)</span>
</code></dt>
<dd>
<div class="desc"><p>Provides initial data collection into MongoDb.</p>
<p>Normally, this does not have to run, since the MongoDb is persistent.
Only when the MongoDb of the Pure3D app is fresh,
or when the MongoDb is out of sync with the data on the filesystem
it must be initialized.</p>
<p>It reads:</p>
<ul>
<li>configuration data of the app,</li>
<li>project data on the file system</li>
<li>workflow data on the file system</li>
<li>3D-viewer code on file system</li>
</ul>
<p>The project-, workflow, and viewer data should be placed on the same share
in the file system, by a provision step that is done on the host.</p>
<p>The data for the supported viewers is in repo <code>pure3d-data</code>, under <code>viewers</code>.</p>
<p>For testing, there is <code>exampledata</code> in the same <code>pure3d-data</code> repo.
The provision step should copy the contents of <code>exampledata</code> to the
<code>data</code> directory of this repo (<code>pure3dx</code>).</p>
<p>If data collection is triggered in test mode, the user table will be wiped,
and the test users present in the example data will be imported.</p>
<p>Otherwise the user table will be left unchanged.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>Settings</code></strong> :&ensp;<code><a title="control.generic.AttrDict" href="generic.html#control.generic.AttrDict">AttrDict</a></code></dt>
<dd>App-wide configuration data obtained from
<code><a title="control.config.Config.Settings" href="config.html#control.config.Config.Settings">Config.Settings</a></code>.</dd>
<dt><strong><code>Messages</code></strong> :&ensp;<code>object</code></dt>
<dd>Singleton instance of <code><a title="control.messages.Messages" href="messages.html#control.messages.Messages">Messages</a></code>.</dd>
<dt><strong><code>Mongo</code></strong> :&ensp;<code>object</code></dt>
<dd>Singleton instance of <code><a title="control.mongo.Mongo" href="mongo.html#control.mongo.Mongo">Mongo</a></code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/43bd2e150961ad81f2af6575b1c8f269a7e20738/src/pure3d/control/collect.py#L18-L386" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Collect:
    def __init__(self, Settings, Messages, Mongo):
        &#34;&#34;&#34;Provides initial data collection into MongoDb.

        Normally, this does not have to run, since the MongoDb is persistent.
        Only when the MongoDb of the Pure3D app is fresh,
        or when the MongoDb is out of sync with the data on the filesystem
        it must be initialized.

        It reads:

        * configuration data of the app,
        * project data on the file system
        * workflow data on the file system
        * 3D-viewer code on file system

        The project-, workflow, and viewer data should be placed on the same share
        in the file system, by a provision step that is done on the host.

        The data for the supported viewers is in repo `pure3d-data`, under `viewers`.

        For testing, there is `exampledata` in the same `pure3d-data` repo.
        The provision step should copy the contents of `exampledata` to the
        `data` directory of this repo (`pure3dx`).

        If data collection is triggered in test mode, the user table will be wiped,
        and the test users present in the example data will be imported.

        Otherwise the user table will be left unchanged.

        Parameters
        ----------
        Settings: `control.generic.AttrDict`
            App-wide configuration data obtained from
            `control.config.Config.Settings`.
        Messages: object
            Singleton instance of `control.messages.Messages`.
        Mongo: object
            Singleton instance of `control.mongo.Mongo`.
        &#34;&#34;&#34;
        self.Settings = Settings
        self.Messages = Messages
        Messages.debugAdd(self)
        self.Mongo = Mongo

        importSubdir = var(&#34;initdata&#34;) or &#34;exampledata&#34;
        dataDir = Settings.dataDir
        self.workingDir = Settings.workingDir
        self.importDir = f&#34;{dataDir}/{importSubdir}&#34;

    def trigger(self):
        &#34;&#34;&#34;Determines whether data collection should be done.

        We only do data collection if the environment variable `docollect` is `v`
        If so, the value of the environment variable `initdata`
        is the name of a subdirectory of the data directory.
        This subdirectory contains example data that will be imported into the system.

        We also prevent this from happening twice, which occurs when Flask runs
        in debug mode, since then the code is loaded twice.
        We guard against this by inspecting the environment variable
        `WERKZEUG_RUN_MAIN`. If it is set, we are already running the app,
        and data collection should be inhibited, because it has been done
        just before Flask started running.
        &#34;&#34;&#34;
        doCollect = var(&#34;docollect&#34;) == &#34;v&#34;

        return initializing() and doCollect

    def fetch(self):
        &#34;&#34;&#34;Performs a data collection.&#34;&#34;&#34;
        Messages = self.Messages
        Messages.info(logmsg=&#34;Collecting data before starting the app&#34;)

        self.clearDb()
        self.doOuter()
        self.doProjects()
        self.doWorkflow()

    def clearDb(self):
        &#34;&#34;&#34;Clears selected collections in the MongoDb.

        All collections that will be filled with data from the filesystem
        will be wiped.

        !!! &#34;Users collection will be wiped in test mode&#34;
            If in test mode, the `users` collection will be wiped,
            and then filled from the example data.
        &#34;&#34;&#34;
        Settings = self.Settings
        Mongo = self.Mongo

        for table in (
            &#34;meta&#34;,
            &#34;projects&#34;,
            &#34;editions&#34;,
            &#34;scenes&#34;,
            &#34;users&#34;,
            &#34;projectUsers&#34;,
        ):
            Mongo.checkCollection(table, reset=True)

        if Settings.testMode:
            Mongo.checkCollection(&#34;users&#34;, reset=True)

    def doOuter(self):
        &#34;&#34;&#34;Collects data not belonging to specific projects.&#34;&#34;&#34;
        Messages = self.Messages
        Mongo = self.Mongo

        importDir = self.importDir
        workingDir = self.workingDir

        Messages.plain(logmsg=f&#34;Import metadata from {importDir} to {workingDir}&#34;)

        dirMake(workingDir)

        metaDir = f&#34;{importDir}/meta&#34;
        metaFiles = listFiles(metaDir, &#34;.yml&#34;)
        meta = {}

        for metaFile in metaFiles:
            meta[metaFile] = readYaml(f&#34;{metaDir}/{metaFile}.yml&#34;, defaultEmpty=True)

        Mongo.insertRecord(&#34;meta&#34;, name=&#34;site&#34;, icon=ICON_FILE, **meta)

        fileCopy(f&#34;{importDir}/{ICON_FILE}&#34;, f&#34;{workingDir}/{ICON_FILE}&#34;)
        fileCopy(f&#34;{importDir}/{FAVICON_FILE}&#34;, f&#34;{workingDir}/{FAVICON_FILE}&#34;)

    def doProjects(self):
        &#34;&#34;&#34;Collects data belonging to projects.&#34;&#34;&#34;
        importDir = self.importDir
        workingDir = self.workingDir

        projectsInPath = f&#34;{importDir}/projects&#34;
        projectsOutPath = f&#34;{workingDir}/projects&#34;
        dirRemove(projectsOutPath)

        self.projectIdByName = {}

        projectNames = listDirs(projectsInPath)

        for projectName in projectNames:
            self.doProject(projectsInPath, projectsOutPath, projectName)

    def doProject(self, projectsInPath, projectsOutPath, projectName):
        &#34;&#34;&#34;Collects data belonging to a specific project.

        Parameters
        ----------
        projectsInPath: string
            Path on the filesystem to the projects input directory
        projectsOutPath: string
            Path on the filesystem to the projects destination directory
        projectName: string
            Directory name of the project to collect.
        &#34;&#34;&#34;
        Messages = self.Messages
        Mongo = self.Mongo
        projectIdByName = self.projectIdByName

        projectInPath = f&#34;{projectsInPath}/{projectName}&#34;

        meta = {}
        metaDir = f&#34;{projectInPath}/meta&#34;
        metaFiles = listFiles(metaDir, &#34;.yml&#34;)

        for metaFile in metaFiles:
            meta[metaFile] = readYaml(f&#34;{metaDir}/{metaFile}.yml&#34;, defaultEmpty=True)

        title = meta.get(&#34;dc&#34;, {}).get(&#34;title&#34;, projectName)

        projectInfo = dict(title=title, icon=ICON_FILE, **meta)

        projectId = Mongo.insertRecord(&#34;projects&#34;, **projectInfo)
        projectIdByName[projectName] = projectId

        Messages.plain(logmsg=f&#34;PROJECT {projectName} =&gt; {projectId}&#34;)

        projectOutPath = f&#34;{projectsOutPath}/{projectId}&#34;
        dirMake(projectOutPath)
        fileCopy(f&#34;{projectInPath}/{ICON_FILE}&#34;, f&#34;{projectOutPath}/{ICON_FILE}&#34;)

        self.doEditions(projectInPath, projectOutPath, projectId)

    def doEditions(self, projectInPath, projectOutPath, projectId):
        &#34;&#34;&#34;Collects data belonging to the editions of a project.

        Parameters
        ----------
        projectInPath: string
            Path on the filesystem to the input directory of this project
        projectOutPath: string
            Path on the filesystem to the destination directory of this project
        projectId: ObjectId
            MongoId of the project to collect.
        &#34;&#34;&#34;
        editionsInPath = f&#34;{projectInPath}/editions&#34;
        editionsOutPath = f&#34;{projectOutPath}/editions&#34;

        editionNames = listDirs(editionsInPath)

        for editionName in editionNames:
            self.doEdition(projectId, editionsInPath, editionsOutPath, editionName)

    def doEdition(self, projectId, editionsInPath, editionsOutPath, editionName):
        &#34;&#34;&#34;Collects data belonging to a specific edition.

        Parameters
        ----------
        projectId: ObjectId
            MongoId of the project to which the edition belongs.
        editionsInPath: string
            Path on the filesystem to the editions input directory
            within this project.
        editionsOutPath: string
            Path on the filesystem to the editions working directory
            within this project.
        editionName: string
            Directory name of the edition to collect.
        &#34;&#34;&#34;
        Messages = self.Messages
        Mongo = self.Mongo

        editionInPath = f&#34;{editionsInPath}/{editionName}&#34;

        meta = {}
        metaDir = f&#34;{editionInPath}/meta&#34;
        metaFiles = listFiles(metaDir, &#34;.yml&#34;)

        for metaFile in metaFiles:
            meta[metaFile] = readYaml(f&#34;{metaDir}/{metaFile}.yml&#34;, defaultEmpty=True)

        title = meta.get(&#34;dc&#34;, {}).get(&#34;title&#34;, editionName)

        modelFile = None

        modelFiles = get3d(editionInPath, &#34;model&#34;)

        if len(modelFiles) == 0:
            Messages.plain(logmsg=&#34;\t\tNo model&#34;)
        else:
            extensions = modelFiles[&#34;model&#34;]
            if len(extensions) &gt; 1:
                Messages.plain(
                    logmsg=f&#34;\t\tMultiple extensions for model: {&#39;, &#39;.join(extensions)}&#34;
                )
            else:
                modelExt = extensions[0]
                modelFile = f&#34;model.{modelExt.lower()}&#34;

        editionInfo = dict(
            title=title, projectId=projectId, model=modelFile, icon=ICON_FILE, **meta
        )
        editionId = Mongo.insertRecord(&#34;editions&#34;, **editionInfo)

        Messages.plain(logmsg=f&#34;\tEDITION {editionName} =&gt; {editionId}&#34;)

        editionOutPath = f&#34;{editionsOutPath}/{editionId}&#34;
        dirMake(editionOutPath)
        fileCopy(f&#34;{editionInPath}/{ICON_FILE}&#34;, f&#34;{editionOutPath}/{ICON_FILE}&#34;)

        if modelFile is not None:
            modelFileIn = f&#34;{editionInPath}/model.{modelExt}&#34;
            modelFileOut = f&#34;{editionOutPath}/{modelFile}&#34;
            fileCopy(modelFileIn, modelFileOut)

        self.doScenes(editionInPath, editionOutPath, projectId, editionId)

    def doScenes(self, editionInPath, editionOutPath, projectId, editionId):
        &#34;&#34;&#34;Collects data belonging to the scenes of an edition.

        Parameters
        ----------
        editionInPath: string
            Path on the filesystem to the input directory of this edition
        editionOutPath: string
            Path on the filesystem to the destination directory of this edition
        projectId: ObjectId
            MongoId of the project to collect.
        editionId: ObjectId
            MongoId of the edition to collect.
        &#34;&#34;&#34;
        Messages = self.Messages
        Mongo = self.Mongo

        scenes = listFiles(editionInPath, &#34;.json&#34;)

        sceneDefault = None

        for scene in scenes:
            Messages.plain(logmsg=f&#34;\t\tSCENE {scene}&#34;)

            default = sceneDefault is None and scene == &#34;intro&#34;
            if default:
                sceneDefault = scene

            sceneFile = f&#34;{scene}.json&#34;
            sceneIcon = f&#34;{scene}.png&#34;

            sceneInfo = dict(
                name=scene,
                scene=sceneFile,
                icon=sceneIcon,
                editionId=editionId,
                projectId=projectId,
                default=default,
            )
            Mongo.insertRecord(&#34;scenes&#34;, **sceneInfo)
            sceneInPath = f&#34;{editionInPath}/{sceneFile}&#34;
            sceneOutPath = f&#34;{editionOutPath}/{sceneFile}&#34;
            fileCopy(sceneInPath, sceneOutPath)
            iconInPath = f&#34;{editionInPath}/{sceneIcon}&#34;
            iconOutPath = f&#34;{editionOutPath}/{sceneIcon}&#34;
            fileCopy(iconInPath, iconOutPath)

        articlesInPath = f&#34;{editionInPath}/articles&#34;
        articlesOutPath = f&#34;{editionOutPath}/articles&#34;
        Messages.plain(logmsg=&#34;\t\tARTICLES&#34;)
        dirCopy(articlesInPath, articlesOutPath)

    def doWorkflow(self):
        &#34;&#34;&#34;Collects workflow information from yaml files.

        !!! note &#34;Test users&#34;
            This includes test users when in test mode.
        &#34;&#34;&#34;
        Messages = self.Messages
        Mongo = self.Mongo
        importDir = self.importDir

        projectIdByName = self.projectIdByName

        workflowDir = f&#34;{importDir}/workflow&#34;
        workflowPath = f&#34;{workflowDir}/init.yml&#34;
        workflow = readYaml(workflowPath, defaultEmpty=True)
        users = workflow[&#34;users&#34;]
        projectUsers = workflow[&#34;projectUsers&#34;]
        projectStatus = workflow[&#34;projectStatus&#34;]

        userByName = {}

        for (userName, role) in users.items():
            sub = f&#34;{userName:0&gt;16}&#34;
            userInfo = dict(
                nickname=userName,
                sub=sub,
                role=role,
                isTest=True,
            )
            Mongo.insertRecord(&#34;users&#34;, **userInfo)
            userByName[userName] = sub

        for (projectName, isPublished) in projectStatus.items():
            Messages.plain(logmsg=f&#34;PROJECT {projectName} published: {isPublished}&#34;)
            Mongo.updateRecord(
                &#34;projects&#34;,
                dict(isPublished=isPublished),
                _id=projectIdByName[projectName],
            )

        for (projectName, projectUsrs) in projectUsers.items():
            for (userName, role) in projectUsrs.items():
                xInfo = dict(
                    user=userByName[userName],
                    projectId=projectIdByName[projectName],
                    role=role,
                )
                Mongo.insertRecord(&#34;projectUsers&#34;, **xInfo)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="control.collect.Collect.clearDb"><code class="name flex">
<span>def <span class="ident">clearDb</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Clears selected collections in the MongoDb.</p>
<p>All collections that will be filled with data from the filesystem
will be wiped.</p>
<p>!!! "Users collection will be wiped in test mode"
If in test mode, the <code>users</code> collection will be wiped,
and then filled from the example data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/43bd2e150961ad81f2af6575b1c8f269a7e20738/src/pure3d/control/collect.py#L97-L121" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def clearDb(self):
    &#34;&#34;&#34;Clears selected collections in the MongoDb.

    All collections that will be filled with data from the filesystem
    will be wiped.

    !!! &#34;Users collection will be wiped in test mode&#34;
        If in test mode, the `users` collection will be wiped,
        and then filled from the example data.
    &#34;&#34;&#34;
    Settings = self.Settings
    Mongo = self.Mongo

    for table in (
        &#34;meta&#34;,
        &#34;projects&#34;,
        &#34;editions&#34;,
        &#34;scenes&#34;,
        &#34;users&#34;,
        &#34;projectUsers&#34;,
    ):
        Mongo.checkCollection(table, reset=True)

    if Settings.testMode:
        Mongo.checkCollection(&#34;users&#34;, reset=True)</code></pre>
</details>
</dd>
<dt id="control.collect.Collect.doEdition"><code class="name flex">
<span>def <span class="ident">doEdition</span></span>(<span>self, projectId, editionsInPath, editionsOutPath, editionName)</span>
</code></dt>
<dd>
<div class="desc"><p>Collects data belonging to a specific edition.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>projectId</code></strong> :&ensp;<code>ObjectId</code></dt>
<dd>MongoId of the project to which the edition belongs.</dd>
<dt><strong><code>editionsInPath</code></strong> :&ensp;<code>string</code></dt>
<dd>Path on the filesystem to the editions input directory
within this project.</dd>
<dt><strong><code>editionsOutPath</code></strong> :&ensp;<code>string</code></dt>
<dd>Path on the filesystem to the editions working directory
within this project.</dd>
<dt><strong><code>editionName</code></strong> :&ensp;<code>string</code></dt>
<dd>Directory name of the edition to collect.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/43bd2e150961ad81f2af6575b1c8f269a7e20738/src/pure3d/control/collect.py#L223-L285" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def doEdition(self, projectId, editionsInPath, editionsOutPath, editionName):
    &#34;&#34;&#34;Collects data belonging to a specific edition.

    Parameters
    ----------
    projectId: ObjectId
        MongoId of the project to which the edition belongs.
    editionsInPath: string
        Path on the filesystem to the editions input directory
        within this project.
    editionsOutPath: string
        Path on the filesystem to the editions working directory
        within this project.
    editionName: string
        Directory name of the edition to collect.
    &#34;&#34;&#34;
    Messages = self.Messages
    Mongo = self.Mongo

    editionInPath = f&#34;{editionsInPath}/{editionName}&#34;

    meta = {}
    metaDir = f&#34;{editionInPath}/meta&#34;
    metaFiles = listFiles(metaDir, &#34;.yml&#34;)

    for metaFile in metaFiles:
        meta[metaFile] = readYaml(f&#34;{metaDir}/{metaFile}.yml&#34;, defaultEmpty=True)

    title = meta.get(&#34;dc&#34;, {}).get(&#34;title&#34;, editionName)

    modelFile = None

    modelFiles = get3d(editionInPath, &#34;model&#34;)

    if len(modelFiles) == 0:
        Messages.plain(logmsg=&#34;\t\tNo model&#34;)
    else:
        extensions = modelFiles[&#34;model&#34;]
        if len(extensions) &gt; 1:
            Messages.plain(
                logmsg=f&#34;\t\tMultiple extensions for model: {&#39;, &#39;.join(extensions)}&#34;
            )
        else:
            modelExt = extensions[0]
            modelFile = f&#34;model.{modelExt.lower()}&#34;

    editionInfo = dict(
        title=title, projectId=projectId, model=modelFile, icon=ICON_FILE, **meta
    )
    editionId = Mongo.insertRecord(&#34;editions&#34;, **editionInfo)

    Messages.plain(logmsg=f&#34;\tEDITION {editionName} =&gt; {editionId}&#34;)

    editionOutPath = f&#34;{editionsOutPath}/{editionId}&#34;
    dirMake(editionOutPath)
    fileCopy(f&#34;{editionInPath}/{ICON_FILE}&#34;, f&#34;{editionOutPath}/{ICON_FILE}&#34;)

    if modelFile is not None:
        modelFileIn = f&#34;{editionInPath}/model.{modelExt}&#34;
        modelFileOut = f&#34;{editionOutPath}/{modelFile}&#34;
        fileCopy(modelFileIn, modelFileOut)

    self.doScenes(editionInPath, editionOutPath, projectId, editionId)</code></pre>
</details>
</dd>
<dt id="control.collect.Collect.doEditions"><code class="name flex">
<span>def <span class="ident">doEditions</span></span>(<span>self, projectInPath, projectOutPath, projectId)</span>
</code></dt>
<dd>
<div class="desc"><p>Collects data belonging to the editions of a project.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>projectInPath</code></strong> :&ensp;<code>string</code></dt>
<dd>Path on the filesystem to the input directory of this project</dd>
<dt><strong><code>projectOutPath</code></strong> :&ensp;<code>string</code></dt>
<dd>Path on the filesystem to the destination directory of this project</dd>
<dt><strong><code>projectId</code></strong> :&ensp;<code>ObjectId</code></dt>
<dd>MongoId of the project to collect.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/43bd2e150961ad81f2af6575b1c8f269a7e20738/src/pure3d/control/collect.py#L203-L221" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def doEditions(self, projectInPath, projectOutPath, projectId):
    &#34;&#34;&#34;Collects data belonging to the editions of a project.

    Parameters
    ----------
    projectInPath: string
        Path on the filesystem to the input directory of this project
    projectOutPath: string
        Path on the filesystem to the destination directory of this project
    projectId: ObjectId
        MongoId of the project to collect.
    &#34;&#34;&#34;
    editionsInPath = f&#34;{projectInPath}/editions&#34;
    editionsOutPath = f&#34;{projectOutPath}/editions&#34;

    editionNames = listDirs(editionsInPath)

    for editionName in editionNames:
        self.doEdition(projectId, editionsInPath, editionsOutPath, editionName)</code></pre>
</details>
</dd>
<dt id="control.collect.Collect.doOuter"><code class="name flex">
<span>def <span class="ident">doOuter</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Collects data not belonging to specific projects.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/43bd2e150961ad81f2af6575b1c8f269a7e20738/src/pure3d/control/collect.py#L123-L145" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def doOuter(self):
    &#34;&#34;&#34;Collects data not belonging to specific projects.&#34;&#34;&#34;
    Messages = self.Messages
    Mongo = self.Mongo

    importDir = self.importDir
    workingDir = self.workingDir

    Messages.plain(logmsg=f&#34;Import metadata from {importDir} to {workingDir}&#34;)

    dirMake(workingDir)

    metaDir = f&#34;{importDir}/meta&#34;
    metaFiles = listFiles(metaDir, &#34;.yml&#34;)
    meta = {}

    for metaFile in metaFiles:
        meta[metaFile] = readYaml(f&#34;{metaDir}/{metaFile}.yml&#34;, defaultEmpty=True)

    Mongo.insertRecord(&#34;meta&#34;, name=&#34;site&#34;, icon=ICON_FILE, **meta)

    fileCopy(f&#34;{importDir}/{ICON_FILE}&#34;, f&#34;{workingDir}/{ICON_FILE}&#34;)
    fileCopy(f&#34;{importDir}/{FAVICON_FILE}&#34;, f&#34;{workingDir}/{FAVICON_FILE}&#34;)</code></pre>
</details>
</dd>
<dt id="control.collect.Collect.doProject"><code class="name flex">
<span>def <span class="ident">doProject</span></span>(<span>self, projectsInPath, projectsOutPath, projectName)</span>
</code></dt>
<dd>
<div class="desc"><p>Collects data belonging to a specific project.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>projectsInPath</code></strong> :&ensp;<code>string</code></dt>
<dd>Path on the filesystem to the projects input directory</dd>
<dt><strong><code>projectsOutPath</code></strong> :&ensp;<code>string</code></dt>
<dd>Path on the filesystem to the projects destination directory</dd>
<dt><strong><code>projectName</code></strong> :&ensp;<code>string</code></dt>
<dd>Directory name of the project to collect.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/43bd2e150961ad81f2af6575b1c8f269a7e20738/src/pure3d/control/collect.py#L163-L201" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def doProject(self, projectsInPath, projectsOutPath, projectName):
    &#34;&#34;&#34;Collects data belonging to a specific project.

    Parameters
    ----------
    projectsInPath: string
        Path on the filesystem to the projects input directory
    projectsOutPath: string
        Path on the filesystem to the projects destination directory
    projectName: string
        Directory name of the project to collect.
    &#34;&#34;&#34;
    Messages = self.Messages
    Mongo = self.Mongo
    projectIdByName = self.projectIdByName

    projectInPath = f&#34;{projectsInPath}/{projectName}&#34;

    meta = {}
    metaDir = f&#34;{projectInPath}/meta&#34;
    metaFiles = listFiles(metaDir, &#34;.yml&#34;)

    for metaFile in metaFiles:
        meta[metaFile] = readYaml(f&#34;{metaDir}/{metaFile}.yml&#34;, defaultEmpty=True)

    title = meta.get(&#34;dc&#34;, {}).get(&#34;title&#34;, projectName)

    projectInfo = dict(title=title, icon=ICON_FILE, **meta)

    projectId = Mongo.insertRecord(&#34;projects&#34;, **projectInfo)
    projectIdByName[projectName] = projectId

    Messages.plain(logmsg=f&#34;PROJECT {projectName} =&gt; {projectId}&#34;)

    projectOutPath = f&#34;{projectsOutPath}/{projectId}&#34;
    dirMake(projectOutPath)
    fileCopy(f&#34;{projectInPath}/{ICON_FILE}&#34;, f&#34;{projectOutPath}/{ICON_FILE}&#34;)

    self.doEditions(projectInPath, projectOutPath, projectId)</code></pre>
</details>
</dd>
<dt id="control.collect.Collect.doProjects"><code class="name flex">
<span>def <span class="ident">doProjects</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Collects data belonging to projects.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/43bd2e150961ad81f2af6575b1c8f269a7e20738/src/pure3d/control/collect.py#L147-L161" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def doProjects(self):
    &#34;&#34;&#34;Collects data belonging to projects.&#34;&#34;&#34;
    importDir = self.importDir
    workingDir = self.workingDir

    projectsInPath = f&#34;{importDir}/projects&#34;
    projectsOutPath = f&#34;{workingDir}/projects&#34;
    dirRemove(projectsOutPath)

    self.projectIdByName = {}

    projectNames = listDirs(projectsInPath)

    for projectName in projectNames:
        self.doProject(projectsInPath, projectsOutPath, projectName)</code></pre>
</details>
</dd>
<dt id="control.collect.Collect.doScenes"><code class="name flex">
<span>def <span class="ident">doScenes</span></span>(<span>self, editionInPath, editionOutPath, projectId, editionId)</span>
</code></dt>
<dd>
<div class="desc"><p>Collects data belonging to the scenes of an edition.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>editionInPath</code></strong> :&ensp;<code>string</code></dt>
<dd>Path on the filesystem to the input directory of this edition</dd>
<dt><strong><code>editionOutPath</code></strong> :&ensp;<code>string</code></dt>
<dd>Path on the filesystem to the destination directory of this edition</dd>
<dt><strong><code>projectId</code></strong> :&ensp;<code>ObjectId</code></dt>
<dd>MongoId of the project to collect.</dd>
<dt><strong><code>editionId</code></strong> :&ensp;<code>ObjectId</code></dt>
<dd>MongoId of the edition to collect.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/43bd2e150961ad81f2af6575b1c8f269a7e20738/src/pure3d/control/collect.py#L287-L337" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def doScenes(self, editionInPath, editionOutPath, projectId, editionId):
    &#34;&#34;&#34;Collects data belonging to the scenes of an edition.

    Parameters
    ----------
    editionInPath: string
        Path on the filesystem to the input directory of this edition
    editionOutPath: string
        Path on the filesystem to the destination directory of this edition
    projectId: ObjectId
        MongoId of the project to collect.
    editionId: ObjectId
        MongoId of the edition to collect.
    &#34;&#34;&#34;
    Messages = self.Messages
    Mongo = self.Mongo

    scenes = listFiles(editionInPath, &#34;.json&#34;)

    sceneDefault = None

    for scene in scenes:
        Messages.plain(logmsg=f&#34;\t\tSCENE {scene}&#34;)

        default = sceneDefault is None and scene == &#34;intro&#34;
        if default:
            sceneDefault = scene

        sceneFile = f&#34;{scene}.json&#34;
        sceneIcon = f&#34;{scene}.png&#34;

        sceneInfo = dict(
            name=scene,
            scene=sceneFile,
            icon=sceneIcon,
            editionId=editionId,
            projectId=projectId,
            default=default,
        )
        Mongo.insertRecord(&#34;scenes&#34;, **sceneInfo)
        sceneInPath = f&#34;{editionInPath}/{sceneFile}&#34;
        sceneOutPath = f&#34;{editionOutPath}/{sceneFile}&#34;
        fileCopy(sceneInPath, sceneOutPath)
        iconInPath = f&#34;{editionInPath}/{sceneIcon}&#34;
        iconOutPath = f&#34;{editionOutPath}/{sceneIcon}&#34;
        fileCopy(iconInPath, iconOutPath)

    articlesInPath = f&#34;{editionInPath}/articles&#34;
    articlesOutPath = f&#34;{editionOutPath}/articles&#34;
    Messages.plain(logmsg=&#34;\t\tARTICLES&#34;)
    dirCopy(articlesInPath, articlesOutPath)</code></pre>
</details>
</dd>
<dt id="control.collect.Collect.doWorkflow"><code class="name flex">
<span>def <span class="ident">doWorkflow</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Collects workflow information from yaml files.</p>
<div class="admonition note">
<p class="admonition-title">Test users</p>
<p>This includes test users when in test mode.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/43bd2e150961ad81f2af6575b1c8f269a7e20738/src/pure3d/control/collect.py#L339-L386" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def doWorkflow(self):
    &#34;&#34;&#34;Collects workflow information from yaml files.

    !!! note &#34;Test users&#34;
        This includes test users when in test mode.
    &#34;&#34;&#34;
    Messages = self.Messages
    Mongo = self.Mongo
    importDir = self.importDir

    projectIdByName = self.projectIdByName

    workflowDir = f&#34;{importDir}/workflow&#34;
    workflowPath = f&#34;{workflowDir}/init.yml&#34;
    workflow = readYaml(workflowPath, defaultEmpty=True)
    users = workflow[&#34;users&#34;]
    projectUsers = workflow[&#34;projectUsers&#34;]
    projectStatus = workflow[&#34;projectStatus&#34;]

    userByName = {}

    for (userName, role) in users.items():
        sub = f&#34;{userName:0&gt;16}&#34;
        userInfo = dict(
            nickname=userName,
            sub=sub,
            role=role,
            isTest=True,
        )
        Mongo.insertRecord(&#34;users&#34;, **userInfo)
        userByName[userName] = sub

    for (projectName, isPublished) in projectStatus.items():
        Messages.plain(logmsg=f&#34;PROJECT {projectName} published: {isPublished}&#34;)
        Mongo.updateRecord(
            &#34;projects&#34;,
            dict(isPublished=isPublished),
            _id=projectIdByName[projectName],
        )

    for (projectName, projectUsrs) in projectUsers.items():
        for (userName, role) in projectUsrs.items():
            xInfo = dict(
                user=userByName[userName],
                projectId=projectIdByName[projectName],
                role=role,
            )
            Mongo.insertRecord(&#34;projectUsers&#34;, **xInfo)</code></pre>
</details>
</dd>
<dt id="control.collect.Collect.fetch"><code class="name flex">
<span>def <span class="ident">fetch</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Performs a data collection.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/43bd2e150961ad81f2af6575b1c8f269a7e20738/src/pure3d/control/collect.py#L87-L95" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def fetch(self):
    &#34;&#34;&#34;Performs a data collection.&#34;&#34;&#34;
    Messages = self.Messages
    Messages.info(logmsg=&#34;Collecting data before starting the app&#34;)

    self.clearDb()
    self.doOuter()
    self.doProjects()
    self.doWorkflow()</code></pre>
</details>
</dd>
<dt id="control.collect.Collect.trigger"><code class="name flex">
<span>def <span class="ident">trigger</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Determines whether data collection should be done.</p>
<p>We only do data collection if the environment variable <code>docollect</code> is <code>v</code>
If so, the value of the environment variable <code>initdata</code>
is the name of a subdirectory of the data directory.
This subdirectory contains example data that will be imported into the system.</p>
<p>We also prevent this from happening twice, which occurs when Flask runs
in debug mode, since then the code is loaded twice.
We guard against this by inspecting the environment variable
<code>WERKZEUG_RUN_MAIN</code>. If it is set, we are already running the app,
and data collection should be inhibited, because it has been done
just before Flask started running.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/43bd2e150961ad81f2af6575b1c8f269a7e20738/src/pure3d/control/collect.py#L68-L85" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def trigger(self):
    &#34;&#34;&#34;Determines whether data collection should be done.

    We only do data collection if the environment variable `docollect` is `v`
    If so, the value of the environment variable `initdata`
    is the name of a subdirectory of the data directory.
    This subdirectory contains example data that will be imported into the system.

    We also prevent this from happening twice, which occurs when Flask runs
    in debug mode, since then the code is loaded twice.
    We guard against this by inspecting the environment variable
    `WERKZEUG_RUN_MAIN`. If it is set, we are already running the app,
    and data collection should be inhibited, because it has been done
    just before Flask started running.
    &#34;&#34;&#34;
    doCollect = var(&#34;docollect&#34;) == &#34;v&#34;

    return initializing() and doCollect</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<p><a href="https://github.com/CLARIAH/pure3dx" title="GitHub repo">GitHub</a></p>
<form>
<input id="lunr-search" name="q" placeholder="🔎 Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="control" href="index.html">control</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="control.collect.Collect" href="#control.collect.Collect">Collect</a></code></h4>
<ul class="two-column">
<li><code><a title="control.collect.Collect.clearDb" href="#control.collect.Collect.clearDb">clearDb</a></code></li>
<li><code><a title="control.collect.Collect.doEdition" href="#control.collect.Collect.doEdition">doEdition</a></code></li>
<li><code><a title="control.collect.Collect.doEditions" href="#control.collect.Collect.doEditions">doEditions</a></code></li>
<li><code><a title="control.collect.Collect.doOuter" href="#control.collect.Collect.doOuter">doOuter</a></code></li>
<li><code><a title="control.collect.Collect.doProject" href="#control.collect.Collect.doProject">doProject</a></code></li>
<li><code><a title="control.collect.Collect.doProjects" href="#control.collect.Collect.doProjects">doProjects</a></code></li>
<li><code><a title="control.collect.Collect.doScenes" href="#control.collect.Collect.doScenes">doScenes</a></code></li>
<li><code><a title="control.collect.Collect.doWorkflow" href="#control.collect.Collect.doWorkflow">doWorkflow</a></code></li>
<li><code><a title="control.collect.Collect.fetch" href="#control.collect.Collect.fetch">fetch</a></code></li>
<li><code><a title="control.collect.Collect.trigger" href="#control.collect.Collect.trigger">trigger</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<a href="https://pure.knaw.nl/portal/en/persons/dirk-roorda">Dirk Roorda</a>
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>