<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>control.viewers API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>control.viewers</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/4bb2a3c091b2869e30f26c6c28942718f16603ee/src/control/viewers.py#L1-L482" class="git-link">Browse git</a>
</summary>
<pre><code class="python">from textwrap import dedent

from control.generic import AttrDict, attResolve


class Viewers:
    def __init__(self, Settings, Messages):
        &#34;&#34;&#34;Knowledge of the installed 3D viewers.

        This class knows which (versions of) viewers are installed,
        and has the methods to invoke them.

        It is instantiated by a singleton object.

        Parameters
        ----------
        Settings: AttrDict
            App-wide configuration data obtained from
            `control.config.Config.Settings`.
        Messages: object
            Singleton instance of `control.messages.Messages`.
        &#34;&#34;&#34;
        self.Settings = Settings
        self.Messages = Messages
        Messages.debugAdd(self)
        self.viewers = Settings.viewers
        self.viewerActions = Settings.viewerActions
        self.viewerDefault = Settings.viewerDefault

    def addAuth(self, Auth):
        &#34;&#34;&#34;Give this object a handle to the Auth object.

        The Viewers and Auth objects need each other, so one of them must
        be given the handle to the other after initialization.
        &#34;&#34;&#34;
        self.Auth = Auth

    def check(self, viewer, version):
        &#34;&#34;&#34;Checks whether a viewer version exists.

        Given a viewer and a version, it is looked up whether the code
        is present.
        If not, reasonable defaults returned instead by default.

        Parameters
        ----------
        viewer: string
            The viewer in question.
        version: string
            The version of the viewer in question.

        Returns
        -------
        string | void
            The version is returned unmodified if that viewer
            version is supported.
            If the viewer is supported, but not the version, the default version
            of that viewer is taken, if there is a default version,
            otherwise the latest supported version.
            If the viewer is not supported, None is returned.
        &#34;&#34;&#34;
        viewers = self.viewers

        if viewer not in viewers:
            return None

        viewerInfo = viewers[viewer]
        versions = viewerInfo.versions
        defaultVersion = viewerInfo.defaultVersion
        if version not in versions:
            version = defaultVersion
        return version

    def getViewInfo(self, edition):
        &#34;&#34;&#34;Gets viewer-related info that an edition is made with.

        Parameters
        ----------
        edition: AttrDict
            The edition record.

        Returns
        -------
        tuple of string
            * The name of the viewer
            * The name of the scene

        &#34;&#34;&#34;
        viewerDefault = self.viewerDefault

        editionId = edition._id
        if editionId is None:
            return (viewerDefault, None)

        editionSettings = edition.settings or AttrDict()
        authorTool = editionSettings.authorTool or AttrDict()
        viewer = authorTool.name or viewerDefault
        sceneFile = authorTool.sceneFile

        return (viewer, sceneFile)

    def getFrame(
        self, edition, actions, viewer, versionActive, actionActive, sceneExists
    ):
        &#34;&#34;&#34;Produces a set of buttons to launch 3D viewers for a scene.

        Make sure that if there is no scene file present, no viewer will be opened.

        Parameters
        ----------
        edition: AttrDict
            The edition in question.
        actions: iterable of string
            The actions for which we have to create buttons.
            Typically `read` and possibly also `update`.
            Actions that are not recognized as viewer actions
            will be filtered out, such as `create` and `delete`.
        viewer: string
            The viewer in which the scene is currently loaded.
        versionActive: string | void
            The version of the viewer in which the scene is currently loaded,
            if any, otherwise None
        actionActive: string | void
            The mode in which the scene is currently loaded in the viewer
            (`read` or `update`),
            if any, otherwise None
        sceneExists: boolean
            Whether the scene file exists.

        Returns
        -------
        string
            The HTML that represents the buttons.
        &#34;&#34;&#34;
        Settings = self.Settings
        H = Settings.H
        actionInfo = self.viewerActions
        viewers = self.viewers

        filteredActions = {a for a in actions if a in actionInfo and a != &#34;create&#34;}
        versionActive = self.check(viewer, versionActive)

        editionId = edition._id
        if editionId is None:
            return (&#34;&#34;, &#34;&#34;)

        create = &#34;/update&#34; if sceneExists else &#34;/create&#34;

        src = f&#34;/viewer/{versionActive}/{actionActive}/{editionId}{create}&#34;
        frame = H.div(
            H.div(H.iframe(src, cls=&#34;previewer&#34;), cls=&#34;surround&#34;), cls=&#34;model&#34;
        )

        def getViewerButtons(vw):
            &#34;&#34;&#34;Internal function.

            Returns
            -------
            string
                HTML for the buttons to launch a viewer.
            &#34;&#34;&#34;
            openAtt = vw == viewer

            versions = viewers[vw].versions
            if len(versions) == 1:
                version = versions[0]
                return H.table(
                    [
                        getVersionButtons(
                            version,
                            version == versionActive,
                            versionAmount=len(versions),
                            withViewer=True,
                            withVersion=True,
                            # withViewer=not pilotMode,
                            # withVersion=not pilotMode,
                        )
                    ],
                    [],
                    cls=&#34;vwv&#34;,
                )

            (latest, previous) = (versions[0:1], versions[1:])

            openAtt = vw == viewer and len(previous) and versionActive in previous

            return H.details(
                H.table(
                    [
                        getVersionButtons(
                            version,
                            version == versionActive,
                            versionAmount=len(versions),
                            withViewer=True,
                        )
                        for version in latest
                    ],
                    [],
                    cls=&#34;vwv&#34;,
                ),
                H.table(
                    [],
                    [
                        getVersionButtons(
                            version, version == versionActive, withViewer=False
                        )
                        for version in previous
                    ],
                    cls=&#34;vwv&#34;,
                ),
                f&#34;vwbuttons-{editionId}&#34;,
                cls=&#34;vw&#34;,
                open=openAtt,
            )

        def getVersionButtons(
            version, active, versionAmount=None, withViewer=False, withVersion=True
        ):
            &#34;&#34;&#34;Internal function.

            Parameters
            ----------
            version: string
                The version of the viewer.
            active: boolean
                Whether that version of that viewer is currently active.
            versionAmount: int, optional None
                If passed, contains the number of versions and displays it.
            withViewer: boolean, optional False
                Whether to show the viewer name in the first column.
            withVersion: boolean, optional True
                Whether to show the version in the second column.

            Returns
            -------
            string
                HTML for the buttons to launch a specific version of a viewer.
            &#34;&#34;&#34;
            activeRowCls = &#34;activer&#34; if active else &#34;&#34;

            plural = &#34;&#34; if versionAmount == 2 else &#34;s&#34;
            title = (
                f&#34;click to show previous {versionAmount - 1} {viewer} version{plural}&#34;
                if versionAmount and versionAmount &gt; 1
                else f&#34;no previous {viewer} versions&#34;
            )

            return (
                [
                    (viewer if withViewer else H.nbsp, dict(cls=&#34;vwc&#34;, title=title)),
                    (
                        version if withVersion else H.nbsp,
                        dict(cls=&#34;vvl vwc&#34;, title=title),
                    ),
                ]
                + [
                    getActionButton(
                        version, action, disabled=active and action == actionActive
                    )
                    for action in sorted(filteredActions)
                ],
                dict(cls=activeRowCls),
            )

        def getActionButton(version, action, disabled=False):
            &#34;&#34;&#34;Internal function.

            Parameters
            ----------
            version: string
                The version of the viewer.
            action: string
                Whether to launch the viewer for `read` or for `update`.
            disabled: boolean, optional Fasle
                Whether to show the button as disabled

            Returns
            -------
            string
                HTML for the buttons to launch a specific version of a viewer
                for a specific action.
            &#34;&#34;&#34;
            atts = {}

            href = None if disabled else f&#34;/edition/{editionId}/{version}/{action}&#34;

            if action == &#34;update&#34;:
                viewerHref = f&#34;/viewer/{version}/{action}/{editionId}{create}&#34;
                atts[&#34;onclick&#34;] = dedent(
                    f&#34;&#34;&#34;
                    window.open(
                        &#39;{viewerHref}&#39;,
                        &#39;newwindow&#39;,
                        width=window.innerWidth,
                        height=window.innerHeight
                    );
                    return false;
                    &#34;&#34;&#34;
                )

            titleFragment = &#34;a new window&#34; if action == &#34;update&#34; else &#34;place&#34;

            createMode = action == &#34;update&#34; and not sceneExists
            action = &#34;create&#34; if createMode else action
            thisActionInfo = actionInfo.get(action, AttrDict())
            name = thisActionInfo.name
            atts[&#34;title&#34;] = f&#34;{name} scene in {titleFragment}&#34;

            disabledCls = &#34;disabled&#34; if disabled else &#34;&#34;
            activeCellCls = &#34;activec&#34; if disabled else &#34;&#34;
            cls = f&#34;button vwb {disabledCls}&#34;

            return (
                H.iconx(action, text=name, href=href, cls=cls, **atts),
                dict(cls=f&#34;vwc {activeCellCls}&#34;),
            )

        allButtons = H.div([getViewerButtons(vw) for vw in viewers])

        return (frame if sceneExists else &#34;&#34;, allButtons)

    def genHtml(self, urlBase, sceneFile, viewer, version, action, subMode):
        &#34;&#34;&#34;Generates the HTML for the viewer page that is loaded in an iframe.

        When a scene is loaded in a viewer, it happens in an iframe.
        Here we generate the complete HTML for such an iframe.

        Parameters
        ----------
        urlBase: string
            The first part of the root url that is given to the viewer.
            The viewer code uses this to retrieve additional information.
            The root url will be completed with the `action` and the `viewer`.
        sceneFile: string
            The name of the scene file in the file system.
        viewer: string
            The chosen viewer.
        version: string
            The chosen version of the viewer.
        action: string
            The chosen mode in which the viewer is launched (`read` or `update`).
        subMode: string | None
            The sub mode in which the viewer is to be used (`update` or `create`).

        Returns
        -------
        string
            The HTML for the iframe.
        &#34;&#34;&#34;
        Settings = self.Settings
        H = Settings.H
        debugMode = Settings.debugMode
        viewerUrlBase = Settings.viewerUrlBase
        viewers = self.viewers

        ext = &#34;dev&#34; if debugMode else &#34;min&#34;

        viewerStaticRoot = self.getStaticRoot(viewerUrlBase, action, viewer, version)

        viewerRoot = self.getRoot(urlBase, action, viewer)

        if viewer == &#34;voyager&#34;:
            modes = viewers[viewer].modes
            modeProps = modes[action]
            element = modeProps.element
            fileBase = modeProps.fileBase
            subModes = modeProps.subModes or AttrDict()
            atts = attResolve(subModes[subMode] or AttrDict(), version)
            if subMode != &#34;create&#34;:
                atts[&#34;document&#34;] = sceneFile

            return H.content(
                H.head(
                    [
                        H.meta(charset=&#34;utf-8&#34;),
                        H.link(
                            &#34;shortcut icon&#34;,
                            f&#34;{viewerStaticRoot}/favicon.png&#34;,
                            tp=&#34;image/png&#34;,
                        ),
                        H.link(&#34;stylesheet&#34;, f&#34;{viewerStaticRoot}/fonts/fonts.css&#34;),
                        H.link(
                            &#34;stylesheet&#34;, f&#34;{viewerStaticRoot}/css/{fileBase}.{ext}.css&#34;
                        ),
                        H.script(
                            &#34;&#34;,
                            defer=True,
                            src=f&#34;{viewerStaticRoot}/js/{fileBase}.{ext}.js&#34;,
                        ),
                    ]
                ),
                H.body(
                    H.elem(
                        element,
                        &#34;&#34;,
                        root=viewerRoot,
                        resourceroot=f&#34;{viewerStaticRoot}/&#34;,
                        **atts,
                    )
                ),
            )
        else:
            return H.content(
                H.head(H.meta(charset=&#34;utf-8&#34;)),
                H.body(H.p(f&#34;Unsupported viewer: {viewer}&#34;)),
            )

    def getRoot(self, urlBase, action, viewer):
        &#34;&#34;&#34;Composes the root url for a viewer.

        The root url is passed to a viewer instance as the url that
        the viewer can use to fetch its data.
        It is not meant for the static data that is part of the viewer software,
        but for the model related data that the viewer is going to display.

        See `getStaticRoot()` for the url meant for getting parts of the
        viewer software.

        Parameters
        ----------
        urlBase: string
            The first part of the root url, depending
            on the project and edition.
        action: string
            The mode in which the viewer is opened.
            Depending on the mode, the viewer code may communicate with the server
            with different urls.
            For example, for the voyager,
            the `read` mode (voyager-explorer) uses ordinary HTTP requests,
            but the `update` mode (voyager-story) uses WebDAV requests.

            So this app points voyager-explorer to a root url starting with `/data`,
            and voyager-story to a root url starting with `/webdav`.

            These prefixes of the urls can be configured per viewer
            in the viewer configuration in `yaml/viewers.yml`.
        &#34;&#34;&#34;
        viewers = self.viewers

        if viewer not in viewers:
            return None

        modes = viewers[viewer].modes

        thisMode = modes[action] or modes.read
        prefix = thisMode.prefix

        return f&#34;{prefix}/{urlBase}&#34;

    def getStaticRoot(self, viewerUrlBase, action, viewer, version):
        &#34;&#34;&#34;Composes the static root url for a viewer.

        The static root url is passed to a viewer instance as the url that the
        viewer can use to fetch its assets.
        It is not meant for the model related data, but for the parts of the
        viewer software that it needs to get from the server.

        See `getRoot()` for the url meant for getting model-related data.

        Parameters
        ----------
        urlBase: string
            The first part of the root url, depending
            on the project and edition.
        action: string
            The mode in which the viewer is opened.
            Depending on the mode, the viewer code may communicate with the server
            with different urls.
            For example, for the voyager,
            the `read` mode (voyager-explorer) uses ordinary HTTP requests,
            but the `update` mode (voyager-story) uses WebDAV requests.

            So this app points voyager-explorer to a root url starting with `/data`,
            and voyager-story to a root url starting with `/webdav`.

            These prefixes of the urls can be configured per viewer
            in the viewer configuration in `yaml/viewers.yml`.
        &#34;&#34;&#34;
        if not self.check(viewer, version):
            return None

        return f&#34;{viewerUrlBase}/{viewer}/{version}&#34;</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="control.viewers.Viewers"><code class="flex name class">
<span>class <span class="ident">Viewers</span></span>
<span>(</span><span>Settings, Messages)</span>
</code></dt>
<dd>
<div class="desc"><p>Knowledge of the installed 3D viewers.</p>
<p>This class knows which (versions of) viewers are installed,
and has the methods to invoke them.</p>
<p>It is instantiated by a singleton object.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>Settings</code></strong> :&ensp;<code>AttrDict</code></dt>
<dd>App-wide configuration data obtained from
<code><a title="control.config.Config.Settings" href="config.html#control.config.Config.Settings">Config.Settings</a></code>.</dd>
<dt><strong><code>Messages</code></strong> :&ensp;<code>object</code></dt>
<dd>Singleton instance of <code><a title="control.messages.Messages" href="messages.html#control.messages.Messages">Messages</a></code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/4bb2a3c091b2869e30f26c6c28942718f16603ee/src/control/viewers.py#L6-L482" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Viewers:
    def __init__(self, Settings, Messages):
        &#34;&#34;&#34;Knowledge of the installed 3D viewers.

        This class knows which (versions of) viewers are installed,
        and has the methods to invoke them.

        It is instantiated by a singleton object.

        Parameters
        ----------
        Settings: AttrDict
            App-wide configuration data obtained from
            `control.config.Config.Settings`.
        Messages: object
            Singleton instance of `control.messages.Messages`.
        &#34;&#34;&#34;
        self.Settings = Settings
        self.Messages = Messages
        Messages.debugAdd(self)
        self.viewers = Settings.viewers
        self.viewerActions = Settings.viewerActions
        self.viewerDefault = Settings.viewerDefault

    def addAuth(self, Auth):
        &#34;&#34;&#34;Give this object a handle to the Auth object.

        The Viewers and Auth objects need each other, so one of them must
        be given the handle to the other after initialization.
        &#34;&#34;&#34;
        self.Auth = Auth

    def check(self, viewer, version):
        &#34;&#34;&#34;Checks whether a viewer version exists.

        Given a viewer and a version, it is looked up whether the code
        is present.
        If not, reasonable defaults returned instead by default.

        Parameters
        ----------
        viewer: string
            The viewer in question.
        version: string
            The version of the viewer in question.

        Returns
        -------
        string | void
            The version is returned unmodified if that viewer
            version is supported.
            If the viewer is supported, but not the version, the default version
            of that viewer is taken, if there is a default version,
            otherwise the latest supported version.
            If the viewer is not supported, None is returned.
        &#34;&#34;&#34;
        viewers = self.viewers

        if viewer not in viewers:
            return None

        viewerInfo = viewers[viewer]
        versions = viewerInfo.versions
        defaultVersion = viewerInfo.defaultVersion
        if version not in versions:
            version = defaultVersion
        return version

    def getViewInfo(self, edition):
        &#34;&#34;&#34;Gets viewer-related info that an edition is made with.

        Parameters
        ----------
        edition: AttrDict
            The edition record.

        Returns
        -------
        tuple of string
            * The name of the viewer
            * The name of the scene

        &#34;&#34;&#34;
        viewerDefault = self.viewerDefault

        editionId = edition._id
        if editionId is None:
            return (viewerDefault, None)

        editionSettings = edition.settings or AttrDict()
        authorTool = editionSettings.authorTool or AttrDict()
        viewer = authorTool.name or viewerDefault
        sceneFile = authorTool.sceneFile

        return (viewer, sceneFile)

    def getFrame(
        self, edition, actions, viewer, versionActive, actionActive, sceneExists
    ):
        &#34;&#34;&#34;Produces a set of buttons to launch 3D viewers for a scene.

        Make sure that if there is no scene file present, no viewer will be opened.

        Parameters
        ----------
        edition: AttrDict
            The edition in question.
        actions: iterable of string
            The actions for which we have to create buttons.
            Typically `read` and possibly also `update`.
            Actions that are not recognized as viewer actions
            will be filtered out, such as `create` and `delete`.
        viewer: string
            The viewer in which the scene is currently loaded.
        versionActive: string | void
            The version of the viewer in which the scene is currently loaded,
            if any, otherwise None
        actionActive: string | void
            The mode in which the scene is currently loaded in the viewer
            (`read` or `update`),
            if any, otherwise None
        sceneExists: boolean
            Whether the scene file exists.

        Returns
        -------
        string
            The HTML that represents the buttons.
        &#34;&#34;&#34;
        Settings = self.Settings
        H = Settings.H
        actionInfo = self.viewerActions
        viewers = self.viewers

        filteredActions = {a for a in actions if a in actionInfo and a != &#34;create&#34;}
        versionActive = self.check(viewer, versionActive)

        editionId = edition._id
        if editionId is None:
            return (&#34;&#34;, &#34;&#34;)

        create = &#34;/update&#34; if sceneExists else &#34;/create&#34;

        src = f&#34;/viewer/{versionActive}/{actionActive}/{editionId}{create}&#34;
        frame = H.div(
            H.div(H.iframe(src, cls=&#34;previewer&#34;), cls=&#34;surround&#34;), cls=&#34;model&#34;
        )

        def getViewerButtons(vw):
            &#34;&#34;&#34;Internal function.

            Returns
            -------
            string
                HTML for the buttons to launch a viewer.
            &#34;&#34;&#34;
            openAtt = vw == viewer

            versions = viewers[vw].versions
            if len(versions) == 1:
                version = versions[0]
                return H.table(
                    [
                        getVersionButtons(
                            version,
                            version == versionActive,
                            versionAmount=len(versions),
                            withViewer=True,
                            withVersion=True,
                            # withViewer=not pilotMode,
                            # withVersion=not pilotMode,
                        )
                    ],
                    [],
                    cls=&#34;vwv&#34;,
                )

            (latest, previous) = (versions[0:1], versions[1:])

            openAtt = vw == viewer and len(previous) and versionActive in previous

            return H.details(
                H.table(
                    [
                        getVersionButtons(
                            version,
                            version == versionActive,
                            versionAmount=len(versions),
                            withViewer=True,
                        )
                        for version in latest
                    ],
                    [],
                    cls=&#34;vwv&#34;,
                ),
                H.table(
                    [],
                    [
                        getVersionButtons(
                            version, version == versionActive, withViewer=False
                        )
                        for version in previous
                    ],
                    cls=&#34;vwv&#34;,
                ),
                f&#34;vwbuttons-{editionId}&#34;,
                cls=&#34;vw&#34;,
                open=openAtt,
            )

        def getVersionButtons(
            version, active, versionAmount=None, withViewer=False, withVersion=True
        ):
            &#34;&#34;&#34;Internal function.

            Parameters
            ----------
            version: string
                The version of the viewer.
            active: boolean
                Whether that version of that viewer is currently active.
            versionAmount: int, optional None
                If passed, contains the number of versions and displays it.
            withViewer: boolean, optional False
                Whether to show the viewer name in the first column.
            withVersion: boolean, optional True
                Whether to show the version in the second column.

            Returns
            -------
            string
                HTML for the buttons to launch a specific version of a viewer.
            &#34;&#34;&#34;
            activeRowCls = &#34;activer&#34; if active else &#34;&#34;

            plural = &#34;&#34; if versionAmount == 2 else &#34;s&#34;
            title = (
                f&#34;click to show previous {versionAmount - 1} {viewer} version{plural}&#34;
                if versionAmount and versionAmount &gt; 1
                else f&#34;no previous {viewer} versions&#34;
            )

            return (
                [
                    (viewer if withViewer else H.nbsp, dict(cls=&#34;vwc&#34;, title=title)),
                    (
                        version if withVersion else H.nbsp,
                        dict(cls=&#34;vvl vwc&#34;, title=title),
                    ),
                ]
                + [
                    getActionButton(
                        version, action, disabled=active and action == actionActive
                    )
                    for action in sorted(filteredActions)
                ],
                dict(cls=activeRowCls),
            )

        def getActionButton(version, action, disabled=False):
            &#34;&#34;&#34;Internal function.

            Parameters
            ----------
            version: string
                The version of the viewer.
            action: string
                Whether to launch the viewer for `read` or for `update`.
            disabled: boolean, optional Fasle
                Whether to show the button as disabled

            Returns
            -------
            string
                HTML for the buttons to launch a specific version of a viewer
                for a specific action.
            &#34;&#34;&#34;
            atts = {}

            href = None if disabled else f&#34;/edition/{editionId}/{version}/{action}&#34;

            if action == &#34;update&#34;:
                viewerHref = f&#34;/viewer/{version}/{action}/{editionId}{create}&#34;
                atts[&#34;onclick&#34;] = dedent(
                    f&#34;&#34;&#34;
                    window.open(
                        &#39;{viewerHref}&#39;,
                        &#39;newwindow&#39;,
                        width=window.innerWidth,
                        height=window.innerHeight
                    );
                    return false;
                    &#34;&#34;&#34;
                )

            titleFragment = &#34;a new window&#34; if action == &#34;update&#34; else &#34;place&#34;

            createMode = action == &#34;update&#34; and not sceneExists
            action = &#34;create&#34; if createMode else action
            thisActionInfo = actionInfo.get(action, AttrDict())
            name = thisActionInfo.name
            atts[&#34;title&#34;] = f&#34;{name} scene in {titleFragment}&#34;

            disabledCls = &#34;disabled&#34; if disabled else &#34;&#34;
            activeCellCls = &#34;activec&#34; if disabled else &#34;&#34;
            cls = f&#34;button vwb {disabledCls}&#34;

            return (
                H.iconx(action, text=name, href=href, cls=cls, **atts),
                dict(cls=f&#34;vwc {activeCellCls}&#34;),
            )

        allButtons = H.div([getViewerButtons(vw) for vw in viewers])

        return (frame if sceneExists else &#34;&#34;, allButtons)

    def genHtml(self, urlBase, sceneFile, viewer, version, action, subMode):
        &#34;&#34;&#34;Generates the HTML for the viewer page that is loaded in an iframe.

        When a scene is loaded in a viewer, it happens in an iframe.
        Here we generate the complete HTML for such an iframe.

        Parameters
        ----------
        urlBase: string
            The first part of the root url that is given to the viewer.
            The viewer code uses this to retrieve additional information.
            The root url will be completed with the `action` and the `viewer`.
        sceneFile: string
            The name of the scene file in the file system.
        viewer: string
            The chosen viewer.
        version: string
            The chosen version of the viewer.
        action: string
            The chosen mode in which the viewer is launched (`read` or `update`).
        subMode: string | None
            The sub mode in which the viewer is to be used (`update` or `create`).

        Returns
        -------
        string
            The HTML for the iframe.
        &#34;&#34;&#34;
        Settings = self.Settings
        H = Settings.H
        debugMode = Settings.debugMode
        viewerUrlBase = Settings.viewerUrlBase
        viewers = self.viewers

        ext = &#34;dev&#34; if debugMode else &#34;min&#34;

        viewerStaticRoot = self.getStaticRoot(viewerUrlBase, action, viewer, version)

        viewerRoot = self.getRoot(urlBase, action, viewer)

        if viewer == &#34;voyager&#34;:
            modes = viewers[viewer].modes
            modeProps = modes[action]
            element = modeProps.element
            fileBase = modeProps.fileBase
            subModes = modeProps.subModes or AttrDict()
            atts = attResolve(subModes[subMode] or AttrDict(), version)
            if subMode != &#34;create&#34;:
                atts[&#34;document&#34;] = sceneFile

            return H.content(
                H.head(
                    [
                        H.meta(charset=&#34;utf-8&#34;),
                        H.link(
                            &#34;shortcut icon&#34;,
                            f&#34;{viewerStaticRoot}/favicon.png&#34;,
                            tp=&#34;image/png&#34;,
                        ),
                        H.link(&#34;stylesheet&#34;, f&#34;{viewerStaticRoot}/fonts/fonts.css&#34;),
                        H.link(
                            &#34;stylesheet&#34;, f&#34;{viewerStaticRoot}/css/{fileBase}.{ext}.css&#34;
                        ),
                        H.script(
                            &#34;&#34;,
                            defer=True,
                            src=f&#34;{viewerStaticRoot}/js/{fileBase}.{ext}.js&#34;,
                        ),
                    ]
                ),
                H.body(
                    H.elem(
                        element,
                        &#34;&#34;,
                        root=viewerRoot,
                        resourceroot=f&#34;{viewerStaticRoot}/&#34;,
                        **atts,
                    )
                ),
            )
        else:
            return H.content(
                H.head(H.meta(charset=&#34;utf-8&#34;)),
                H.body(H.p(f&#34;Unsupported viewer: {viewer}&#34;)),
            )

    def getRoot(self, urlBase, action, viewer):
        &#34;&#34;&#34;Composes the root url for a viewer.

        The root url is passed to a viewer instance as the url that
        the viewer can use to fetch its data.
        It is not meant for the static data that is part of the viewer software,
        but for the model related data that the viewer is going to display.

        See `getStaticRoot()` for the url meant for getting parts of the
        viewer software.

        Parameters
        ----------
        urlBase: string
            The first part of the root url, depending
            on the project and edition.
        action: string
            The mode in which the viewer is opened.
            Depending on the mode, the viewer code may communicate with the server
            with different urls.
            For example, for the voyager,
            the `read` mode (voyager-explorer) uses ordinary HTTP requests,
            but the `update` mode (voyager-story) uses WebDAV requests.

            So this app points voyager-explorer to a root url starting with `/data`,
            and voyager-story to a root url starting with `/webdav`.

            These prefixes of the urls can be configured per viewer
            in the viewer configuration in `yaml/viewers.yml`.
        &#34;&#34;&#34;
        viewers = self.viewers

        if viewer not in viewers:
            return None

        modes = viewers[viewer].modes

        thisMode = modes[action] or modes.read
        prefix = thisMode.prefix

        return f&#34;{prefix}/{urlBase}&#34;

    def getStaticRoot(self, viewerUrlBase, action, viewer, version):
        &#34;&#34;&#34;Composes the static root url for a viewer.

        The static root url is passed to a viewer instance as the url that the
        viewer can use to fetch its assets.
        It is not meant for the model related data, but for the parts of the
        viewer software that it needs to get from the server.

        See `getRoot()` for the url meant for getting model-related data.

        Parameters
        ----------
        urlBase: string
            The first part of the root url, depending
            on the project and edition.
        action: string
            The mode in which the viewer is opened.
            Depending on the mode, the viewer code may communicate with the server
            with different urls.
            For example, for the voyager,
            the `read` mode (voyager-explorer) uses ordinary HTTP requests,
            but the `update` mode (voyager-story) uses WebDAV requests.

            So this app points voyager-explorer to a root url starting with `/data`,
            and voyager-story to a root url starting with `/webdav`.

            These prefixes of the urls can be configured per viewer
            in the viewer configuration in `yaml/viewers.yml`.
        &#34;&#34;&#34;
        if not self.check(viewer, version):
            return None

        return f&#34;{viewerUrlBase}/{viewer}/{version}&#34;</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="control.viewers.Viewers.addAuth"><code class="name flex">
<span>def <span class="ident">addAuth</span></span>(<span>self, Auth)</span>
</code></dt>
<dd>
<div class="desc"><p>Give this object a handle to the Auth object.</p>
<p>The Viewers and Auth objects need each other, so one of them must
be given the handle to the other after initialization.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/4bb2a3c091b2869e30f26c6c28942718f16603ee/src/control/viewers.py#L30-L36" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def addAuth(self, Auth):
    &#34;&#34;&#34;Give this object a handle to the Auth object.

    The Viewers and Auth objects need each other, so one of them must
    be given the handle to the other after initialization.
    &#34;&#34;&#34;
    self.Auth = Auth</code></pre>
</details>
</dd>
<dt id="control.viewers.Viewers.check"><code class="name flex">
<span>def <span class="ident">check</span></span>(<span>self, viewer, version)</span>
</code></dt>
<dd>
<div class="desc"><p>Checks whether a viewer version exists.</p>
<p>Given a viewer and a version, it is looked up whether the code
is present.
If not, reasonable defaults returned instead by default.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>viewer</code></strong> :&ensp;<code>string</code></dt>
<dd>The viewer in question.</dd>
<dt><strong><code>version</code></strong> :&ensp;<code>string</code></dt>
<dd>The version of the viewer in question.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>string | void</code></dt>
<dd>The version is returned unmodified if that viewer
version is supported.
If the viewer is supported, but not the version, the default version
of that viewer is taken, if there is a default version,
otherwise the latest supported version.
If the viewer is not supported, None is returned.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/4bb2a3c091b2869e30f26c6c28942718f16603ee/src/control/viewers.py#L38-L72" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def check(self, viewer, version):
    &#34;&#34;&#34;Checks whether a viewer version exists.

    Given a viewer and a version, it is looked up whether the code
    is present.
    If not, reasonable defaults returned instead by default.

    Parameters
    ----------
    viewer: string
        The viewer in question.
    version: string
        The version of the viewer in question.

    Returns
    -------
    string | void
        The version is returned unmodified if that viewer
        version is supported.
        If the viewer is supported, but not the version, the default version
        of that viewer is taken, if there is a default version,
        otherwise the latest supported version.
        If the viewer is not supported, None is returned.
    &#34;&#34;&#34;
    viewers = self.viewers

    if viewer not in viewers:
        return None

    viewerInfo = viewers[viewer]
    versions = viewerInfo.versions
    defaultVersion = viewerInfo.defaultVersion
    if version not in versions:
        version = defaultVersion
    return version</code></pre>
</details>
</dd>
<dt id="control.viewers.Viewers.genHtml"><code class="name flex">
<span>def <span class="ident">genHtml</span></span>(<span>self, urlBase, sceneFile, viewer, version, action, subMode)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates the HTML for the viewer page that is loaded in an iframe.</p>
<p>When a scene is loaded in a viewer, it happens in an iframe.
Here we generate the complete HTML for such an iframe.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>urlBase</code></strong> :&ensp;<code>string</code></dt>
<dd>The first part of the root url that is given to the viewer.
The viewer code uses this to retrieve additional information.
The root url will be completed with the <code>action</code> and the <code>viewer</code>.</dd>
<dt><strong><code>sceneFile</code></strong> :&ensp;<code>string</code></dt>
<dd>The name of the scene file in the file system.</dd>
<dt><strong><code>viewer</code></strong> :&ensp;<code>string</code></dt>
<dd>The chosen viewer.</dd>
<dt><strong><code>version</code></strong> :&ensp;<code>string</code></dt>
<dd>The chosen version of the viewer.</dd>
<dt><strong><code>action</code></strong> :&ensp;<code>string</code></dt>
<dd>The chosen mode in which the viewer is launched (<code>read</code> or <code>update</code>).</dd>
<dt><strong><code>subMode</code></strong> :&ensp;<code>string | None</code></dt>
<dd>The sub mode in which the viewer is to be used (<code>update</code> or <code>create</code>).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>string</code></dt>
<dd>The HTML for the iframe.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/4bb2a3c091b2869e30f26c6c28942718f16603ee/src/control/viewers.py#L322-L406" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def genHtml(self, urlBase, sceneFile, viewer, version, action, subMode):
    &#34;&#34;&#34;Generates the HTML for the viewer page that is loaded in an iframe.

    When a scene is loaded in a viewer, it happens in an iframe.
    Here we generate the complete HTML for such an iframe.

    Parameters
    ----------
    urlBase: string
        The first part of the root url that is given to the viewer.
        The viewer code uses this to retrieve additional information.
        The root url will be completed with the `action` and the `viewer`.
    sceneFile: string
        The name of the scene file in the file system.
    viewer: string
        The chosen viewer.
    version: string
        The chosen version of the viewer.
    action: string
        The chosen mode in which the viewer is launched (`read` or `update`).
    subMode: string | None
        The sub mode in which the viewer is to be used (`update` or `create`).

    Returns
    -------
    string
        The HTML for the iframe.
    &#34;&#34;&#34;
    Settings = self.Settings
    H = Settings.H
    debugMode = Settings.debugMode
    viewerUrlBase = Settings.viewerUrlBase
    viewers = self.viewers

    ext = &#34;dev&#34; if debugMode else &#34;min&#34;

    viewerStaticRoot = self.getStaticRoot(viewerUrlBase, action, viewer, version)

    viewerRoot = self.getRoot(urlBase, action, viewer)

    if viewer == &#34;voyager&#34;:
        modes = viewers[viewer].modes
        modeProps = modes[action]
        element = modeProps.element
        fileBase = modeProps.fileBase
        subModes = modeProps.subModes or AttrDict()
        atts = attResolve(subModes[subMode] or AttrDict(), version)
        if subMode != &#34;create&#34;:
            atts[&#34;document&#34;] = sceneFile

        return H.content(
            H.head(
                [
                    H.meta(charset=&#34;utf-8&#34;),
                    H.link(
                        &#34;shortcut icon&#34;,
                        f&#34;{viewerStaticRoot}/favicon.png&#34;,
                        tp=&#34;image/png&#34;,
                    ),
                    H.link(&#34;stylesheet&#34;, f&#34;{viewerStaticRoot}/fonts/fonts.css&#34;),
                    H.link(
                        &#34;stylesheet&#34;, f&#34;{viewerStaticRoot}/css/{fileBase}.{ext}.css&#34;
                    ),
                    H.script(
                        &#34;&#34;,
                        defer=True,
                        src=f&#34;{viewerStaticRoot}/js/{fileBase}.{ext}.js&#34;,
                    ),
                ]
            ),
            H.body(
                H.elem(
                    element,
                    &#34;&#34;,
                    root=viewerRoot,
                    resourceroot=f&#34;{viewerStaticRoot}/&#34;,
                    **atts,
                )
            ),
        )
    else:
        return H.content(
            H.head(H.meta(charset=&#34;utf-8&#34;)),
            H.body(H.p(f&#34;Unsupported viewer: {viewer}&#34;)),
        )</code></pre>
</details>
</dd>
<dt id="control.viewers.Viewers.getFrame"><code class="name flex">
<span>def <span class="ident">getFrame</span></span>(<span>self, edition, actions, viewer, versionActive, actionActive, sceneExists)</span>
</code></dt>
<dd>
<div class="desc"><p>Produces a set of buttons to launch 3D viewers for a scene.</p>
<p>Make sure that if there is no scene file present, no viewer will be opened.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>edition</code></strong> :&ensp;<code>AttrDict</code></dt>
<dd>The edition in question.</dd>
<dt><strong><code>actions</code></strong> :&ensp;<code>iterable</code> of <code>string</code></dt>
<dd>The actions for which we have to create buttons.
Typically <code>read</code> and possibly also <code>update</code>.
Actions that are not recognized as viewer actions
will be filtered out, such as <code>create</code> and <code>delete</code>.</dd>
<dt><strong><code>viewer</code></strong> :&ensp;<code>string</code></dt>
<dd>The viewer in which the scene is currently loaded.</dd>
<dt><strong><code>versionActive</code></strong> :&ensp;<code>string | void</code></dt>
<dd>The version of the viewer in which the scene is currently loaded,
if any, otherwise None</dd>
<dt><strong><code>actionActive</code></strong> :&ensp;<code>string | void</code></dt>
<dd>The mode in which the scene is currently loaded in the viewer
(<code>read</code> or <code>update</code>),
if any, otherwise None</dd>
<dt><strong><code>sceneExists</code></strong> :&ensp;<code>boolean</code></dt>
<dd>Whether the scene file exists.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>string</code></dt>
<dd>The HTML that represents the buttons.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/4bb2a3c091b2869e30f26c6c28942718f16603ee/src/control/viewers.py#L102-L320" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getFrame(
    self, edition, actions, viewer, versionActive, actionActive, sceneExists
):
    &#34;&#34;&#34;Produces a set of buttons to launch 3D viewers for a scene.

    Make sure that if there is no scene file present, no viewer will be opened.

    Parameters
    ----------
    edition: AttrDict
        The edition in question.
    actions: iterable of string
        The actions for which we have to create buttons.
        Typically `read` and possibly also `update`.
        Actions that are not recognized as viewer actions
        will be filtered out, such as `create` and `delete`.
    viewer: string
        The viewer in which the scene is currently loaded.
    versionActive: string | void
        The version of the viewer in which the scene is currently loaded,
        if any, otherwise None
    actionActive: string | void
        The mode in which the scene is currently loaded in the viewer
        (`read` or `update`),
        if any, otherwise None
    sceneExists: boolean
        Whether the scene file exists.

    Returns
    -------
    string
        The HTML that represents the buttons.
    &#34;&#34;&#34;
    Settings = self.Settings
    H = Settings.H
    actionInfo = self.viewerActions
    viewers = self.viewers

    filteredActions = {a for a in actions if a in actionInfo and a != &#34;create&#34;}
    versionActive = self.check(viewer, versionActive)

    editionId = edition._id
    if editionId is None:
        return (&#34;&#34;, &#34;&#34;)

    create = &#34;/update&#34; if sceneExists else &#34;/create&#34;

    src = f&#34;/viewer/{versionActive}/{actionActive}/{editionId}{create}&#34;
    frame = H.div(
        H.div(H.iframe(src, cls=&#34;previewer&#34;), cls=&#34;surround&#34;), cls=&#34;model&#34;
    )

    def getViewerButtons(vw):
        &#34;&#34;&#34;Internal function.

        Returns
        -------
        string
            HTML for the buttons to launch a viewer.
        &#34;&#34;&#34;
        openAtt = vw == viewer

        versions = viewers[vw].versions
        if len(versions) == 1:
            version = versions[0]
            return H.table(
                [
                    getVersionButtons(
                        version,
                        version == versionActive,
                        versionAmount=len(versions),
                        withViewer=True,
                        withVersion=True,
                        # withViewer=not pilotMode,
                        # withVersion=not pilotMode,
                    )
                ],
                [],
                cls=&#34;vwv&#34;,
            )

        (latest, previous) = (versions[0:1], versions[1:])

        openAtt = vw == viewer and len(previous) and versionActive in previous

        return H.details(
            H.table(
                [
                    getVersionButtons(
                        version,
                        version == versionActive,
                        versionAmount=len(versions),
                        withViewer=True,
                    )
                    for version in latest
                ],
                [],
                cls=&#34;vwv&#34;,
            ),
            H.table(
                [],
                [
                    getVersionButtons(
                        version, version == versionActive, withViewer=False
                    )
                    for version in previous
                ],
                cls=&#34;vwv&#34;,
            ),
            f&#34;vwbuttons-{editionId}&#34;,
            cls=&#34;vw&#34;,
            open=openAtt,
        )

    def getVersionButtons(
        version, active, versionAmount=None, withViewer=False, withVersion=True
    ):
        &#34;&#34;&#34;Internal function.

        Parameters
        ----------
        version: string
            The version of the viewer.
        active: boolean
            Whether that version of that viewer is currently active.
        versionAmount: int, optional None
            If passed, contains the number of versions and displays it.
        withViewer: boolean, optional False
            Whether to show the viewer name in the first column.
        withVersion: boolean, optional True
            Whether to show the version in the second column.

        Returns
        -------
        string
            HTML for the buttons to launch a specific version of a viewer.
        &#34;&#34;&#34;
        activeRowCls = &#34;activer&#34; if active else &#34;&#34;

        plural = &#34;&#34; if versionAmount == 2 else &#34;s&#34;
        title = (
            f&#34;click to show previous {versionAmount - 1} {viewer} version{plural}&#34;
            if versionAmount and versionAmount &gt; 1
            else f&#34;no previous {viewer} versions&#34;
        )

        return (
            [
                (viewer if withViewer else H.nbsp, dict(cls=&#34;vwc&#34;, title=title)),
                (
                    version if withVersion else H.nbsp,
                    dict(cls=&#34;vvl vwc&#34;, title=title),
                ),
            ]
            + [
                getActionButton(
                    version, action, disabled=active and action == actionActive
                )
                for action in sorted(filteredActions)
            ],
            dict(cls=activeRowCls),
        )

    def getActionButton(version, action, disabled=False):
        &#34;&#34;&#34;Internal function.

        Parameters
        ----------
        version: string
            The version of the viewer.
        action: string
            Whether to launch the viewer for `read` or for `update`.
        disabled: boolean, optional Fasle
            Whether to show the button as disabled

        Returns
        -------
        string
            HTML for the buttons to launch a specific version of a viewer
            for a specific action.
        &#34;&#34;&#34;
        atts = {}

        href = None if disabled else f&#34;/edition/{editionId}/{version}/{action}&#34;

        if action == &#34;update&#34;:
            viewerHref = f&#34;/viewer/{version}/{action}/{editionId}{create}&#34;
            atts[&#34;onclick&#34;] = dedent(
                f&#34;&#34;&#34;
                window.open(
                    &#39;{viewerHref}&#39;,
                    &#39;newwindow&#39;,
                    width=window.innerWidth,
                    height=window.innerHeight
                );
                return false;
                &#34;&#34;&#34;
            )

        titleFragment = &#34;a new window&#34; if action == &#34;update&#34; else &#34;place&#34;

        createMode = action == &#34;update&#34; and not sceneExists
        action = &#34;create&#34; if createMode else action
        thisActionInfo = actionInfo.get(action, AttrDict())
        name = thisActionInfo.name
        atts[&#34;title&#34;] = f&#34;{name} scene in {titleFragment}&#34;

        disabledCls = &#34;disabled&#34; if disabled else &#34;&#34;
        activeCellCls = &#34;activec&#34; if disabled else &#34;&#34;
        cls = f&#34;button vwb {disabledCls}&#34;

        return (
            H.iconx(action, text=name, href=href, cls=cls, **atts),
            dict(cls=f&#34;vwc {activeCellCls}&#34;),
        )

    allButtons = H.div([getViewerButtons(vw) for vw in viewers])

    return (frame if sceneExists else &#34;&#34;, allButtons)</code></pre>
</details>
</dd>
<dt id="control.viewers.Viewers.getRoot"><code class="name flex">
<span>def <span class="ident">getRoot</span></span>(<span>self, urlBase, action, viewer)</span>
</code></dt>
<dd>
<div class="desc"><p>Composes the root url for a viewer.</p>
<p>The root url is passed to a viewer instance as the url that
the viewer can use to fetch its data.
It is not meant for the static data that is part of the viewer software,
but for the model related data that the viewer is going to display.</p>
<p>See <code>getStaticRoot()</code> for the url meant for getting parts of the
viewer software.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>urlBase</code></strong> :&ensp;<code>string</code></dt>
<dd>The first part of the root url, depending
on the project and edition.</dd>
<dt><strong><code>action</code></strong> :&ensp;<code>string</code></dt>
<dd>
<p>The mode in which the viewer is opened.
Depending on the mode, the viewer code may communicate with the server
with different urls.
For example, for the voyager,
the <code>read</code> mode (voyager-explorer) uses ordinary HTTP requests,
but the <code>update</code> mode (voyager-story) uses WebDAV requests.</p>
<p>So this app points voyager-explorer to a root url starting with <code>/data</code>,
and voyager-story to a root url starting with <code>/webdav</code>.</p>
<p>These prefixes of the urls can be configured per viewer
in the viewer configuration in <code>yaml/viewers.yml</code>.</p>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/4bb2a3c091b2869e30f26c6c28942718f16603ee/src/control/viewers.py#L408-L448" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getRoot(self, urlBase, action, viewer):
    &#34;&#34;&#34;Composes the root url for a viewer.

    The root url is passed to a viewer instance as the url that
    the viewer can use to fetch its data.
    It is not meant for the static data that is part of the viewer software,
    but for the model related data that the viewer is going to display.

    See `getStaticRoot()` for the url meant for getting parts of the
    viewer software.

    Parameters
    ----------
    urlBase: string
        The first part of the root url, depending
        on the project and edition.
    action: string
        The mode in which the viewer is opened.
        Depending on the mode, the viewer code may communicate with the server
        with different urls.
        For example, for the voyager,
        the `read` mode (voyager-explorer) uses ordinary HTTP requests,
        but the `update` mode (voyager-story) uses WebDAV requests.

        So this app points voyager-explorer to a root url starting with `/data`,
        and voyager-story to a root url starting with `/webdav`.

        These prefixes of the urls can be configured per viewer
        in the viewer configuration in `yaml/viewers.yml`.
    &#34;&#34;&#34;
    viewers = self.viewers

    if viewer not in viewers:
        return None

    modes = viewers[viewer].modes

    thisMode = modes[action] or modes.read
    prefix = thisMode.prefix

    return f&#34;{prefix}/{urlBase}&#34;</code></pre>
</details>
</dd>
<dt id="control.viewers.Viewers.getStaticRoot"><code class="name flex">
<span>def <span class="ident">getStaticRoot</span></span>(<span>self, viewerUrlBase, action, viewer, version)</span>
</code></dt>
<dd>
<div class="desc"><p>Composes the static root url for a viewer.</p>
<p>The static root url is passed to a viewer instance as the url that the
viewer can use to fetch its assets.
It is not meant for the model related data, but for the parts of the
viewer software that it needs to get from the server.</p>
<p>See <code>getRoot()</code> for the url meant for getting model-related data.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>urlBase</code></strong> :&ensp;<code>string</code></dt>
<dd>The first part of the root url, depending
on the project and edition.</dd>
<dt><strong><code>action</code></strong> :&ensp;<code>string</code></dt>
<dd>
<p>The mode in which the viewer is opened.
Depending on the mode, the viewer code may communicate with the server
with different urls.
For example, for the voyager,
the <code>read</code> mode (voyager-explorer) uses ordinary HTTP requests,
but the <code>update</code> mode (voyager-story) uses WebDAV requests.</p>
<p>So this app points voyager-explorer to a root url starting with <code>/data</code>,
and voyager-story to a root url starting with <code>/webdav</code>.</p>
<p>These prefixes of the urls can be configured per viewer
in the viewer configuration in <code>yaml/viewers.yml</code>.</p>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/4bb2a3c091b2869e30f26c6c28942718f16603ee/src/control/viewers.py#L450-L482" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getStaticRoot(self, viewerUrlBase, action, viewer, version):
    &#34;&#34;&#34;Composes the static root url for a viewer.

    The static root url is passed to a viewer instance as the url that the
    viewer can use to fetch its assets.
    It is not meant for the model related data, but for the parts of the
    viewer software that it needs to get from the server.

    See `getRoot()` for the url meant for getting model-related data.

    Parameters
    ----------
    urlBase: string
        The first part of the root url, depending
        on the project and edition.
    action: string
        The mode in which the viewer is opened.
        Depending on the mode, the viewer code may communicate with the server
        with different urls.
        For example, for the voyager,
        the `read` mode (voyager-explorer) uses ordinary HTTP requests,
        but the `update` mode (voyager-story) uses WebDAV requests.

        So this app points voyager-explorer to a root url starting with `/data`,
        and voyager-story to a root url starting with `/webdav`.

        These prefixes of the urls can be configured per viewer
        in the viewer configuration in `yaml/viewers.yml`.
    &#34;&#34;&#34;
    if not self.check(viewer, version):
        return None

    return f&#34;{viewerUrlBase}/{viewer}/{version}&#34;</code></pre>
</details>
</dd>
<dt id="control.viewers.Viewers.getViewInfo"><code class="name flex">
<span>def <span class="ident">getViewInfo</span></span>(<span>self, edition)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets viewer-related info that an edition is made with.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>edition</code></strong> :&ensp;<code>AttrDict</code></dt>
<dd>The edition record.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code> of <code>string</code></dt>
<dd>
<ul>
<li>The name of the viewer</li>
<li>The name of the scene</li>
</ul>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/4bb2a3c091b2869e30f26c6c28942718f16603ee/src/control/viewers.py#L74-L100" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getViewInfo(self, edition):
    &#34;&#34;&#34;Gets viewer-related info that an edition is made with.

    Parameters
    ----------
    edition: AttrDict
        The edition record.

    Returns
    -------
    tuple of string
        * The name of the viewer
        * The name of the scene

    &#34;&#34;&#34;
    viewerDefault = self.viewerDefault

    editionId = edition._id
    if editionId is None:
        return (viewerDefault, None)

    editionSettings = edition.settings or AttrDict()
    authorTool = editionSettings.authorTool or AttrDict()
    viewer = authorTool.name or viewerDefault
    sceneFile = authorTool.sceneFile

    return (viewer, sceneFile)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<p><a href="https://github.com/CLARIAH/pure3dx" title="GitHub repo">GitHub</a></p>
<p><a href="https://github.com/CLARIAH/pure3dx/blob/main/stats.md" title="GitHub repo">code stats</a></p>
<form>
<input id="lunr-search" name="q" placeholder="🔎 Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="control" href="index.html">control</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="control.viewers.Viewers" href="#control.viewers.Viewers">Viewers</a></code></h4>
<ul class="two-column">
<li><code><a title="control.viewers.Viewers.addAuth" href="#control.viewers.Viewers.addAuth">addAuth</a></code></li>
<li><code><a title="control.viewers.Viewers.check" href="#control.viewers.Viewers.check">check</a></code></li>
<li><code><a title="control.viewers.Viewers.genHtml" href="#control.viewers.Viewers.genHtml">genHtml</a></code></li>
<li><code><a title="control.viewers.Viewers.getFrame" href="#control.viewers.Viewers.getFrame">getFrame</a></code></li>
<li><code><a title="control.viewers.Viewers.getRoot" href="#control.viewers.Viewers.getRoot">getRoot</a></code></li>
<li><code><a title="control.viewers.Viewers.getStaticRoot" href="#control.viewers.Viewers.getStaticRoot">getStaticRoot</a></code></li>
<li><code><a title="control.viewers.Viewers.getViewInfo" href="#control.viewers.Viewers.getViewInfo">getViewInfo</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<a href="https://pure.knaw.nl/portal/en/persons/dirk-roorda">Dirk Roorda</a>
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>