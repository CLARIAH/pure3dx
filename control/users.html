<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>control.users API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>control.users</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/1a4455072b1ffa872b86f15d4e31826810cd1f2e/src/control/users.py#L1-L673" class="git-link">Browse git</a>
</summary>
<pre><code class="python">from control.generic import AttrDict
from control.flask import (
    acg,
    requestArg,
    sessionPop,
    sessionGet,
    sessionSet,
    getReferrer,
    redirectStatus,
)


PROVIDER_ATTS = {
    x: x
    for x in &#34;&#34;&#34;
    sub
    email
    nickname
&#34;&#34;&#34;.strip().split()
}
PROVIDER_ATTS[&#34;sub&#34;] = &#34;user&#34;


class Users:
    def __init__(self, Settings, Messages, Mongo):
        &#34;&#34;&#34;All about users and the current user.

        This class has methods to login/logout a user,
        to retrieve the data of the currently logged in user,
        and to query the users table in MongoDb.

        It is instantiated by a singleton object.

        !!! note &#34;User details are not stored here&#34;
            The user details are not stored as members of this object, since
            this object has been made before the flask app was initialized,
            hence the object is global in the sefver process, meaning that all
            workers can see its data.

            Instead, the user details are stored in a so-called *global* in an
            [Application Context](https://flask.palletsprojects.com/en/2.2.x/appcontext/),
            where it is visible and modifiable by the current request only.

        Parameters
        ----------
        Settings: AttrDict
            App-wide configuration data obtained from
            `control.config.Config.Settings`.
        Messages: object
            Singleton instance of `control.messages.Messages`.
        Mongo: object
            Singleton instance of `control.mongo.Mongo`.
        &#34;&#34;&#34;
        self.Settings = Settings
        self.Messages = Messages
        Messages.debugAdd(self)
        self.Mongo = Mongo

        self.oidc = None
        &#34;&#34;&#34;The object that gives access to authentication methods.
        &#34;&#34;&#34;

    @staticmethod
    def initUser():
        &#34;&#34;&#34;Initialize the storage that keeps the details of the currently
        logged-in user.

        It will put an empty AttrDict as *global* in the current application context.

        As long as there is no current user, this AttrDict will remain empty.
        If there is a current user, or a user logs in, it will get a member
        `user`, which is the *sub* as it comes from the OIDC authenticator or from
        a special login procedure.

        It may then also have additional members, such as `name` and `role`.
        &#34;&#34;&#34;
        acg.User = AttrDict()

    def addAuthenticator(self, oidc):
        &#34;&#34;&#34;Adds the object that gives access to authentication methods.

        Parameters
        ----------
        oidc: object
            The object corresponding to the flask app prepared with the
            Flask-OIDC authenticator.

        Returns
        -------
        void
            The object is stored in the `oidc` member.
        &#34;&#34;&#34;
        self.oidc = oidc

    def login(self):
        &#34;&#34;&#34;Log in a user.

        Logging in has several main steps:

        1. redirecting to a private page, for which login is required
        2. obtaining the authentication results when the user visits that page
        3. storing the relevant user data

        When we log in test/pilot users, we can skip the first step, because
        we already know everything about the test/pilot user on the basis of the
        information in the request that brought us here.

        So, we find out if we have to log in a test/pilot user or a user that must be
        authenticated through oidc.

        We only log in a test/pilot user if we are in test/pilot mode and the user&#39;s &#34;sub&#34;
        is passed in the request.

        Returns
        -------
        response
            A redirect. When logging in in test/pilot mode, the redirect
            is to *referrer* (the url we came from). Otherwise it is to a url
            that triggers an oidc login procedure. To that page we pass
            the referrer as part of the url, so that after login the user
            can be redirected to the original referrer.
        &#34;&#34;&#34;
        Messages = self.Messages
        Settings = self.Settings
        runProd = Settings.runProd

        referrer = getReferrer()
        (isSpecialUser, user) = self.getUser(fromArg=True)
        name = acg.User.nickname

        if user and not isSpecialUser and not runProd:
            Messages.warning(
                logmsg=(
                    &#34;LOGIN attempt while an user is already logged in: &#34;
                    f&#34;user {name} {user}&#34;
                ),
                msg=f&#34;first log out as user {name}&#34;,
            )
            return redirectStatus(f&#34;/{referrer}&#34;, False)

        return (
            self.__loginSpecial(referrer, requestArg(&#34;user&#34;))
            if isSpecialUser
            else self.__loginOidc(referrer)
        )

    def afterLogin(self, referrer):
        &#34;&#34;&#34;Logs in a user.

        When this function starts operating, the user has been through the login
        process provided by the authentication service.

        We can now find the user&#39;s &#34;sub&#34; and additional attributes in the request
        context.

        We use that information to lookup the user in the MongoDb users table.
        If the user does not exists, we add a new user record, with this &#34;sub&#34; and
        these attributes, and role `user`.

        If the user does exists, we check whether we have to update his attributes.
        If the attributes found in MongoDb differ from those supplied by the
        authentication service, we update the MongoDb values on the basis
        of the provider values.

        Parameters
        ----------
        referrer: string
            url where we came from.

        Returns
        -------
        response
            A redirect to the referrer, with a status 302 if the log in was
            successful or 303 if not.
        &#34;&#34;&#34;
        Messages = self.Messages
        oidc = self.oidc

        user = None
        referrer = referrer.removeprefix(&#34;/&#34;)

        if oidc.user_loggedin:
            user = oidc.user_getfield(&#34;sub&#34;)
            name = oidc.user_getfield(&#34;nickname&#34;)

        if user is None or not self.__findUser(user, update=True):
            Messages.warning(
                logmsg=f&#34;LOGIN failed for user {user}&#34;,
                msg=&#34;failed to log in&#34;,
            )
            return redirectStatus(f&#34;/{referrer}&#34;, False)

        name = acg.User.nickname
        Messages.plain(
            logmsg=f&#34;LOGIN successful: user {name} {user}&#34;,
            msg=f&#34;LOGIN successful: user {name}&#34;,
        )
        return redirectStatus(f&#34;/{referrer}&#34;, True)

    def logout(self):
        &#34;&#34;&#34;Logs off the current user.

        First we find out whether we have to log out a test/pilot user or a normal
        user.
        After logging out, we redirect to the home page.

        Returns
        -------
        response
            A redirect to the home page.
        &#34;&#34;&#34;
        oidc = self.oidc
        Settings = self.Settings
        Messages = self.Messages
        name = acg.User.nickname
        runProd = Settings.runProd

        (isSpecialUser, user) = self.getUser()

        if user is None:
            if not runProd:
                sessionPop(&#34;user&#34;)
            else:
                oidc.logout()
            acg.User.clear()
            Messages.plain(logmsg=&#34;LOGOUT but no user was logged in.&#34;)
            return redirectStatus(&#34;/&#34;, False)

        if isSpecialUser:
            sessionPop(&#34;user&#34;)
        else:
            oidc.logout()

        acg.User.clear()
        Messages.plain(
            logmsg=f&#34;LOGOUT successful: user {name} {user}&#34;,
            msg=f&#34;{name} logged out&#34;,
        )
        return redirectStatus(&#34;/&#34;, True)

    def identify(self):
        &#34;&#34;&#34;Make sure who is the current user.

        Checks whether there is a current user and whether that user is fully known,
        i.e. in the users table of the mongoDb.

        If there is a current user that is unknown to the database, the current user
        will be cleared.

        Otherwise, we make sure that we retrieve the current user&#39;s attributes from
        the database.

        !!! note &#34;No login&#34;
            We do not try to perform a login of a user,
            we only check who is the currently logged in user.

            A login must be explicitly triggered by the the `/login` url.
        &#34;&#34;&#34;
        oidc = self.oidc

        (isSpecialUser, user) = self.getUser()

        if user is not None:
            if isSpecialUser:
                if not self.__findSpecialUser(user):
                    acg.User.clear()
                    sessionPop(&#34;user&#34;)
            else:
                if not self.__findUser(user, update=False):
                    acg.User.clear()
                    oidc.logout()

    def myDetails(self):
        &#34;&#34;&#34;Who is the currently authenticated user?

        The appplication-context-global `User` is inspected:
        does it contain a member called `user`?
        If so, that is taken as proof that we have a valid user.

        Returns
        -------
        dict
            Otherwise a copy of the complete `User` record is returned.
            unless there is no `user` member in the current user, then
            the empty dictionary is returned.
        &#34;&#34;&#34;
        User = acg.User
        return AttrDict(**User) if &#34;user&#34; in User else AttrDict({})

    def getUser(self, fromArg=False):
        &#34;&#34;&#34;Obtain the &#34;sub&#34; of the currently logged in user from the request info.

        It works for test/pilot users and normal users.

        Parameters
        ----------
        fromArg: boolean, optional False
            If True, the test/pilot user is not read from the session, but from a
            request argument.
            This is used during the login procedure of test/pilot users.

        Returns
        -------
        boolean, string
            *   Whether the user is a test/pilot user or a normally authenticated user.
                None if there is no authenticated user.
            *   The &#34;sub&#34; of the user.
        &#34;&#34;&#34;
        oidc = self.oidc
        Settings = self.Settings
        runProd = Settings.runProd

        user = None
        isSpecialUser = None

        if not runProd:
            user = requestArg(&#34;user&#34;) if fromArg else sessionGet(&#34;user&#34;)
            if user:
                isSpecialUser = True

        if user is None:
            user = oidc.user_getfield(&#34;sub&#34;) if oidc.user_loggedin else None
            if user:
                isSpecialUser = False

        return (isSpecialUser, user)

    def wrapLogin(self):
        &#34;&#34;&#34;Generate HTML for the login widget.

        De task is to generate login/logout buttons.

        If the user is logged in, his nickname should be displayed, together
        with a logout button.

        If no user is logged in, a login button should be displayed.

        If in test/pilot mode, a list of buttons for each test/pilot user should be
        displayed.

        Returns
        -------
        string
            HTML of the list of buttons for test/pilot users, with the button
            for the current user styled as active.
        &#34;&#34;&#34;
        Settings = self.Settings
        H = Settings.H
        runMode = Settings.runMode
        runProd = Settings.runProd
        Mongo = self.Mongo

        (isSpecialUser, userActive) = self.getUser()

        specialContent = []
        content = []

        def wrap(label, text, title, href, active, enabled):
            &#34;&#34;&#34;Inner function to be called recursively.&#34;&#34;&#34;
            if label:
                content.append(H.span(label, cls=&#34;label&#34;))

            if active:
                cls = &#34;active&#34;
                elem = &#34;span&#34;
                href = []
            else:
                cls = &#34;&#34;
                elem = &#34;a&#34;
                href = [href]

            if not enabled:
                cls = &#34;disabled&#34;
                elem = &#34;span&#34;
                href = []

            fullCls = f&#34;button small {cls}&#34;

            return H.elem(elem, text, *href, cls=fullCls, title=title)

        if not runProd:
            # row of test/pilot users

            enabled = not userActive or isSpecialUser

            for record in sorted(
                Mongo.getList(&#34;user&#34;, sort=&#34;nickname&#34;, isSpecial=True),
                key=lambda r: r.nickname,
            ):
                user = record.user
                name = record.nickname
                role = self.presentRole(record.role)

                active = user == userActive
                specialContent.append(
                    wrap(None, name, role, f&#34;/alogin?user={user}&#34;, active, enabled)
                )

        if userActive:
            # details of logged in user

            details = self.myDetails()
            name = details.nickname
            email = details.email
            userRep = f&#34;{name} - {email}&#34; if email else name
            role = self.presentRole(details.role)
            content.append(wrap(&#34;Logged in as&#34;, userRep, role, None, True, True))

            # logout button
            content.append(
                wrap(None, &#34;log out&#34;, f&#34;log out {name}&#34;, &#34;/alogout&#34;, False, True)
            )

        else:
            # login button
            if runMode != &#34;custom&#34;:
                content.append(wrap(None, &#34;log in&#34;, &#34;log in&#34;, &#34;/alogin&#34;, False, True))

        return (H.content(*specialContent), H.content(*content))

    def presentRole(self, role):
        &#34;&#34;&#34;Finds the interface representation of a role.

        Parameters
        ----------
        role: string
            The internal name of the role.

        Returns
        -------
        string
            The name of the role as it should be presented to users.
            If no representation can be found, the internal name is returned.
        &#34;&#34;&#34;
        Settings = self.Settings
        roles = Settings.auth.roles
        return roles.get(role, role)

    def getInvolvedUsers(self, tableRecordRoles, asString=False):
        &#34;&#34;&#34;Finds the users involved in a specific role with respect to something.

        By this method you can find the organisers of a project, the editors of
        an edition, the admins of the site, etc.

        Parameters
        ----------
        table: string
            Either `site`, `project` or `edition`.
            This indicates the kind of thing that the users are related to.
        tableRecordRoles: tuple
            The tuple consists of tuples `(table, record, role)`
            The users connected to that record in that table in that role
            should be added to the list.
            All roles are specified in the `yaml/authorise.yml` file.

        Returns
        -------
        tuple or string
            If `asString` is False, the result is a datastructure:

            *   whether the information can be disclosed to the current users
            *   the representation of that role on the interface.
            *   a tuple:

                Each item is a tuple, corresponding to a user.
                For each user there are the follwoing fields:

                *   user field in the user table
                *   full name
                *   table of the record to which the user is linked
                *   role in which the user is linked to that record

            If `asString` is True, this data structure will be wrapped in HTML.
        &#34;&#34;&#34;
        Mongo = self.Mongo
        Settings = self.Settings
        H = Settings.H
        auth = Settings.auth

        involvedUsers = []

        for table, record, role in tableRecordRoles:
            roles = auth.roles[table]
            allowed = self.authorise(table, record, action=&#34;read&#34;)
            users = None

            if allowed and roles is not None and roles.get(role, None) is not None:
                userInfo = Mongo.getList(&#34;user&#34;, sort=&#34;nickname&#34;, asDict=&#34;user&#34;)

                if table == &#34;site&#34;:
                    relatedUsers = [
                        uInfo for uInfo in userInfo.values() if uInfo.role == role
                    ]
                else:
                    criteria = {f&#34;{table}Id&#34;: record._id, &#34;role&#34;: role}
                    relatedUserList = Mongo.getList(f&#34;{table}User&#34;, **criteria)
                    relatedUsers = sorted(
                        (userInfo[r.user] for r in relatedUserList),
                        key=lambda x: x.nickname,
                    )
                users = tuple((u.user, u.nickname) for u in relatedUsers)

                involvedUsers.append((table, role, users))

        if not asString:
            return tuple(involvedUsers)

        html = []

        seenUsers = set()

        for table, role, users in sorted(involvedUsers, key=lambda x: -len(x[2])):
            if len(users) == 0:
                continue

            userIds = {u[0] for u in users}

            if len(userIds - seenUsers) == 0:
                continue

            seenUsers |= userIds

            roles = auth.roles[table]
            roleRep = roles[role]

            label = H.i(f&#34;{table} {roleRep}&#34;)
            userRep = &#34; or &#34;.join(H.span(name, uid=u) for (u, name) in users)
            html.append(f&#34;{userRep}{H.nbsp}({label})&#34;)

        return f&#34;ask: {&#39;; &#39;.join(html)}&#34;

    def __loginSpecial(self, referrer, user):
        &#34;&#34;&#34;Perform the steps to log in a test/pilot/custom user.

        This involves looking up the user in the user table,
        copying its information in the application-context-global `User`,
        and storing the user in the session. After that the user is redirected
        to where he came from.

        Parameters
        ----------
        referrer: string
            url where we came from.
        user: string
            The &#34;sub&#34; of the test/pilot user that we must log in as.

        Returns
        -------
        response
            A redirect to the referrer, with a status 302 if the log in was
            successful or 303 if not.
        &#34;&#34;&#34;
        Messages = self.Messages
        Settings = self.Settings
        runMode = Settings.runMode

        if user is None or not self.__findSpecialUser(user):
            return redirectStatus(f&#34;/{referrer}&#34;, False)

        sessionSet(&#34;user&#34;, user)
        name = acg.User.nickname
        Messages.plain(
            logmsg=f&#34;LOGIN successful: {runMode} user {name} {user}&#34;,
            msg=f&#34;LOGIN successful: {runMode} user {name}&#34;,
        )
        return redirectStatus(f&#34;/{referrer}&#34;, True)

    def __loginOidc(self, referrer):
        &#34;&#34;&#34;Redirect step in logging in normal user.

        This means redirecting the user to a url for which authentication
        is required.

        Parameters
        ----------
        referrer: string
            url where we came from. We pass this to the private url.

        Returns
        -------
        response
            A redirect to the referrer, with a status 302 if the log in was
            successful or 303 if not.
        &#34;&#34;&#34;
        return redirectStatus(f&#34;/afterlogin/referrer/{referrer}&#34;, True)

    def __findSpecialUser(self, user):
        &#34;&#34;&#34;Lookup data of a test/pilot user in the MongoDb user table.

        The user is looked up by the `user` field.

        Parameters
        ----------
        user: string
            The `user` of by which a user is looked up, if not None.

        Returns
        -------
        boolean
            Whether a user has been found/created.
            If so, the data of that user record is stored in the
            application-context-global `User`.
        &#34;&#34;&#34;
        Messages = self.Messages
        Mongo = self.Mongo
        User = acg.User

        record = Mongo.getRecord(&#34;user&#34;, user=user)

        if not record:
            Messages.warning(msg=&#34;Unknown user&#34;, logmsg=f&#34;Unknown user {user}&#34;)
            return False

        User.clear()
        for att in PROVIDER_ATTS.values():
            User[att] = record[att]
        User.role = record.role

        return True

    def __findUser(self, user, update=False):
        &#34;&#34;&#34;Lookup user data in the MongoDb user table.

        The user is looked up by the `user` field.
        Optionally, the user record in MongoDb is updated with attributes from
        the identity provider.

        Parameters
        ----------
        user: string
            The `user` of by which a user is looked up, if not None.
        update: boolean, optional False
            Whether to update the user record with fresh attributes of the
            identity provider.

        Returns
        -------
        boolean
            Whether a user has been found/created.
            If so, the data of that user record is stored in the
            application-context-global `User`.
        &#34;&#34;&#34;
        Mongo = self.Mongo
        oidc = self.oidc
        User = acg.User

        record = Mongo.getRecord(&#34;user&#34;, user=user, warn=False)
        newUser = None

        if not record:
            newUser = {
                att: oidc.user_getfield(oidcAtt)
                for (oidcAtt, att) in PROVIDER_ATTS.items()
            }
            userId = Mongo.insertRecord(&#34;user&#34;, role=&#34;user&#34;, **newUser)
            record = Mongo.getRecord(&#34;user&#34;, _id=userId)

        User.clear()
        for att in PROVIDER_ATTS.values():
            User[att] = record[att]
        User.role = record.role

        if update and not newUser:
            changes = {}
            for oidcAtt, att in PROVIDER_ATTS.items():
                orig = User[att]
                new = oidc.user_getfield(oidcAtt)
                if new is not None and orig != new:
                    changes[att] = new
                    User[att] = new
            if changes:
                Mongo.updateRecord(&#34;user&#34;, changes, user=User.user)
        return True</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="control.users.Users"><code class="flex name class">
<span>class <span class="ident">Users</span></span>
<span>(</span><span>Settings, Messages, Mongo)</span>
</code></dt>
<dd>
<div class="desc"><p>All about users and the current user.</p>
<p>This class has methods to login/logout a user,
to retrieve the data of the currently logged in user,
and to query the users table in MongoDb.</p>
<p>It is instantiated by a singleton object.</p>
<div class="admonition note">
<p class="admonition-title">User details are not stored here</p>
<p>The user details are not stored as members of this object, since
this object has been made before the flask app was initialized,
hence the object is global in the sefver process, meaning that all
workers can see its data.</p>
<p>Instead, the user details are stored in a so-called <em>global</em> in an
<a href="https://flask.palletsprojects.com/en/2.2.x/appcontext/">Application Context</a>,
where it is visible and modifiable by the current request only.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>Settings</code></strong> :&ensp;<code>AttrDict</code></dt>
<dd>App-wide configuration data obtained from
<code><a title="control.config.Config.Settings" href="config.html#control.config.Config.Settings">Config.Settings</a></code>.</dd>
<dt><strong><code>Messages</code></strong> :&ensp;<code>object</code></dt>
<dd>Singleton instance of <code><a title="control.messages.Messages" href="messages.html#control.messages.Messages">Messages</a></code>.</dd>
<dt><strong><code>Mongo</code></strong> :&ensp;<code>object</code></dt>
<dd>Singleton instance of <code><a title="control.mongo.Mongo" href="mongo.html#control.mongo.Mongo">Mongo</a></code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/1a4455072b1ffa872b86f15d4e31826810cd1f2e/src/control/users.py#L24-L673" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Users:
    def __init__(self, Settings, Messages, Mongo):
        &#34;&#34;&#34;All about users and the current user.

        This class has methods to login/logout a user,
        to retrieve the data of the currently logged in user,
        and to query the users table in MongoDb.

        It is instantiated by a singleton object.

        !!! note &#34;User details are not stored here&#34;
            The user details are not stored as members of this object, since
            this object has been made before the flask app was initialized,
            hence the object is global in the sefver process, meaning that all
            workers can see its data.

            Instead, the user details are stored in a so-called *global* in an
            [Application Context](https://flask.palletsprojects.com/en/2.2.x/appcontext/),
            where it is visible and modifiable by the current request only.

        Parameters
        ----------
        Settings: AttrDict
            App-wide configuration data obtained from
            `control.config.Config.Settings`.
        Messages: object
            Singleton instance of `control.messages.Messages`.
        Mongo: object
            Singleton instance of `control.mongo.Mongo`.
        &#34;&#34;&#34;
        self.Settings = Settings
        self.Messages = Messages
        Messages.debugAdd(self)
        self.Mongo = Mongo

        self.oidc = None
        &#34;&#34;&#34;The object that gives access to authentication methods.
        &#34;&#34;&#34;

    @staticmethod
    def initUser():
        &#34;&#34;&#34;Initialize the storage that keeps the details of the currently
        logged-in user.

        It will put an empty AttrDict as *global* in the current application context.

        As long as there is no current user, this AttrDict will remain empty.
        If there is a current user, or a user logs in, it will get a member
        `user`, which is the *sub* as it comes from the OIDC authenticator or from
        a special login procedure.

        It may then also have additional members, such as `name` and `role`.
        &#34;&#34;&#34;
        acg.User = AttrDict()

    def addAuthenticator(self, oidc):
        &#34;&#34;&#34;Adds the object that gives access to authentication methods.

        Parameters
        ----------
        oidc: object
            The object corresponding to the flask app prepared with the
            Flask-OIDC authenticator.

        Returns
        -------
        void
            The object is stored in the `oidc` member.
        &#34;&#34;&#34;
        self.oidc = oidc

    def login(self):
        &#34;&#34;&#34;Log in a user.

        Logging in has several main steps:

        1. redirecting to a private page, for which login is required
        2. obtaining the authentication results when the user visits that page
        3. storing the relevant user data

        When we log in test/pilot users, we can skip the first step, because
        we already know everything about the test/pilot user on the basis of the
        information in the request that brought us here.

        So, we find out if we have to log in a test/pilot user or a user that must be
        authenticated through oidc.

        We only log in a test/pilot user if we are in test/pilot mode and the user&#39;s &#34;sub&#34;
        is passed in the request.

        Returns
        -------
        response
            A redirect. When logging in in test/pilot mode, the redirect
            is to *referrer* (the url we came from). Otherwise it is to a url
            that triggers an oidc login procedure. To that page we pass
            the referrer as part of the url, so that after login the user
            can be redirected to the original referrer.
        &#34;&#34;&#34;
        Messages = self.Messages
        Settings = self.Settings
        runProd = Settings.runProd

        referrer = getReferrer()
        (isSpecialUser, user) = self.getUser(fromArg=True)
        name = acg.User.nickname

        if user and not isSpecialUser and not runProd:
            Messages.warning(
                logmsg=(
                    &#34;LOGIN attempt while an user is already logged in: &#34;
                    f&#34;user {name} {user}&#34;
                ),
                msg=f&#34;first log out as user {name}&#34;,
            )
            return redirectStatus(f&#34;/{referrer}&#34;, False)

        return (
            self.__loginSpecial(referrer, requestArg(&#34;user&#34;))
            if isSpecialUser
            else self.__loginOidc(referrer)
        )

    def afterLogin(self, referrer):
        &#34;&#34;&#34;Logs in a user.

        When this function starts operating, the user has been through the login
        process provided by the authentication service.

        We can now find the user&#39;s &#34;sub&#34; and additional attributes in the request
        context.

        We use that information to lookup the user in the MongoDb users table.
        If the user does not exists, we add a new user record, with this &#34;sub&#34; and
        these attributes, and role `user`.

        If the user does exists, we check whether we have to update his attributes.
        If the attributes found in MongoDb differ from those supplied by the
        authentication service, we update the MongoDb values on the basis
        of the provider values.

        Parameters
        ----------
        referrer: string
            url where we came from.

        Returns
        -------
        response
            A redirect to the referrer, with a status 302 if the log in was
            successful or 303 if not.
        &#34;&#34;&#34;
        Messages = self.Messages
        oidc = self.oidc

        user = None
        referrer = referrer.removeprefix(&#34;/&#34;)

        if oidc.user_loggedin:
            user = oidc.user_getfield(&#34;sub&#34;)
            name = oidc.user_getfield(&#34;nickname&#34;)

        if user is None or not self.__findUser(user, update=True):
            Messages.warning(
                logmsg=f&#34;LOGIN failed for user {user}&#34;,
                msg=&#34;failed to log in&#34;,
            )
            return redirectStatus(f&#34;/{referrer}&#34;, False)

        name = acg.User.nickname
        Messages.plain(
            logmsg=f&#34;LOGIN successful: user {name} {user}&#34;,
            msg=f&#34;LOGIN successful: user {name}&#34;,
        )
        return redirectStatus(f&#34;/{referrer}&#34;, True)

    def logout(self):
        &#34;&#34;&#34;Logs off the current user.

        First we find out whether we have to log out a test/pilot user or a normal
        user.
        After logging out, we redirect to the home page.

        Returns
        -------
        response
            A redirect to the home page.
        &#34;&#34;&#34;
        oidc = self.oidc
        Settings = self.Settings
        Messages = self.Messages
        name = acg.User.nickname
        runProd = Settings.runProd

        (isSpecialUser, user) = self.getUser()

        if user is None:
            if not runProd:
                sessionPop(&#34;user&#34;)
            else:
                oidc.logout()
            acg.User.clear()
            Messages.plain(logmsg=&#34;LOGOUT but no user was logged in.&#34;)
            return redirectStatus(&#34;/&#34;, False)

        if isSpecialUser:
            sessionPop(&#34;user&#34;)
        else:
            oidc.logout()

        acg.User.clear()
        Messages.plain(
            logmsg=f&#34;LOGOUT successful: user {name} {user}&#34;,
            msg=f&#34;{name} logged out&#34;,
        )
        return redirectStatus(&#34;/&#34;, True)

    def identify(self):
        &#34;&#34;&#34;Make sure who is the current user.

        Checks whether there is a current user and whether that user is fully known,
        i.e. in the users table of the mongoDb.

        If there is a current user that is unknown to the database, the current user
        will be cleared.

        Otherwise, we make sure that we retrieve the current user&#39;s attributes from
        the database.

        !!! note &#34;No login&#34;
            We do not try to perform a login of a user,
            we only check who is the currently logged in user.

            A login must be explicitly triggered by the the `/login` url.
        &#34;&#34;&#34;
        oidc = self.oidc

        (isSpecialUser, user) = self.getUser()

        if user is not None:
            if isSpecialUser:
                if not self.__findSpecialUser(user):
                    acg.User.clear()
                    sessionPop(&#34;user&#34;)
            else:
                if not self.__findUser(user, update=False):
                    acg.User.clear()
                    oidc.logout()

    def myDetails(self):
        &#34;&#34;&#34;Who is the currently authenticated user?

        The appplication-context-global `User` is inspected:
        does it contain a member called `user`?
        If so, that is taken as proof that we have a valid user.

        Returns
        -------
        dict
            Otherwise a copy of the complete `User` record is returned.
            unless there is no `user` member in the current user, then
            the empty dictionary is returned.
        &#34;&#34;&#34;
        User = acg.User
        return AttrDict(**User) if &#34;user&#34; in User else AttrDict({})

    def getUser(self, fromArg=False):
        &#34;&#34;&#34;Obtain the &#34;sub&#34; of the currently logged in user from the request info.

        It works for test/pilot users and normal users.

        Parameters
        ----------
        fromArg: boolean, optional False
            If True, the test/pilot user is not read from the session, but from a
            request argument.
            This is used during the login procedure of test/pilot users.

        Returns
        -------
        boolean, string
            *   Whether the user is a test/pilot user or a normally authenticated user.
                None if there is no authenticated user.
            *   The &#34;sub&#34; of the user.
        &#34;&#34;&#34;
        oidc = self.oidc
        Settings = self.Settings
        runProd = Settings.runProd

        user = None
        isSpecialUser = None

        if not runProd:
            user = requestArg(&#34;user&#34;) if fromArg else sessionGet(&#34;user&#34;)
            if user:
                isSpecialUser = True

        if user is None:
            user = oidc.user_getfield(&#34;sub&#34;) if oidc.user_loggedin else None
            if user:
                isSpecialUser = False

        return (isSpecialUser, user)

    def wrapLogin(self):
        &#34;&#34;&#34;Generate HTML for the login widget.

        De task is to generate login/logout buttons.

        If the user is logged in, his nickname should be displayed, together
        with a logout button.

        If no user is logged in, a login button should be displayed.

        If in test/pilot mode, a list of buttons for each test/pilot user should be
        displayed.

        Returns
        -------
        string
            HTML of the list of buttons for test/pilot users, with the button
            for the current user styled as active.
        &#34;&#34;&#34;
        Settings = self.Settings
        H = Settings.H
        runMode = Settings.runMode
        runProd = Settings.runProd
        Mongo = self.Mongo

        (isSpecialUser, userActive) = self.getUser()

        specialContent = []
        content = []

        def wrap(label, text, title, href, active, enabled):
            &#34;&#34;&#34;Inner function to be called recursively.&#34;&#34;&#34;
            if label:
                content.append(H.span(label, cls=&#34;label&#34;))

            if active:
                cls = &#34;active&#34;
                elem = &#34;span&#34;
                href = []
            else:
                cls = &#34;&#34;
                elem = &#34;a&#34;
                href = [href]

            if not enabled:
                cls = &#34;disabled&#34;
                elem = &#34;span&#34;
                href = []

            fullCls = f&#34;button small {cls}&#34;

            return H.elem(elem, text, *href, cls=fullCls, title=title)

        if not runProd:
            # row of test/pilot users

            enabled = not userActive or isSpecialUser

            for record in sorted(
                Mongo.getList(&#34;user&#34;, sort=&#34;nickname&#34;, isSpecial=True),
                key=lambda r: r.nickname,
            ):
                user = record.user
                name = record.nickname
                role = self.presentRole(record.role)

                active = user == userActive
                specialContent.append(
                    wrap(None, name, role, f&#34;/alogin?user={user}&#34;, active, enabled)
                )

        if userActive:
            # details of logged in user

            details = self.myDetails()
            name = details.nickname
            email = details.email
            userRep = f&#34;{name} - {email}&#34; if email else name
            role = self.presentRole(details.role)
            content.append(wrap(&#34;Logged in as&#34;, userRep, role, None, True, True))

            # logout button
            content.append(
                wrap(None, &#34;log out&#34;, f&#34;log out {name}&#34;, &#34;/alogout&#34;, False, True)
            )

        else:
            # login button
            if runMode != &#34;custom&#34;:
                content.append(wrap(None, &#34;log in&#34;, &#34;log in&#34;, &#34;/alogin&#34;, False, True))

        return (H.content(*specialContent), H.content(*content))

    def presentRole(self, role):
        &#34;&#34;&#34;Finds the interface representation of a role.

        Parameters
        ----------
        role: string
            The internal name of the role.

        Returns
        -------
        string
            The name of the role as it should be presented to users.
            If no representation can be found, the internal name is returned.
        &#34;&#34;&#34;
        Settings = self.Settings
        roles = Settings.auth.roles
        return roles.get(role, role)

    def getInvolvedUsers(self, tableRecordRoles, asString=False):
        &#34;&#34;&#34;Finds the users involved in a specific role with respect to something.

        By this method you can find the organisers of a project, the editors of
        an edition, the admins of the site, etc.

        Parameters
        ----------
        table: string
            Either `site`, `project` or `edition`.
            This indicates the kind of thing that the users are related to.
        tableRecordRoles: tuple
            The tuple consists of tuples `(table, record, role)`
            The users connected to that record in that table in that role
            should be added to the list.
            All roles are specified in the `yaml/authorise.yml` file.

        Returns
        -------
        tuple or string
            If `asString` is False, the result is a datastructure:

            *   whether the information can be disclosed to the current users
            *   the representation of that role on the interface.
            *   a tuple:

                Each item is a tuple, corresponding to a user.
                For each user there are the follwoing fields:

                *   user field in the user table
                *   full name
                *   table of the record to which the user is linked
                *   role in which the user is linked to that record

            If `asString` is True, this data structure will be wrapped in HTML.
        &#34;&#34;&#34;
        Mongo = self.Mongo
        Settings = self.Settings
        H = Settings.H
        auth = Settings.auth

        involvedUsers = []

        for table, record, role in tableRecordRoles:
            roles = auth.roles[table]
            allowed = self.authorise(table, record, action=&#34;read&#34;)
            users = None

            if allowed and roles is not None and roles.get(role, None) is not None:
                userInfo = Mongo.getList(&#34;user&#34;, sort=&#34;nickname&#34;, asDict=&#34;user&#34;)

                if table == &#34;site&#34;:
                    relatedUsers = [
                        uInfo for uInfo in userInfo.values() if uInfo.role == role
                    ]
                else:
                    criteria = {f&#34;{table}Id&#34;: record._id, &#34;role&#34;: role}
                    relatedUserList = Mongo.getList(f&#34;{table}User&#34;, **criteria)
                    relatedUsers = sorted(
                        (userInfo[r.user] for r in relatedUserList),
                        key=lambda x: x.nickname,
                    )
                users = tuple((u.user, u.nickname) for u in relatedUsers)

                involvedUsers.append((table, role, users))

        if not asString:
            return tuple(involvedUsers)

        html = []

        seenUsers = set()

        for table, role, users in sorted(involvedUsers, key=lambda x: -len(x[2])):
            if len(users) == 0:
                continue

            userIds = {u[0] for u in users}

            if len(userIds - seenUsers) == 0:
                continue

            seenUsers |= userIds

            roles = auth.roles[table]
            roleRep = roles[role]

            label = H.i(f&#34;{table} {roleRep}&#34;)
            userRep = &#34; or &#34;.join(H.span(name, uid=u) for (u, name) in users)
            html.append(f&#34;{userRep}{H.nbsp}({label})&#34;)

        return f&#34;ask: {&#39;; &#39;.join(html)}&#34;

    def __loginSpecial(self, referrer, user):
        &#34;&#34;&#34;Perform the steps to log in a test/pilot/custom user.

        This involves looking up the user in the user table,
        copying its information in the application-context-global `User`,
        and storing the user in the session. After that the user is redirected
        to where he came from.

        Parameters
        ----------
        referrer: string
            url where we came from.
        user: string
            The &#34;sub&#34; of the test/pilot user that we must log in as.

        Returns
        -------
        response
            A redirect to the referrer, with a status 302 if the log in was
            successful or 303 if not.
        &#34;&#34;&#34;
        Messages = self.Messages
        Settings = self.Settings
        runMode = Settings.runMode

        if user is None or not self.__findSpecialUser(user):
            return redirectStatus(f&#34;/{referrer}&#34;, False)

        sessionSet(&#34;user&#34;, user)
        name = acg.User.nickname
        Messages.plain(
            logmsg=f&#34;LOGIN successful: {runMode} user {name} {user}&#34;,
            msg=f&#34;LOGIN successful: {runMode} user {name}&#34;,
        )
        return redirectStatus(f&#34;/{referrer}&#34;, True)

    def __loginOidc(self, referrer):
        &#34;&#34;&#34;Redirect step in logging in normal user.

        This means redirecting the user to a url for which authentication
        is required.

        Parameters
        ----------
        referrer: string
            url where we came from. We pass this to the private url.

        Returns
        -------
        response
            A redirect to the referrer, with a status 302 if the log in was
            successful or 303 if not.
        &#34;&#34;&#34;
        return redirectStatus(f&#34;/afterlogin/referrer/{referrer}&#34;, True)

    def __findSpecialUser(self, user):
        &#34;&#34;&#34;Lookup data of a test/pilot user in the MongoDb user table.

        The user is looked up by the `user` field.

        Parameters
        ----------
        user: string
            The `user` of by which a user is looked up, if not None.

        Returns
        -------
        boolean
            Whether a user has been found/created.
            If so, the data of that user record is stored in the
            application-context-global `User`.
        &#34;&#34;&#34;
        Messages = self.Messages
        Mongo = self.Mongo
        User = acg.User

        record = Mongo.getRecord(&#34;user&#34;, user=user)

        if not record:
            Messages.warning(msg=&#34;Unknown user&#34;, logmsg=f&#34;Unknown user {user}&#34;)
            return False

        User.clear()
        for att in PROVIDER_ATTS.values():
            User[att] = record[att]
        User.role = record.role

        return True

    def __findUser(self, user, update=False):
        &#34;&#34;&#34;Lookup user data in the MongoDb user table.

        The user is looked up by the `user` field.
        Optionally, the user record in MongoDb is updated with attributes from
        the identity provider.

        Parameters
        ----------
        user: string
            The `user` of by which a user is looked up, if not None.
        update: boolean, optional False
            Whether to update the user record with fresh attributes of the
            identity provider.

        Returns
        -------
        boolean
            Whether a user has been found/created.
            If so, the data of that user record is stored in the
            application-context-global `User`.
        &#34;&#34;&#34;
        Mongo = self.Mongo
        oidc = self.oidc
        User = acg.User

        record = Mongo.getRecord(&#34;user&#34;, user=user, warn=False)
        newUser = None

        if not record:
            newUser = {
                att: oidc.user_getfield(oidcAtt)
                for (oidcAtt, att) in PROVIDER_ATTS.items()
            }
            userId = Mongo.insertRecord(&#34;user&#34;, role=&#34;user&#34;, **newUser)
            record = Mongo.getRecord(&#34;user&#34;, _id=userId)

        User.clear()
        for att in PROVIDER_ATTS.values():
            User[att] = record[att]
        User.role = record.role

        if update and not newUser:
            changes = {}
            for oidcAtt, att in PROVIDER_ATTS.items():
                orig = User[att]
                new = oidc.user_getfield(oidcAtt)
                if new is not None and orig != new:
                    changes[att] = new
                    User[att] = new
            if changes:
                Mongo.updateRecord(&#34;user&#34;, changes, user=User.user)
        return True</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="control.auth.Auth" href="auth.html#control.auth.Auth">Auth</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="control.users.Users.initUser"><code class="name flex">
<span>def <span class="ident">initUser</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize the storage that keeps the details of the currently
logged-in user.</p>
<p>It will put an empty AttrDict as <em>global</em> in the current application context.</p>
<p>As long as there is no current user, this AttrDict will remain empty.
If there is a current user, or a user logs in, it will get a member
<code>user</code>, which is the <em>sub</em> as it comes from the OIDC authenticator or from
a special login procedure.</p>
<p>It may then also have additional members, such as <code>name</code> and <code>role</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/1a4455072b1ffa872b86f15d4e31826810cd1f2e/src/control/users.py#L63-L77" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@staticmethod
def initUser():
    &#34;&#34;&#34;Initialize the storage that keeps the details of the currently
    logged-in user.

    It will put an empty AttrDict as *global* in the current application context.

    As long as there is no current user, this AttrDict will remain empty.
    If there is a current user, or a user logs in, it will get a member
    `user`, which is the *sub* as it comes from the OIDC authenticator or from
    a special login procedure.

    It may then also have additional members, such as `name` and `role`.
    &#34;&#34;&#34;
    acg.User = AttrDict()</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="control.users.Users.oidc"><code class="name">var <span class="ident">oidc</span></code></dt>
<dd>
<div class="desc"><p>The object that gives access to authentication methods.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="control.users.Users.addAuthenticator"><code class="name flex">
<span>def <span class="ident">addAuthenticator</span></span>(<span>self, oidc)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds the object that gives access to authentication methods.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>oidc</code></strong> :&ensp;<code>object</code></dt>
<dd>The object corresponding to the flask app prepared with the
Flask-OIDC authenticator.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>void</code></dt>
<dd>The object is stored in the <code>oidc</code> member.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/1a4455072b1ffa872b86f15d4e31826810cd1f2e/src/control/users.py#L79-L93" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def addAuthenticator(self, oidc):
    &#34;&#34;&#34;Adds the object that gives access to authentication methods.

    Parameters
    ----------
    oidc: object
        The object corresponding to the flask app prepared with the
        Flask-OIDC authenticator.

    Returns
    -------
    void
        The object is stored in the `oidc` member.
    &#34;&#34;&#34;
    self.oidc = oidc</code></pre>
</details>
</dd>
<dt id="control.users.Users.afterLogin"><code class="name flex">
<span>def <span class="ident">afterLogin</span></span>(<span>self, referrer)</span>
</code></dt>
<dd>
<div class="desc"><p>Logs in a user.</p>
<p>When this function starts operating, the user has been through the login
process provided by the authentication service.</p>
<p>We can now find the user's "sub" and additional attributes in the request
context.</p>
<p>We use that information to lookup the user in the MongoDb users table.
If the user does not exists, we add a new user record, with this "sub" and
these attributes, and role <code>user</code>.</p>
<p>If the user does exists, we check whether we have to update his attributes.
If the attributes found in MongoDb differ from those supplied by the
authentication service, we update the MongoDb values on the basis
of the provider values.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>referrer</code></strong> :&ensp;<code>string</code></dt>
<dd>url where we came from.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>response</code></dt>
<dd>A redirect to the referrer, with a status 302 if the log in was
successful or 303 if not.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/1a4455072b1ffa872b86f15d4e31826810cd1f2e/src/control/users.py#L147-L198" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def afterLogin(self, referrer):
    &#34;&#34;&#34;Logs in a user.

    When this function starts operating, the user has been through the login
    process provided by the authentication service.

    We can now find the user&#39;s &#34;sub&#34; and additional attributes in the request
    context.

    We use that information to lookup the user in the MongoDb users table.
    If the user does not exists, we add a new user record, with this &#34;sub&#34; and
    these attributes, and role `user`.

    If the user does exists, we check whether we have to update his attributes.
    If the attributes found in MongoDb differ from those supplied by the
    authentication service, we update the MongoDb values on the basis
    of the provider values.

    Parameters
    ----------
    referrer: string
        url where we came from.

    Returns
    -------
    response
        A redirect to the referrer, with a status 302 if the log in was
        successful or 303 if not.
    &#34;&#34;&#34;
    Messages = self.Messages
    oidc = self.oidc

    user = None
    referrer = referrer.removeprefix(&#34;/&#34;)

    if oidc.user_loggedin:
        user = oidc.user_getfield(&#34;sub&#34;)
        name = oidc.user_getfield(&#34;nickname&#34;)

    if user is None or not self.__findUser(user, update=True):
        Messages.warning(
            logmsg=f&#34;LOGIN failed for user {user}&#34;,
            msg=&#34;failed to log in&#34;,
        )
        return redirectStatus(f&#34;/{referrer}&#34;, False)

    name = acg.User.nickname
    Messages.plain(
        logmsg=f&#34;LOGIN successful: user {name} {user}&#34;,
        msg=f&#34;LOGIN successful: user {name}&#34;,
    )
    return redirectStatus(f&#34;/{referrer}&#34;, True)</code></pre>
</details>
</dd>
<dt id="control.users.Users.getInvolvedUsers"><code class="name flex">
<span>def <span class="ident">getInvolvedUsers</span></span>(<span>self, tableRecordRoles, asString=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Finds the users involved in a specific role with respect to something.</p>
<p>By this method you can find the organisers of a project, the editors of
an edition, the admins of the site, etc.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>table</code></strong> :&ensp;<code>string</code></dt>
<dd>Either <code>site</code>, <code>project</code> or <code>edition</code>.
This indicates the kind of thing that the users are related to.</dd>
<dt><strong><code>tableRecordRoles</code></strong> :&ensp;<code>tuple</code></dt>
<dd>The tuple consists of tuples <code>(table, record, role)</code>
The users connected to that record in that table in that role
should be added to the list.
All roles are specified in the <code>yaml/authorise.yml</code> file.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code> or <code>string</code></dt>
<dd>
<p>If <code>asString</code> is False, the result is a datastructure:</p>
<ul>
<li>whether the information can be disclosed to the current users</li>
<li>the representation of that role on the interface.</li>
<li>
<p>a tuple:</p>
<p>Each item is a tuple, corresponding to a user.
For each user there are the follwoing fields:</p>
<ul>
<li>user field in the user table</li>
<li>full name</li>
<li>table of the record to which the user is linked</li>
<li>role in which the user is linked to that record</li>
</ul>
</li>
</ul>
<p>If <code>asString</code> is True, this data structure will be wrapped in HTML.</p>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/1a4455072b1ffa872b86f15d4e31826810cd1f2e/src/control/users.py#L439-L530" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getInvolvedUsers(self, tableRecordRoles, asString=False):
    &#34;&#34;&#34;Finds the users involved in a specific role with respect to something.

    By this method you can find the organisers of a project, the editors of
    an edition, the admins of the site, etc.

    Parameters
    ----------
    table: string
        Either `site`, `project` or `edition`.
        This indicates the kind of thing that the users are related to.
    tableRecordRoles: tuple
        The tuple consists of tuples `(table, record, role)`
        The users connected to that record in that table in that role
        should be added to the list.
        All roles are specified in the `yaml/authorise.yml` file.

    Returns
    -------
    tuple or string
        If `asString` is False, the result is a datastructure:

        *   whether the information can be disclosed to the current users
        *   the representation of that role on the interface.
        *   a tuple:

            Each item is a tuple, corresponding to a user.
            For each user there are the follwoing fields:

            *   user field in the user table
            *   full name
            *   table of the record to which the user is linked
            *   role in which the user is linked to that record

        If `asString` is True, this data structure will be wrapped in HTML.
    &#34;&#34;&#34;
    Mongo = self.Mongo
    Settings = self.Settings
    H = Settings.H
    auth = Settings.auth

    involvedUsers = []

    for table, record, role in tableRecordRoles:
        roles = auth.roles[table]
        allowed = self.authorise(table, record, action=&#34;read&#34;)
        users = None

        if allowed and roles is not None and roles.get(role, None) is not None:
            userInfo = Mongo.getList(&#34;user&#34;, sort=&#34;nickname&#34;, asDict=&#34;user&#34;)

            if table == &#34;site&#34;:
                relatedUsers = [
                    uInfo for uInfo in userInfo.values() if uInfo.role == role
                ]
            else:
                criteria = {f&#34;{table}Id&#34;: record._id, &#34;role&#34;: role}
                relatedUserList = Mongo.getList(f&#34;{table}User&#34;, **criteria)
                relatedUsers = sorted(
                    (userInfo[r.user] for r in relatedUserList),
                    key=lambda x: x.nickname,
                )
            users = tuple((u.user, u.nickname) for u in relatedUsers)

            involvedUsers.append((table, role, users))

    if not asString:
        return tuple(involvedUsers)

    html = []

    seenUsers = set()

    for table, role, users in sorted(involvedUsers, key=lambda x: -len(x[2])):
        if len(users) == 0:
            continue

        userIds = {u[0] for u in users}

        if len(userIds - seenUsers) == 0:
            continue

        seenUsers |= userIds

        roles = auth.roles[table]
        roleRep = roles[role]

        label = H.i(f&#34;{table} {roleRep}&#34;)
        userRep = &#34; or &#34;.join(H.span(name, uid=u) for (u, name) in users)
        html.append(f&#34;{userRep}{H.nbsp}({label})&#34;)

    return f&#34;ask: {&#39;; &#39;.join(html)}&#34;</code></pre>
</details>
</dd>
<dt id="control.users.Users.getUser"><code class="name flex">
<span>def <span class="ident">getUser</span></span>(<span>self, fromArg=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Obtain the "sub" of the currently logged in user from the request info.</p>
<p>It works for test/pilot users and normal users.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>fromArg</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>If True, the test/pilot user is not read from the session, but from a
request argument.
This is used during the login procedure of test/pilot users.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>boolean, string</code></dt>
<dd>
<ul>
<li>Whether the user is a test/pilot user or a normally authenticated user.
None if there is no authenticated user.</li>
<li>The "sub" of the user.</li>
</ul>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/1a4455072b1ffa872b86f15d4e31826810cd1f2e/src/control/users.py#L290-L326" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getUser(self, fromArg=False):
    &#34;&#34;&#34;Obtain the &#34;sub&#34; of the currently logged in user from the request info.

    It works for test/pilot users and normal users.

    Parameters
    ----------
    fromArg: boolean, optional False
        If True, the test/pilot user is not read from the session, but from a
        request argument.
        This is used during the login procedure of test/pilot users.

    Returns
    -------
    boolean, string
        *   Whether the user is a test/pilot user or a normally authenticated user.
            None if there is no authenticated user.
        *   The &#34;sub&#34; of the user.
    &#34;&#34;&#34;
    oidc = self.oidc
    Settings = self.Settings
    runProd = Settings.runProd

    user = None
    isSpecialUser = None

    if not runProd:
        user = requestArg(&#34;user&#34;) if fromArg else sessionGet(&#34;user&#34;)
        if user:
            isSpecialUser = True

    if user is None:
        user = oidc.user_getfield(&#34;sub&#34;) if oidc.user_loggedin else None
        if user:
            isSpecialUser = False

    return (isSpecialUser, user)</code></pre>
</details>
</dd>
<dt id="control.users.Users.identify"><code class="name flex">
<span>def <span class="ident">identify</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Make sure who is the current user.</p>
<p>Checks whether there is a current user and whether that user is fully known,
i.e. in the users table of the mongoDb.</p>
<p>If there is a current user that is unknown to the database, the current user
will be cleared.</p>
<p>Otherwise, we make sure that we retrieve the current user's attributes from
the database.</p>
<div class="admonition note">
<p class="admonition-title">No login</p>
<p>We do not try to perform a login of a user,
we only check who is the currently logged in user.</p>
<p>A login must be explicitly triggered by the the <code>/login</code> url.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/1a4455072b1ffa872b86f15d4e31826810cd1f2e/src/control/users.py#L241-L271" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def identify(self):
    &#34;&#34;&#34;Make sure who is the current user.

    Checks whether there is a current user and whether that user is fully known,
    i.e. in the users table of the mongoDb.

    If there is a current user that is unknown to the database, the current user
    will be cleared.

    Otherwise, we make sure that we retrieve the current user&#39;s attributes from
    the database.

    !!! note &#34;No login&#34;
        We do not try to perform a login of a user,
        we only check who is the currently logged in user.

        A login must be explicitly triggered by the the `/login` url.
    &#34;&#34;&#34;
    oidc = self.oidc

    (isSpecialUser, user) = self.getUser()

    if user is not None:
        if isSpecialUser:
            if not self.__findSpecialUser(user):
                acg.User.clear()
                sessionPop(&#34;user&#34;)
        else:
            if not self.__findUser(user, update=False):
                acg.User.clear()
                oidc.logout()</code></pre>
</details>
</dd>
<dt id="control.users.Users.login"><code class="name flex">
<span>def <span class="ident">login</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Log in a user.</p>
<p>Logging in has several main steps:</p>
<ol>
<li>redirecting to a private page, for which login is required</li>
<li>obtaining the authentication results when the user visits that page</li>
<li>storing the relevant user data</li>
</ol>
<p>When we log in test/pilot users, we can skip the first step, because
we already know everything about the test/pilot user on the basis of the
information in the request that brought us here.</p>
<p>So, we find out if we have to log in a test/pilot user or a user that must be
authenticated through oidc.</p>
<p>We only log in a test/pilot user if we are in test/pilot mode and the user's "sub"
is passed in the request.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>response</code></dt>
<dd>A redirect. When logging in in test/pilot mode, the redirect
is to <em>referrer</em> (the url we came from). Otherwise it is to a url
that triggers an oidc login procedure. To that page we pass
the referrer as part of the url, so that after login the user
can be redirected to the original referrer.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/1a4455072b1ffa872b86f15d4e31826810cd1f2e/src/control/users.py#L95-L145" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def login(self):
    &#34;&#34;&#34;Log in a user.

    Logging in has several main steps:

    1. redirecting to a private page, for which login is required
    2. obtaining the authentication results when the user visits that page
    3. storing the relevant user data

    When we log in test/pilot users, we can skip the first step, because
    we already know everything about the test/pilot user on the basis of the
    information in the request that brought us here.

    So, we find out if we have to log in a test/pilot user or a user that must be
    authenticated through oidc.

    We only log in a test/pilot user if we are in test/pilot mode and the user&#39;s &#34;sub&#34;
    is passed in the request.

    Returns
    -------
    response
        A redirect. When logging in in test/pilot mode, the redirect
        is to *referrer* (the url we came from). Otherwise it is to a url
        that triggers an oidc login procedure. To that page we pass
        the referrer as part of the url, so that after login the user
        can be redirected to the original referrer.
    &#34;&#34;&#34;
    Messages = self.Messages
    Settings = self.Settings
    runProd = Settings.runProd

    referrer = getReferrer()
    (isSpecialUser, user) = self.getUser(fromArg=True)
    name = acg.User.nickname

    if user and not isSpecialUser and not runProd:
        Messages.warning(
            logmsg=(
                &#34;LOGIN attempt while an user is already logged in: &#34;
                f&#34;user {name} {user}&#34;
            ),
            msg=f&#34;first log out as user {name}&#34;,
        )
        return redirectStatus(f&#34;/{referrer}&#34;, False)

    return (
        self.__loginSpecial(referrer, requestArg(&#34;user&#34;))
        if isSpecialUser
        else self.__loginOidc(referrer)
    )</code></pre>
</details>
</dd>
<dt id="control.users.Users.logout"><code class="name flex">
<span>def <span class="ident">logout</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Logs off the current user.</p>
<p>First we find out whether we have to log out a test/pilot user or a normal
user.
After logging out, we redirect to the home page.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>response</code></dt>
<dd>A redirect to the home page.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/1a4455072b1ffa872b86f15d4e31826810cd1f2e/src/control/users.py#L200-L239" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def logout(self):
    &#34;&#34;&#34;Logs off the current user.

    First we find out whether we have to log out a test/pilot user or a normal
    user.
    After logging out, we redirect to the home page.

    Returns
    -------
    response
        A redirect to the home page.
    &#34;&#34;&#34;
    oidc = self.oidc
    Settings = self.Settings
    Messages = self.Messages
    name = acg.User.nickname
    runProd = Settings.runProd

    (isSpecialUser, user) = self.getUser()

    if user is None:
        if not runProd:
            sessionPop(&#34;user&#34;)
        else:
            oidc.logout()
        acg.User.clear()
        Messages.plain(logmsg=&#34;LOGOUT but no user was logged in.&#34;)
        return redirectStatus(&#34;/&#34;, False)

    if isSpecialUser:
        sessionPop(&#34;user&#34;)
    else:
        oidc.logout()

    acg.User.clear()
    Messages.plain(
        logmsg=f&#34;LOGOUT successful: user {name} {user}&#34;,
        msg=f&#34;{name} logged out&#34;,
    )
    return redirectStatus(&#34;/&#34;, True)</code></pre>
</details>
</dd>
<dt id="control.users.Users.myDetails"><code class="name flex">
<span>def <span class="ident">myDetails</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Who is the currently authenticated user?</p>
<p>The appplication-context-global <code>User</code> is inspected:
does it contain a member called <code>user</code>?
If so, that is taken as proof that we have a valid user.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>Otherwise a copy of the complete <code>User</code> record is returned.
unless there is no <code>user</code> member in the current user, then
the empty dictionary is returned.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/1a4455072b1ffa872b86f15d4e31826810cd1f2e/src/control/users.py#L273-L288" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def myDetails(self):
    &#34;&#34;&#34;Who is the currently authenticated user?

    The appplication-context-global `User` is inspected:
    does it contain a member called `user`?
    If so, that is taken as proof that we have a valid user.

    Returns
    -------
    dict
        Otherwise a copy of the complete `User` record is returned.
        unless there is no `user` member in the current user, then
        the empty dictionary is returned.
    &#34;&#34;&#34;
    User = acg.User
    return AttrDict(**User) if &#34;user&#34; in User else AttrDict({})</code></pre>
</details>
</dd>
<dt id="control.users.Users.presentRole"><code class="name flex">
<span>def <span class="ident">presentRole</span></span>(<span>self, role)</span>
</code></dt>
<dd>
<div class="desc"><p>Finds the interface representation of a role.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>role</code></strong> :&ensp;<code>string</code></dt>
<dd>The internal name of the role.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>string</code></dt>
<dd>The name of the role as it should be presented to users.
If no representation can be found, the internal name is returned.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/1a4455072b1ffa872b86f15d4e31826810cd1f2e/src/control/users.py#L421-L437" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def presentRole(self, role):
    &#34;&#34;&#34;Finds the interface representation of a role.

    Parameters
    ----------
    role: string
        The internal name of the role.

    Returns
    -------
    string
        The name of the role as it should be presented to users.
        If no representation can be found, the internal name is returned.
    &#34;&#34;&#34;
    Settings = self.Settings
    roles = Settings.auth.roles
    return roles.get(role, role)</code></pre>
</details>
</dd>
<dt id="control.users.Users.wrapLogin"><code class="name flex">
<span>def <span class="ident">wrapLogin</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate HTML for the login widget.</p>
<p>De task is to generate login/logout buttons.</p>
<p>If the user is logged in, his nickname should be displayed, together
with a logout button.</p>
<p>If no user is logged in, a login button should be displayed.</p>
<p>If in test/pilot mode, a list of buttons for each test/pilot user should be
displayed.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>string</code></dt>
<dd>HTML of the list of buttons for test/pilot users, with the button
for the current user styled as active.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/1a4455072b1ffa872b86f15d4e31826810cd1f2e/src/control/users.py#L328-L419" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def wrapLogin(self):
    &#34;&#34;&#34;Generate HTML for the login widget.

    De task is to generate login/logout buttons.

    If the user is logged in, his nickname should be displayed, together
    with a logout button.

    If no user is logged in, a login button should be displayed.

    If in test/pilot mode, a list of buttons for each test/pilot user should be
    displayed.

    Returns
    -------
    string
        HTML of the list of buttons for test/pilot users, with the button
        for the current user styled as active.
    &#34;&#34;&#34;
    Settings = self.Settings
    H = Settings.H
    runMode = Settings.runMode
    runProd = Settings.runProd
    Mongo = self.Mongo

    (isSpecialUser, userActive) = self.getUser()

    specialContent = []
    content = []

    def wrap(label, text, title, href, active, enabled):
        &#34;&#34;&#34;Inner function to be called recursively.&#34;&#34;&#34;
        if label:
            content.append(H.span(label, cls=&#34;label&#34;))

        if active:
            cls = &#34;active&#34;
            elem = &#34;span&#34;
            href = []
        else:
            cls = &#34;&#34;
            elem = &#34;a&#34;
            href = [href]

        if not enabled:
            cls = &#34;disabled&#34;
            elem = &#34;span&#34;
            href = []

        fullCls = f&#34;button small {cls}&#34;

        return H.elem(elem, text, *href, cls=fullCls, title=title)

    if not runProd:
        # row of test/pilot users

        enabled = not userActive or isSpecialUser

        for record in sorted(
            Mongo.getList(&#34;user&#34;, sort=&#34;nickname&#34;, isSpecial=True),
            key=lambda r: r.nickname,
        ):
            user = record.user
            name = record.nickname
            role = self.presentRole(record.role)

            active = user == userActive
            specialContent.append(
                wrap(None, name, role, f&#34;/alogin?user={user}&#34;, active, enabled)
            )

    if userActive:
        # details of logged in user

        details = self.myDetails()
        name = details.nickname
        email = details.email
        userRep = f&#34;{name} - {email}&#34; if email else name
        role = self.presentRole(details.role)
        content.append(wrap(&#34;Logged in as&#34;, userRep, role, None, True, True))

        # logout button
        content.append(
            wrap(None, &#34;log out&#34;, f&#34;log out {name}&#34;, &#34;/alogout&#34;, False, True)
        )

    else:
        # login button
        if runMode != &#34;custom&#34;:
            content.append(wrap(None, &#34;log in&#34;, &#34;log in&#34;, &#34;/alogin&#34;, False, True))

    return (H.content(*specialContent), H.content(*content))</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<p><a href="https://github.com/CLARIAH/pure3dx" title="GitHub repo">GitHub</a></p>
<p><a href="https://github.com/CLARIAH/pure3dx/blob/main/stats.md" title="GitHub repo">code stats</a></p>
<form>
<input id="lunr-search" name="q" placeholder=" Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="control" href="index.html">control</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="control.users.Users" href="#control.users.Users">Users</a></code></h4>
<ul class="two-column">
<li><code><a title="control.users.Users.addAuthenticator" href="#control.users.Users.addAuthenticator">addAuthenticator</a></code></li>
<li><code><a title="control.users.Users.afterLogin" href="#control.users.Users.afterLogin">afterLogin</a></code></li>
<li><code><a title="control.users.Users.getInvolvedUsers" href="#control.users.Users.getInvolvedUsers">getInvolvedUsers</a></code></li>
<li><code><a title="control.users.Users.getUser" href="#control.users.Users.getUser">getUser</a></code></li>
<li><code><a title="control.users.Users.identify" href="#control.users.Users.identify">identify</a></code></li>
<li><code><a title="control.users.Users.initUser" href="#control.users.Users.initUser">initUser</a></code></li>
<li><code><a title="control.users.Users.login" href="#control.users.Users.login">login</a></code></li>
<li><code><a title="control.users.Users.logout" href="#control.users.Users.logout">logout</a></code></li>
<li><code><a title="control.users.Users.myDetails" href="#control.users.Users.myDetails">myDetails</a></code></li>
<li><code><a title="control.users.Users.oidc" href="#control.users.Users.oidc">oidc</a></code></li>
<li><code><a title="control.users.Users.presentRole" href="#control.users.Users.presentRole">presentRole</a></code></li>
<li><code><a title="control.users.Users.wrapLogin" href="#control.users.Users.wrapLogin">wrapLogin</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<a href="https://pure.knaw.nl/portal/en/persons/dirk-roorda">Dirk Roorda</a>
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>