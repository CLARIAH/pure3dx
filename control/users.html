<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>control.users API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>control.users</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/b10d56c9d396baf81f0ad1f8e68fac6fe478a97a/src/pure3d/control/users.py#L1-L555" class="git-link">Browse git</a>
</summary>
<pre><code class="python">from control.generic import AttrDict
from control.flask import (
    requestArg,
    sessionPop,
    sessionGet,
    sessionSet,
    getReferrer,
    redirectStatus,
)


PROVIDER_ATTS = {
    x: x
    for x in &#34;&#34;&#34;
    sub
    email
    nickname
&#34;&#34;&#34;.strip().split()
}
PROVIDER_ATTS[&#34;sub&#34;] = &#34;user&#34;


class Users:
    def __init__(self, Settings, Messages, Mongo):
        &#34;&#34;&#34;All about users and the current user.

        This class has methods to login/logout a user,
        to retrieve the data of the currently logged in user,
        and to query the users table in MongoDb.

        It is instantiated by a singleton object.

        This object has a member `__User` that contains the data of the current
        user if there is a current user.

        Parameters
        ----------
        Settings: AttrDict
            App-wide configuration data obtained from
            `control.config.Config.Settings`.
        Messages: object
            Singleton instance of `control.messages.Messages`.
        Mongo: object
            Singleton instance of `control.mongo.Mongo`.
        &#34;&#34;&#34;
        self.Settings = Settings
        self.Messages = Messages
        Messages.debugAdd(self)
        self.Mongo = Mongo

        self.__User = AttrDict()
        &#34;&#34;&#34;Data of the current user.

        If there is no current user, it has no members.

        Otherwise, it has member `user`, the &#34;sub&#34; of the current user.
        It may also have additional members, such as `name` and `role`.
        &#34;&#34;&#34;

        self.oidc = None
        &#34;&#34;&#34;The object that gives access to authentication methods.
        &#34;&#34;&#34;

    def addAuthenticator(self, oidc):
        &#34;&#34;&#34;Adds the object that gives access to authentication methods.

        Parameters
        ----------
        oidc: object
            The object corresponding to the flask app prepared with the
            Flask-OIDC authenticator.

        Returns
        -------
        void
            The object is stored in the `oidc` member.
        &#34;&#34;&#34;
        self.oidc = oidc

    def login(self):
        &#34;&#34;&#34;Log in a user.

        Logging in has several main steps:

        1. redirecting to a private page, for which login is required
        2. obtaining the authentication results when the user visits that page
        3. storing the relevant user data

        When we log in test users, we can skip the first step, because
        we already know everything about the test user on the basis of the
        information in the request that brought us here.

        So, we find out if we have to log in a test user or a user that must be
        authenticated through oidc.

        We only log in a test user if we are in test mode and the user&#39;s &#34;sub&#34;
        is passed in the request.

        Returns
        -------
        response
            A redirect. When logging in in test mode, the redirect
            is to *referrer* (the url we came from). Otherwise it is to a url
            that triggers an oidc login procedure. To that page we pass
            the referrer as part of the url, so that after login the user
            can be redirected to the original referrer.
        &#34;&#34;&#34;
        Messages = self.Messages
        Settings = self.Settings
        testMode = Settings.testMode

        referrer = getReferrer()
        (testMode, isTestUser, user) = self.getUser(fromArg=True)
        name = self.__User.nickname

        if user and not isTestUser and testMode:
            Messages.warning(
                logmsg=(
                    &#34;LOGIN attempt while an user is already logged in: &#34;
                    f&#34;user {name} {user}&#34;
                ),
                msg=f&#34;first log out as user {name}&#34;,
            )
            return redirectStatus(f&#34;/{referrer}&#34;, False)

        return (
            self.__loginTest(referrer, requestArg(&#34;user&#34;))
            if isTestUser
            else self.__loginOidc(referrer)
        )

    def afterLogin(self, referrer):
        &#34;&#34;&#34;Logs in a user.

        When this function starts operating, the user has been through the login
        process provided by the authentication service.

        We can now find the user&#39;s &#34;sub&#34; and additional attributes in the request
        context.

        We use that information to lookup the user in the MongoDb users table.
        If the user does not exists, we add a new user record, with this &#34;sub&#34; and
        these attributes, and role `user`.

        If the user does exists, we check whether we have to update his attributes.
        If the attributes found in MongoDb differ from those supplied by the
        authentication service, we update the MongoDb values on the basis
        of the provider values.

        Parameters
        ----------
        referrer: string
            url where we came from.

        Returns
        -------
        response
            A redirect to the referrer, with a status 302 if the log in was
            successful or 303 if not.
        &#34;&#34;&#34;
        Messages = self.Messages
        oidc = self.oidc

        user = None
        referrer = referrer.removeprefix(&#34;/&#34;)

        if oidc.user_loggedin:
            user = oidc.user_getfield(&#34;sub&#34;)
            name = oidc.user_getfield(&#34;nickname&#34;)

        if user is None or not self.__findUser(user, update=True):
            Messages.warning(
                logmsg=&#34;LOGIN failed for user {user}&#34;,
                msg=&#34;failed to log in&#34;,
            )
            return redirectStatus(f&#34;/{referrer}&#34;, False)

        name = self.__User.nickname
        Messages.plain(
            logmsg=f&#34;LOGIN successful: user {name} {user}&#34;,
            msg=f&#34;LOGIN successful: user {name}&#34;,
        )
        return redirectStatus(f&#34;/{referrer}&#34;, True)

    def logout(self):
        &#34;&#34;&#34;Logs off the current user.

        First we find out whether we have to log out a test user or a normal
        user.
        After logging out, we redirect to the home page.

        Returns
        -------
        response
            A redirect to the home page.
        &#34;&#34;&#34;
        oidc = self.oidc
        Messages = self.Messages
        name = self.__User.nickname

        (testMode, isTestUser, user) = self.getUser()

        if user is None:
            if testMode:
                sessionPop(&#34;user&#34;)
            else:
                oidc.logout()
            self.__User.clear()
            Messages.plain(logmsg=&#34;LOGOUT but no user was logged in.&#34;)
            return redirectStatus(&#34;/&#34;, False)

        if isTestUser:
            sessionPop(&#34;user&#34;)
        else:
            oidc.logout()

        self.__User.clear()
        Messages.plain(
            logmsg=f&#34;LOGOUT successful: user {name} {user}&#34;,
            msg=f&#34;{name} logged out&#34;,
        )
        return redirectStatus(&#34;/&#34;, True)

    def identify(self):
        &#34;&#34;&#34;Make sure who is the current user.

        Checks whether there is a current user and whether that user is fully known,
        i.e. in the users collection of the mongoDb.

        If there is a current user that is unknown to the database, the current user
        will be cleared.

        Otherwise, we make sure that we retrieve the current user&#39;s attributes from
        the database.

        !!! note &#34;No login&#34;
            We do not try to perform a login of a user,
            we only check who is the currently logged in user.

            A login must be explicitly triggered by the the `/login` url.
        &#34;&#34;&#34;
        oidc = self.oidc

        (testMode, isTestUser, user) = self.getUser()

        if user is not None:
            if isTestUser:
                if not self.__findTestUser(user):
                    self.__User.clear()
                    sessionPop(&#34;user&#34;)
            else:
                if not self.__findUser(user, update=False):
                    self.__User.clear()
                    oidc.logout()

    def myDetails(self):
        &#34;&#34;&#34;Who is the currently authenticated user?

        The `__User` member is inspected: does it contain a field called `user`?
        If so, that is taken as proof that we have a valid user.

        Returns
        -------
        dict
            Otherwise a copy of the complete __User record is returned.
            unless there is no `user` member in the current user, then
            the empty dictionary is returned.
        &#34;&#34;&#34;
        User = self.__User
        return AttrDict(**User) if &#34;user&#34; in User else AttrDict({})

    def getUser(self, fromArg=False):
        &#34;&#34;&#34;Obtain the &#34;sub&#34; of the currently logged in user from the request info.

        It works for test users and normal users.

        Parameters
        ----------
        fromArg: boolean, optional False
            If True, the test user is not read from the session, but from a
            request argument.
            This is used during the login procedure of test users.

        Returns
        -------
        boolean, boolean, string
            Whether we are in test mode.
            Whether the user is a test user.
            The &#34;sub&#34; of the user
        &#34;&#34;&#34;
        oidc = self.oidc
        Settings = self.Settings
        testMode = Settings.testMode

        user = None
        isTestUser = None

        if testMode:
            user = requestArg(&#34;user&#34;) if fromArg else sessionGet(&#34;user&#34;)
            if user:
                isTestUser = True

        if user is None:
            user = oidc.user_getfield(&#34;sub&#34;) if oidc.user_loggedin else None
            if user:
                isTestUser = False

        return (testMode, isTestUser, user)

    def wrapLogin(self):
        &#34;&#34;&#34;Generate HTML for the login widget.

        De task is to generate login/logout buttons.

        If the user is logged in, his nickname should be displayed, together
        with a logout button.

        If no user is logged in, a login button should be displayed.

        If in test mode, a list of buttons for each test-user should be
        displayed.

        Returns
        -------
        string
            HTML of the list of buttons for test users, with the button
            for the current user styled as active.
        &#34;&#34;&#34;
        Settings = self.Settings
        H = Settings.H
        Mongo = self.Mongo

        (testMode, isTestUser, userActive) = self.getUser()

        testContent = []
        content = []

        def wrap(label, text, title, href, active, enabled):
            &#34;&#34;&#34;Inner function to be called recursively.
            &#34;&#34;&#34;
            if label:
                content.append(H.span(label, cls=&#34;label&#34;))

            if active:
                cls = &#34;active&#34;
                elem = &#34;span&#34;
                href = []
            else:
                cls = &#34;&#34;
                elem = &#34;a&#34;
                href = [href]

            if not enabled:
                cls = &#34;disabled&#34;
                elem = &#34;span&#34;
                href = []

            fullCls = f&#34;button small {cls}&#34;

            return H.elem(elem, text, *href, cls=fullCls, title=title)

        if testMode:
            # row of test users

            enabled = not userActive or isTestUser
            for record in sorted(
                Mongo.getList(&#34;user&#34;, isTest=True),
                key=lambda r: r.nickname,
            ):
                user = record.user
                name = record.nickname
                role = self.presentRole(record.role)

                active = user == userActive
                testContent.append(
                    wrap(None, name, role, f&#34;/login?user={user}&#34;, active, enabled)
                )

        if userActive:
            # details of logged in user

            details = self.myDetails()
            name = details.nickname
            email = details.email
            userRep = f&#34;{name} - {email}&#34; if email else name
            role = self.presentRole(details.role)
            content.append(wrap(&#34;Logged in as&#34;, userRep, role, None, True, True))

            # logout button
            content.append(
                wrap(None, &#34;log out&#34;, f&#34;log out {name}&#34;, &#34;/logout&#34;, False, True)
            )

        else:
            # login button
            content.append(wrap(None, &#34;log in&#34;, &#34;log in&#34;, &#34;/login&#34;, False, True))

        return (H.content(*testContent), H.content(*content))

    def presentRole(self, role):
        &#34;&#34;&#34;Finds the interface representation of a role.

        Parameters
        ----------
        role: string
            The internal name of the role.

        Returns
        -------
        string
            The name of the role as it should be presented to users.
            If no representation can be found, the internal name is returned.
        &#34;&#34;&#34;
        Settings = self.Settings
        roles = Settings.auth.roles
        return roles.get(role, role)

    def __loginTest(self, referrer, user):
        &#34;&#34;&#34;Perform the steps to log in a test user.

        This involves looking up the user in the user table,
        copying its information in the `__User` member of this object,
        and storing the user in the session. After that the user is redirected
        to where he came from.

        Parameters
        ----------
        referrer: string
            url where we came from.
        user: string
            The &#34;sub&#34; of the test user that we must log in as.

        Returns
        -------
        response
            A redirect to the referrer, with a status 302 if the log in was
            successful or 303 if not.
        &#34;&#34;&#34;
        Messages = self.Messages

        if user is None or not self.__findTestUser(user):
            return redirectStatus(f&#34;/{referrer}&#34;, False)

        sessionSet(&#34;user&#34;, user)
        name = self.__User.nickname
        Messages.plain(
            logmsg=f&#34;LOGIN successful: test user {name} {user}&#34;,
            msg=f&#34;LOGIN successful: test user {name}&#34;,
        )
        return redirectStatus(f&#34;/{referrer}&#34;, True)

    def __loginOidc(self, referrer):
        &#34;&#34;&#34;Redirect step in logging in normal user.

        This means redirecting the user to a url for which authentication
        is required.

        Parameters
        ----------
        referrer: string
            url where we came from. We pass this to the private url.

        Returns
        -------
        response
            A redirect to the referrer, with a status 302 if the log in was
            successful or 303 if not.
        &#34;&#34;&#34;
        return redirectStatus(f&#34;/afterlogin/referrer/{referrer}&#34;, True)

    def __findTestUser(self, user):
        &#34;&#34;&#34;Lookup data of a test user in the MongoDb users collection.

        The user is looked up by the `user` field.

        Parameters
        ----------
        user: string
            The `user` of by which a user is looked up, if not None.

        Returns
        -------
        boolean
            Whether a user has been found/created.
            If so, the data of that user record is stored in the `__User` member.
        &#34;&#34;&#34;
        Messages = self.Messages
        Mongo = self.Mongo
        User = self.__User

        record = Mongo.getRecord(&#34;user&#34;, user=user)

        if not record:
            Messages.warning(msg=&#34;Unknown user&#34;, logmsg=f&#34;Unknown user {user}&#34;)
            return False

        User.clear()
        for att in PROVIDER_ATTS.values():
            User[att] = record[att]
        User.role = record.role

        return True

    def __findUser(self, user, update=False):
        &#34;&#34;&#34;Lookup user data in the MongoDb users collection.

        The user is looked up by the `user` field.
        Optionally, the user record in MongoDb is updated with attributes from
        the identity provider.

        Parameters
        ----------
        user: string
            The `user` of by which a user is looked up, if not None.
        update: boolean, optional False
            Whether to update the user record with fresh attributes of the
            identity provider.

        Returns
        -------
        boolean
            Whether a user has been found/created.
            If so, the data of that user record is stored in the `__User` member.
        &#34;&#34;&#34;
        Mongo = self.Mongo
        oidc = self.oidc
        User = self.__User

        record = Mongo.getRecord(&#34;user&#34;, user=user, warn=False)
        newUser = None

        if not record:
            newUser = {
                att: oidc.user_getfield(oidcAtt)
                for (oidcAtt, att) in PROVIDER_ATTS.items()
            }
            userId = Mongo.insertRecord(&#34;user&#34;, role=&#34;user&#34;, **newUser)
            record = Mongo.getRecord(&#34;user&#34;, _id=userId)

        User.clear()
        for att in PROVIDER_ATTS.values():
            User[att] = record[att]
        User.role = record.role

        if update and not newUser:
            changes = {}
            for (oidcAtt, att) in PROVIDER_ATTS.items():
                orig = User[att]
                new = oidc.user_getfield(oidcAtt)
                if new is not None and orig != new:
                    changes[att] = new
                    User[att] = new
            if changes:
                Mongo.updateRecord(&#34;user&#34;, changes, user=User.user)
        return True</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="control.users.Users"><code class="flex name class">
<span>class <span class="ident">Users</span></span>
<span>(</span><span>Settings, Messages, Mongo)</span>
</code></dt>
<dd>
<div class="desc"><p>All about users and the current user.</p>
<p>This class has methods to login/logout a user,
to retrieve the data of the currently logged in user,
and to query the users table in MongoDb.</p>
<p>It is instantiated by a singleton object.</p>
<p>This object has a member <code>__User</code> that contains the data of the current
user if there is a current user.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>Settings</code></strong> :&ensp;<code>AttrDict</code></dt>
<dd>App-wide configuration data obtained from
<code><a title="control.config.Config.Settings" href="config.html#control.config.Config.Settings">Config.Settings</a></code>.</dd>
<dt><strong><code>Messages</code></strong> :&ensp;<code>object</code></dt>
<dd>Singleton instance of <code><a title="control.messages.Messages" href="messages.html#control.messages.Messages">Messages</a></code>.</dd>
<dt><strong><code>Mongo</code></strong> :&ensp;<code>object</code></dt>
<dd>Singleton instance of <code><a title="control.mongo.Mongo" href="mongo.html#control.mongo.Mongo">Mongo</a></code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/b10d56c9d396baf81f0ad1f8e68fac6fe478a97a/src/pure3d/control/users.py#L23-L555" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Users:
    def __init__(self, Settings, Messages, Mongo):
        &#34;&#34;&#34;All about users and the current user.

        This class has methods to login/logout a user,
        to retrieve the data of the currently logged in user,
        and to query the users table in MongoDb.

        It is instantiated by a singleton object.

        This object has a member `__User` that contains the data of the current
        user if there is a current user.

        Parameters
        ----------
        Settings: AttrDict
            App-wide configuration data obtained from
            `control.config.Config.Settings`.
        Messages: object
            Singleton instance of `control.messages.Messages`.
        Mongo: object
            Singleton instance of `control.mongo.Mongo`.
        &#34;&#34;&#34;
        self.Settings = Settings
        self.Messages = Messages
        Messages.debugAdd(self)
        self.Mongo = Mongo

        self.__User = AttrDict()
        &#34;&#34;&#34;Data of the current user.

        If there is no current user, it has no members.

        Otherwise, it has member `user`, the &#34;sub&#34; of the current user.
        It may also have additional members, such as `name` and `role`.
        &#34;&#34;&#34;

        self.oidc = None
        &#34;&#34;&#34;The object that gives access to authentication methods.
        &#34;&#34;&#34;

    def addAuthenticator(self, oidc):
        &#34;&#34;&#34;Adds the object that gives access to authentication methods.

        Parameters
        ----------
        oidc: object
            The object corresponding to the flask app prepared with the
            Flask-OIDC authenticator.

        Returns
        -------
        void
            The object is stored in the `oidc` member.
        &#34;&#34;&#34;
        self.oidc = oidc

    def login(self):
        &#34;&#34;&#34;Log in a user.

        Logging in has several main steps:

        1. redirecting to a private page, for which login is required
        2. obtaining the authentication results when the user visits that page
        3. storing the relevant user data

        When we log in test users, we can skip the first step, because
        we already know everything about the test user on the basis of the
        information in the request that brought us here.

        So, we find out if we have to log in a test user or a user that must be
        authenticated through oidc.

        We only log in a test user if we are in test mode and the user&#39;s &#34;sub&#34;
        is passed in the request.

        Returns
        -------
        response
            A redirect. When logging in in test mode, the redirect
            is to *referrer* (the url we came from). Otherwise it is to a url
            that triggers an oidc login procedure. To that page we pass
            the referrer as part of the url, so that after login the user
            can be redirected to the original referrer.
        &#34;&#34;&#34;
        Messages = self.Messages
        Settings = self.Settings
        testMode = Settings.testMode

        referrer = getReferrer()
        (testMode, isTestUser, user) = self.getUser(fromArg=True)
        name = self.__User.nickname

        if user and not isTestUser and testMode:
            Messages.warning(
                logmsg=(
                    &#34;LOGIN attempt while an user is already logged in: &#34;
                    f&#34;user {name} {user}&#34;
                ),
                msg=f&#34;first log out as user {name}&#34;,
            )
            return redirectStatus(f&#34;/{referrer}&#34;, False)

        return (
            self.__loginTest(referrer, requestArg(&#34;user&#34;))
            if isTestUser
            else self.__loginOidc(referrer)
        )

    def afterLogin(self, referrer):
        &#34;&#34;&#34;Logs in a user.

        When this function starts operating, the user has been through the login
        process provided by the authentication service.

        We can now find the user&#39;s &#34;sub&#34; and additional attributes in the request
        context.

        We use that information to lookup the user in the MongoDb users table.
        If the user does not exists, we add a new user record, with this &#34;sub&#34; and
        these attributes, and role `user`.

        If the user does exists, we check whether we have to update his attributes.
        If the attributes found in MongoDb differ from those supplied by the
        authentication service, we update the MongoDb values on the basis
        of the provider values.

        Parameters
        ----------
        referrer: string
            url where we came from.

        Returns
        -------
        response
            A redirect to the referrer, with a status 302 if the log in was
            successful or 303 if not.
        &#34;&#34;&#34;
        Messages = self.Messages
        oidc = self.oidc

        user = None
        referrer = referrer.removeprefix(&#34;/&#34;)

        if oidc.user_loggedin:
            user = oidc.user_getfield(&#34;sub&#34;)
            name = oidc.user_getfield(&#34;nickname&#34;)

        if user is None or not self.__findUser(user, update=True):
            Messages.warning(
                logmsg=&#34;LOGIN failed for user {user}&#34;,
                msg=&#34;failed to log in&#34;,
            )
            return redirectStatus(f&#34;/{referrer}&#34;, False)

        name = self.__User.nickname
        Messages.plain(
            logmsg=f&#34;LOGIN successful: user {name} {user}&#34;,
            msg=f&#34;LOGIN successful: user {name}&#34;,
        )
        return redirectStatus(f&#34;/{referrer}&#34;, True)

    def logout(self):
        &#34;&#34;&#34;Logs off the current user.

        First we find out whether we have to log out a test user or a normal
        user.
        After logging out, we redirect to the home page.

        Returns
        -------
        response
            A redirect to the home page.
        &#34;&#34;&#34;
        oidc = self.oidc
        Messages = self.Messages
        name = self.__User.nickname

        (testMode, isTestUser, user) = self.getUser()

        if user is None:
            if testMode:
                sessionPop(&#34;user&#34;)
            else:
                oidc.logout()
            self.__User.clear()
            Messages.plain(logmsg=&#34;LOGOUT but no user was logged in.&#34;)
            return redirectStatus(&#34;/&#34;, False)

        if isTestUser:
            sessionPop(&#34;user&#34;)
        else:
            oidc.logout()

        self.__User.clear()
        Messages.plain(
            logmsg=f&#34;LOGOUT successful: user {name} {user}&#34;,
            msg=f&#34;{name} logged out&#34;,
        )
        return redirectStatus(&#34;/&#34;, True)

    def identify(self):
        &#34;&#34;&#34;Make sure who is the current user.

        Checks whether there is a current user and whether that user is fully known,
        i.e. in the users collection of the mongoDb.

        If there is a current user that is unknown to the database, the current user
        will be cleared.

        Otherwise, we make sure that we retrieve the current user&#39;s attributes from
        the database.

        !!! note &#34;No login&#34;
            We do not try to perform a login of a user,
            we only check who is the currently logged in user.

            A login must be explicitly triggered by the the `/login` url.
        &#34;&#34;&#34;
        oidc = self.oidc

        (testMode, isTestUser, user) = self.getUser()

        if user is not None:
            if isTestUser:
                if not self.__findTestUser(user):
                    self.__User.clear()
                    sessionPop(&#34;user&#34;)
            else:
                if not self.__findUser(user, update=False):
                    self.__User.clear()
                    oidc.logout()

    def myDetails(self):
        &#34;&#34;&#34;Who is the currently authenticated user?

        The `__User` member is inspected: does it contain a field called `user`?
        If so, that is taken as proof that we have a valid user.

        Returns
        -------
        dict
            Otherwise a copy of the complete __User record is returned.
            unless there is no `user` member in the current user, then
            the empty dictionary is returned.
        &#34;&#34;&#34;
        User = self.__User
        return AttrDict(**User) if &#34;user&#34; in User else AttrDict({})

    def getUser(self, fromArg=False):
        &#34;&#34;&#34;Obtain the &#34;sub&#34; of the currently logged in user from the request info.

        It works for test users and normal users.

        Parameters
        ----------
        fromArg: boolean, optional False
            If True, the test user is not read from the session, but from a
            request argument.
            This is used during the login procedure of test users.

        Returns
        -------
        boolean, boolean, string
            Whether we are in test mode.
            Whether the user is a test user.
            The &#34;sub&#34; of the user
        &#34;&#34;&#34;
        oidc = self.oidc
        Settings = self.Settings
        testMode = Settings.testMode

        user = None
        isTestUser = None

        if testMode:
            user = requestArg(&#34;user&#34;) if fromArg else sessionGet(&#34;user&#34;)
            if user:
                isTestUser = True

        if user is None:
            user = oidc.user_getfield(&#34;sub&#34;) if oidc.user_loggedin else None
            if user:
                isTestUser = False

        return (testMode, isTestUser, user)

    def wrapLogin(self):
        &#34;&#34;&#34;Generate HTML for the login widget.

        De task is to generate login/logout buttons.

        If the user is logged in, his nickname should be displayed, together
        with a logout button.

        If no user is logged in, a login button should be displayed.

        If in test mode, a list of buttons for each test-user should be
        displayed.

        Returns
        -------
        string
            HTML of the list of buttons for test users, with the button
            for the current user styled as active.
        &#34;&#34;&#34;
        Settings = self.Settings
        H = Settings.H
        Mongo = self.Mongo

        (testMode, isTestUser, userActive) = self.getUser()

        testContent = []
        content = []

        def wrap(label, text, title, href, active, enabled):
            &#34;&#34;&#34;Inner function to be called recursively.
            &#34;&#34;&#34;
            if label:
                content.append(H.span(label, cls=&#34;label&#34;))

            if active:
                cls = &#34;active&#34;
                elem = &#34;span&#34;
                href = []
            else:
                cls = &#34;&#34;
                elem = &#34;a&#34;
                href = [href]

            if not enabled:
                cls = &#34;disabled&#34;
                elem = &#34;span&#34;
                href = []

            fullCls = f&#34;button small {cls}&#34;

            return H.elem(elem, text, *href, cls=fullCls, title=title)

        if testMode:
            # row of test users

            enabled = not userActive or isTestUser
            for record in sorted(
                Mongo.getList(&#34;user&#34;, isTest=True),
                key=lambda r: r.nickname,
            ):
                user = record.user
                name = record.nickname
                role = self.presentRole(record.role)

                active = user == userActive
                testContent.append(
                    wrap(None, name, role, f&#34;/login?user={user}&#34;, active, enabled)
                )

        if userActive:
            # details of logged in user

            details = self.myDetails()
            name = details.nickname
            email = details.email
            userRep = f&#34;{name} - {email}&#34; if email else name
            role = self.presentRole(details.role)
            content.append(wrap(&#34;Logged in as&#34;, userRep, role, None, True, True))

            # logout button
            content.append(
                wrap(None, &#34;log out&#34;, f&#34;log out {name}&#34;, &#34;/logout&#34;, False, True)
            )

        else:
            # login button
            content.append(wrap(None, &#34;log in&#34;, &#34;log in&#34;, &#34;/login&#34;, False, True))

        return (H.content(*testContent), H.content(*content))

    def presentRole(self, role):
        &#34;&#34;&#34;Finds the interface representation of a role.

        Parameters
        ----------
        role: string
            The internal name of the role.

        Returns
        -------
        string
            The name of the role as it should be presented to users.
            If no representation can be found, the internal name is returned.
        &#34;&#34;&#34;
        Settings = self.Settings
        roles = Settings.auth.roles
        return roles.get(role, role)

    def __loginTest(self, referrer, user):
        &#34;&#34;&#34;Perform the steps to log in a test user.

        This involves looking up the user in the user table,
        copying its information in the `__User` member of this object,
        and storing the user in the session. After that the user is redirected
        to where he came from.

        Parameters
        ----------
        referrer: string
            url where we came from.
        user: string
            The &#34;sub&#34; of the test user that we must log in as.

        Returns
        -------
        response
            A redirect to the referrer, with a status 302 if the log in was
            successful or 303 if not.
        &#34;&#34;&#34;
        Messages = self.Messages

        if user is None or not self.__findTestUser(user):
            return redirectStatus(f&#34;/{referrer}&#34;, False)

        sessionSet(&#34;user&#34;, user)
        name = self.__User.nickname
        Messages.plain(
            logmsg=f&#34;LOGIN successful: test user {name} {user}&#34;,
            msg=f&#34;LOGIN successful: test user {name}&#34;,
        )
        return redirectStatus(f&#34;/{referrer}&#34;, True)

    def __loginOidc(self, referrer):
        &#34;&#34;&#34;Redirect step in logging in normal user.

        This means redirecting the user to a url for which authentication
        is required.

        Parameters
        ----------
        referrer: string
            url where we came from. We pass this to the private url.

        Returns
        -------
        response
            A redirect to the referrer, with a status 302 if the log in was
            successful or 303 if not.
        &#34;&#34;&#34;
        return redirectStatus(f&#34;/afterlogin/referrer/{referrer}&#34;, True)

    def __findTestUser(self, user):
        &#34;&#34;&#34;Lookup data of a test user in the MongoDb users collection.

        The user is looked up by the `user` field.

        Parameters
        ----------
        user: string
            The `user` of by which a user is looked up, if not None.

        Returns
        -------
        boolean
            Whether a user has been found/created.
            If so, the data of that user record is stored in the `__User` member.
        &#34;&#34;&#34;
        Messages = self.Messages
        Mongo = self.Mongo
        User = self.__User

        record = Mongo.getRecord(&#34;user&#34;, user=user)

        if not record:
            Messages.warning(msg=&#34;Unknown user&#34;, logmsg=f&#34;Unknown user {user}&#34;)
            return False

        User.clear()
        for att in PROVIDER_ATTS.values():
            User[att] = record[att]
        User.role = record.role

        return True

    def __findUser(self, user, update=False):
        &#34;&#34;&#34;Lookup user data in the MongoDb users collection.

        The user is looked up by the `user` field.
        Optionally, the user record in MongoDb is updated with attributes from
        the identity provider.

        Parameters
        ----------
        user: string
            The `user` of by which a user is looked up, if not None.
        update: boolean, optional False
            Whether to update the user record with fresh attributes of the
            identity provider.

        Returns
        -------
        boolean
            Whether a user has been found/created.
            If so, the data of that user record is stored in the `__User` member.
        &#34;&#34;&#34;
        Mongo = self.Mongo
        oidc = self.oidc
        User = self.__User

        record = Mongo.getRecord(&#34;user&#34;, user=user, warn=False)
        newUser = None

        if not record:
            newUser = {
                att: oidc.user_getfield(oidcAtt)
                for (oidcAtt, att) in PROVIDER_ATTS.items()
            }
            userId = Mongo.insertRecord(&#34;user&#34;, role=&#34;user&#34;, **newUser)
            record = Mongo.getRecord(&#34;user&#34;, _id=userId)

        User.clear()
        for att in PROVIDER_ATTS.values():
            User[att] = record[att]
        User.role = record.role

        if update and not newUser:
            changes = {}
            for (oidcAtt, att) in PROVIDER_ATTS.items():
                orig = User[att]
                new = oidc.user_getfield(oidcAtt)
                if new is not None and orig != new:
                    changes[att] = new
                    User[att] = new
            if changes:
                Mongo.updateRecord(&#34;user&#34;, changes, user=User.user)
        return True</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="control.auth.Auth" href="auth.html#control.auth.Auth">Auth</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="control.users.Users.oidc"><code class="name">var <span class="ident">oidc</span></code></dt>
<dd>
<div class="desc"><p>The object that gives access to authentication methods.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="control.users.Users.addAuthenticator"><code class="name flex">
<span>def <span class="ident">addAuthenticator</span></span>(<span>self, oidc)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds the object that gives access to authentication methods.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>oidc</code></strong> :&ensp;<code>object</code></dt>
<dd>The object corresponding to the flask app prepared with the
Flask-OIDC authenticator.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>void</code></dt>
<dd>The object is stored in the <code>oidc</code> member.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/b10d56c9d396baf81f0ad1f8e68fac6fe478a97a/src/pure3d/control/users.py#L64-L78" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def addAuthenticator(self, oidc):
    &#34;&#34;&#34;Adds the object that gives access to authentication methods.

    Parameters
    ----------
    oidc: object
        The object corresponding to the flask app prepared with the
        Flask-OIDC authenticator.

    Returns
    -------
    void
        The object is stored in the `oidc` member.
    &#34;&#34;&#34;
    self.oidc = oidc</code></pre>
</details>
</dd>
<dt id="control.users.Users.afterLogin"><code class="name flex">
<span>def <span class="ident">afterLogin</span></span>(<span>self, referrer)</span>
</code></dt>
<dd>
<div class="desc"><p>Logs in a user.</p>
<p>When this function starts operating, the user has been through the login
process provided by the authentication service.</p>
<p>We can now find the user's "sub" and additional attributes in the request
context.</p>
<p>We use that information to lookup the user in the MongoDb users table.
If the user does not exists, we add a new user record, with this "sub" and
these attributes, and role <code>user</code>.</p>
<p>If the user does exists, we check whether we have to update his attributes.
If the attributes found in MongoDb differ from those supplied by the
authentication service, we update the MongoDb values on the basis
of the provider values.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>referrer</code></strong> :&ensp;<code>string</code></dt>
<dd>url where we came from.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>response</code></dt>
<dd>A redirect to the referrer, with a status 302 if the log in was
successful or 303 if not.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/b10d56c9d396baf81f0ad1f8e68fac6fe478a97a/src/pure3d/control/users.py#L132-L183" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def afterLogin(self, referrer):
    &#34;&#34;&#34;Logs in a user.

    When this function starts operating, the user has been through the login
    process provided by the authentication service.

    We can now find the user&#39;s &#34;sub&#34; and additional attributes in the request
    context.

    We use that information to lookup the user in the MongoDb users table.
    If the user does not exists, we add a new user record, with this &#34;sub&#34; and
    these attributes, and role `user`.

    If the user does exists, we check whether we have to update his attributes.
    If the attributes found in MongoDb differ from those supplied by the
    authentication service, we update the MongoDb values on the basis
    of the provider values.

    Parameters
    ----------
    referrer: string
        url where we came from.

    Returns
    -------
    response
        A redirect to the referrer, with a status 302 if the log in was
        successful or 303 if not.
    &#34;&#34;&#34;
    Messages = self.Messages
    oidc = self.oidc

    user = None
    referrer = referrer.removeprefix(&#34;/&#34;)

    if oidc.user_loggedin:
        user = oidc.user_getfield(&#34;sub&#34;)
        name = oidc.user_getfield(&#34;nickname&#34;)

    if user is None or not self.__findUser(user, update=True):
        Messages.warning(
            logmsg=&#34;LOGIN failed for user {user}&#34;,
            msg=&#34;failed to log in&#34;,
        )
        return redirectStatus(f&#34;/{referrer}&#34;, False)

    name = self.__User.nickname
    Messages.plain(
        logmsg=f&#34;LOGIN successful: user {name} {user}&#34;,
        msg=f&#34;LOGIN successful: user {name}&#34;,
    )
    return redirectStatus(f&#34;/{referrer}&#34;, True)</code></pre>
</details>
</dd>
<dt id="control.users.Users.getUser"><code class="name flex">
<span>def <span class="ident">getUser</span></span>(<span>self, fromArg=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Obtain the "sub" of the currently logged in user from the request info.</p>
<p>It works for test users and normal users.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>fromArg</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>If True, the test user is not read from the session, but from a
request argument.
This is used during the login procedure of test users.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>boolean, boolean, string</code></dt>
<dd>Whether we are in test mode.
Whether the user is a test user.
The "sub" of the user</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/b10d56c9d396baf81f0ad1f8e68fac6fe478a97a/src/pure3d/control/users.py#L272-L308" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getUser(self, fromArg=False):
    &#34;&#34;&#34;Obtain the &#34;sub&#34; of the currently logged in user from the request info.

    It works for test users and normal users.

    Parameters
    ----------
    fromArg: boolean, optional False
        If True, the test user is not read from the session, but from a
        request argument.
        This is used during the login procedure of test users.

    Returns
    -------
    boolean, boolean, string
        Whether we are in test mode.
        Whether the user is a test user.
        The &#34;sub&#34; of the user
    &#34;&#34;&#34;
    oidc = self.oidc
    Settings = self.Settings
    testMode = Settings.testMode

    user = None
    isTestUser = None

    if testMode:
        user = requestArg(&#34;user&#34;) if fromArg else sessionGet(&#34;user&#34;)
        if user:
            isTestUser = True

    if user is None:
        user = oidc.user_getfield(&#34;sub&#34;) if oidc.user_loggedin else None
        if user:
            isTestUser = False

    return (testMode, isTestUser, user)</code></pre>
</details>
</dd>
<dt id="control.users.Users.identify"><code class="name flex">
<span>def <span class="ident">identify</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Make sure who is the current user.</p>
<p>Checks whether there is a current user and whether that user is fully known,
i.e. in the users collection of the mongoDb.</p>
<p>If there is a current user that is unknown to the database, the current user
will be cleared.</p>
<p>Otherwise, we make sure that we retrieve the current user's attributes from
the database.</p>
<div class="admonition note">
<p class="admonition-title">No login</p>
<p>We do not try to perform a login of a user,
we only check who is the currently logged in user.</p>
<p>A login must be explicitly triggered by the the <code>/login</code> url.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/b10d56c9d396baf81f0ad1f8e68fac6fe478a97a/src/pure3d/control/users.py#L224-L254" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def identify(self):
    &#34;&#34;&#34;Make sure who is the current user.

    Checks whether there is a current user and whether that user is fully known,
    i.e. in the users collection of the mongoDb.

    If there is a current user that is unknown to the database, the current user
    will be cleared.

    Otherwise, we make sure that we retrieve the current user&#39;s attributes from
    the database.

    !!! note &#34;No login&#34;
        We do not try to perform a login of a user,
        we only check who is the currently logged in user.

        A login must be explicitly triggered by the the `/login` url.
    &#34;&#34;&#34;
    oidc = self.oidc

    (testMode, isTestUser, user) = self.getUser()

    if user is not None:
        if isTestUser:
            if not self.__findTestUser(user):
                self.__User.clear()
                sessionPop(&#34;user&#34;)
        else:
            if not self.__findUser(user, update=False):
                self.__User.clear()
                oidc.logout()</code></pre>
</details>
</dd>
<dt id="control.users.Users.login"><code class="name flex">
<span>def <span class="ident">login</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Log in a user.</p>
<p>Logging in has several main steps:</p>
<ol>
<li>redirecting to a private page, for which login is required</li>
<li>obtaining the authentication results when the user visits that page</li>
<li>storing the relevant user data</li>
</ol>
<p>When we log in test users, we can skip the first step, because
we already know everything about the test user on the basis of the
information in the request that brought us here.</p>
<p>So, we find out if we have to log in a test user or a user that must be
authenticated through oidc.</p>
<p>We only log in a test user if we are in test mode and the user's "sub"
is passed in the request.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>response</code></dt>
<dd>A redirect. When logging in in test mode, the redirect
is to <em>referrer</em> (the url we came from). Otherwise it is to a url
that triggers an oidc login procedure. To that page we pass
the referrer as part of the url, so that after login the user
can be redirected to the original referrer.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/b10d56c9d396baf81f0ad1f8e68fac6fe478a97a/src/pure3d/control/users.py#L80-L130" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def login(self):
    &#34;&#34;&#34;Log in a user.

    Logging in has several main steps:

    1. redirecting to a private page, for which login is required
    2. obtaining the authentication results when the user visits that page
    3. storing the relevant user data

    When we log in test users, we can skip the first step, because
    we already know everything about the test user on the basis of the
    information in the request that brought us here.

    So, we find out if we have to log in a test user or a user that must be
    authenticated through oidc.

    We only log in a test user if we are in test mode and the user&#39;s &#34;sub&#34;
    is passed in the request.

    Returns
    -------
    response
        A redirect. When logging in in test mode, the redirect
        is to *referrer* (the url we came from). Otherwise it is to a url
        that triggers an oidc login procedure. To that page we pass
        the referrer as part of the url, so that after login the user
        can be redirected to the original referrer.
    &#34;&#34;&#34;
    Messages = self.Messages
    Settings = self.Settings
    testMode = Settings.testMode

    referrer = getReferrer()
    (testMode, isTestUser, user) = self.getUser(fromArg=True)
    name = self.__User.nickname

    if user and not isTestUser and testMode:
        Messages.warning(
            logmsg=(
                &#34;LOGIN attempt while an user is already logged in: &#34;
                f&#34;user {name} {user}&#34;
            ),
            msg=f&#34;first log out as user {name}&#34;,
        )
        return redirectStatus(f&#34;/{referrer}&#34;, False)

    return (
        self.__loginTest(referrer, requestArg(&#34;user&#34;))
        if isTestUser
        else self.__loginOidc(referrer)
    )</code></pre>
</details>
</dd>
<dt id="control.users.Users.logout"><code class="name flex">
<span>def <span class="ident">logout</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Logs off the current user.</p>
<p>First we find out whether we have to log out a test user or a normal
user.
After logging out, we redirect to the home page.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>response</code></dt>
<dd>A redirect to the home page.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/b10d56c9d396baf81f0ad1f8e68fac6fe478a97a/src/pure3d/control/users.py#L185-L222" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def logout(self):
    &#34;&#34;&#34;Logs off the current user.

    First we find out whether we have to log out a test user or a normal
    user.
    After logging out, we redirect to the home page.

    Returns
    -------
    response
        A redirect to the home page.
    &#34;&#34;&#34;
    oidc = self.oidc
    Messages = self.Messages
    name = self.__User.nickname

    (testMode, isTestUser, user) = self.getUser()

    if user is None:
        if testMode:
            sessionPop(&#34;user&#34;)
        else:
            oidc.logout()
        self.__User.clear()
        Messages.plain(logmsg=&#34;LOGOUT but no user was logged in.&#34;)
        return redirectStatus(&#34;/&#34;, False)

    if isTestUser:
        sessionPop(&#34;user&#34;)
    else:
        oidc.logout()

    self.__User.clear()
    Messages.plain(
        logmsg=f&#34;LOGOUT successful: user {name} {user}&#34;,
        msg=f&#34;{name} logged out&#34;,
    )
    return redirectStatus(&#34;/&#34;, True)</code></pre>
</details>
</dd>
<dt id="control.users.Users.myDetails"><code class="name flex">
<span>def <span class="ident">myDetails</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Who is the currently authenticated user?</p>
<p>The <code>__User</code> member is inspected: does it contain a field called <code>user</code>?
If so, that is taken as proof that we have a valid user.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>Otherwise a copy of the complete __User record is returned.
unless there is no <code>user</code> member in the current user, then
the empty dictionary is returned.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/b10d56c9d396baf81f0ad1f8e68fac6fe478a97a/src/pure3d/control/users.py#L256-L270" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def myDetails(self):
    &#34;&#34;&#34;Who is the currently authenticated user?

    The `__User` member is inspected: does it contain a field called `user`?
    If so, that is taken as proof that we have a valid user.

    Returns
    -------
    dict
        Otherwise a copy of the complete __User record is returned.
        unless there is no `user` member in the current user, then
        the empty dictionary is returned.
    &#34;&#34;&#34;
    User = self.__User
    return AttrDict(**User) if &#34;user&#34; in User else AttrDict({})</code></pre>
</details>
</dd>
<dt id="control.users.Users.presentRole"><code class="name flex">
<span>def <span class="ident">presentRole</span></span>(<span>self, role)</span>
</code></dt>
<dd>
<div class="desc"><p>Finds the interface representation of a role.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>role</code></strong> :&ensp;<code>string</code></dt>
<dd>The internal name of the role.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>string</code></dt>
<dd>The name of the role as it should be presented to users.
If no representation can be found, the internal name is returned.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/b10d56c9d396baf81f0ad1f8e68fac6fe478a97a/src/pure3d/control/users.py#L400-L416" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def presentRole(self, role):
    &#34;&#34;&#34;Finds the interface representation of a role.

    Parameters
    ----------
    role: string
        The internal name of the role.

    Returns
    -------
    string
        The name of the role as it should be presented to users.
        If no representation can be found, the internal name is returned.
    &#34;&#34;&#34;
    Settings = self.Settings
    roles = Settings.auth.roles
    return roles.get(role, role)</code></pre>
</details>
</dd>
<dt id="control.users.Users.wrapLogin"><code class="name flex">
<span>def <span class="ident">wrapLogin</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate HTML for the login widget.</p>
<p>De task is to generate login/logout buttons.</p>
<p>If the user is logged in, his nickname should be displayed, together
with a logout button.</p>
<p>If no user is logged in, a login button should be displayed.</p>
<p>If in test mode, a list of buttons for each test-user should be
displayed.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>string</code></dt>
<dd>HTML of the list of buttons for test users, with the button
for the current user styled as active.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/CLARIAH/pure3dx/blob/b10d56c9d396baf81f0ad1f8e68fac6fe478a97a/src/pure3d/control/users.py#L310-L398" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def wrapLogin(self):
    &#34;&#34;&#34;Generate HTML for the login widget.

    De task is to generate login/logout buttons.

    If the user is logged in, his nickname should be displayed, together
    with a logout button.

    If no user is logged in, a login button should be displayed.

    If in test mode, a list of buttons for each test-user should be
    displayed.

    Returns
    -------
    string
        HTML of the list of buttons for test users, with the button
        for the current user styled as active.
    &#34;&#34;&#34;
    Settings = self.Settings
    H = Settings.H
    Mongo = self.Mongo

    (testMode, isTestUser, userActive) = self.getUser()

    testContent = []
    content = []

    def wrap(label, text, title, href, active, enabled):
        &#34;&#34;&#34;Inner function to be called recursively.
        &#34;&#34;&#34;
        if label:
            content.append(H.span(label, cls=&#34;label&#34;))

        if active:
            cls = &#34;active&#34;
            elem = &#34;span&#34;
            href = []
        else:
            cls = &#34;&#34;
            elem = &#34;a&#34;
            href = [href]

        if not enabled:
            cls = &#34;disabled&#34;
            elem = &#34;span&#34;
            href = []

        fullCls = f&#34;button small {cls}&#34;

        return H.elem(elem, text, *href, cls=fullCls, title=title)

    if testMode:
        # row of test users

        enabled = not userActive or isTestUser
        for record in sorted(
            Mongo.getList(&#34;user&#34;, isTest=True),
            key=lambda r: r.nickname,
        ):
            user = record.user
            name = record.nickname
            role = self.presentRole(record.role)

            active = user == userActive
            testContent.append(
                wrap(None, name, role, f&#34;/login?user={user}&#34;, active, enabled)
            )

    if userActive:
        # details of logged in user

        details = self.myDetails()
        name = details.nickname
        email = details.email
        userRep = f&#34;{name} - {email}&#34; if email else name
        role = self.presentRole(details.role)
        content.append(wrap(&#34;Logged in as&#34;, userRep, role, None, True, True))

        # logout button
        content.append(
            wrap(None, &#34;log out&#34;, f&#34;log out {name}&#34;, &#34;/logout&#34;, False, True)
        )

    else:
        # login button
        content.append(wrap(None, &#34;log in&#34;, &#34;log in&#34;, &#34;/login&#34;, False, True))

    return (H.content(*testContent), H.content(*content))</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<p><a href="https://github.com/CLARIAH/pure3dx" title="GitHub repo">GitHub</a></p>
<form>
<input id="lunr-search" name="q" placeholder=" Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="control" href="index.html">control</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="control.users.Users" href="#control.users.Users">Users</a></code></h4>
<ul class="two-column">
<li><code><a title="control.users.Users.addAuthenticator" href="#control.users.Users.addAuthenticator">addAuthenticator</a></code></li>
<li><code><a title="control.users.Users.afterLogin" href="#control.users.Users.afterLogin">afterLogin</a></code></li>
<li><code><a title="control.users.Users.getUser" href="#control.users.Users.getUser">getUser</a></code></li>
<li><code><a title="control.users.Users.identify" href="#control.users.Users.identify">identify</a></code></li>
<li><code><a title="control.users.Users.login" href="#control.users.Users.login">login</a></code></li>
<li><code><a title="control.users.Users.logout" href="#control.users.Users.logout">logout</a></code></li>
<li><code><a title="control.users.Users.myDetails" href="#control.users.Users.myDetails">myDetails</a></code></li>
<li><code><a title="control.users.Users.oidc" href="#control.users.Users.oidc">oidc</a></code></li>
<li><code><a title="control.users.Users.presentRole" href="#control.users.Users.presentRole">presentRole</a></code></li>
<li><code><a title="control.users.Users.wrapLogin" href="#control.users.Users.wrapLogin">wrapLogin</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<a href="https://pure.knaw.nl/portal/en/persons/dirk-roorda">Dirk Roorda</a>
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>